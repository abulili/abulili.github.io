[{"title":"ruankao","path":"/undefined/ruankao/","content":"计算机系统组成 硬件 + 软件 硬件 运算器、控制器、存储器、输入设备、输出设备 其它 汇编程序中，可直接访问通用寄存器存取数据 可访问状态寄存器(标志寄存器，运算器的一部分)获取有关数据处理结果 可通过程序计数器(PC)寻址 不能访问任何指令寄存器 中央处理单元(CPU) 产生每条指令操作信号，并将操作信号送往对应部件，控制相应部件按指令进行操作 运算器、控制器（寄存器组、内部总线） 程序控制、操作控制、时间控制 数据处理 控制器决定了计算机运行过程的自动化 运算器 组成 算数逻辑单元(ALU) 处理数据、算术运算、逻辑运算 由很多部件组成，例如 加法器 等 累加寄存器(AC) 累加器、算通用寄存器 算术逻辑单元执行算数或逻辑运算时，为ALU提供一个工作区，运算结果放在累加器中 运算器中至少存在一个 数据缓冲寄存器(DR) 状态条件寄存器(PSW) 相当于标记 主要功能 算术运算 逻辑运算（与或非） 零值测试：这个值是不是0 所有操作由控制器指挥，只能完成运算，为执行部件 控制器 功能 控制cpu工作，决定计算机运行过程的自动化 保证程序指令正确执行 能处理异常事件 组成 逻辑组成 指令控制逻辑 取指令，分析指令、执行指令 取，译码，按指令操作码执行，形成下一条指令地址 时序控制逻辑 总线控制逻辑 中断控制逻辑 部件 指令寄存器(IR) cpu执行指令时，先把它从内存储器取到缓冲寄存器(DR)中，再送入IR暂存。指令译码器(ID)根据IR的内容产生各种微操作指令，控制其他部件工作 执行指令下都放这里 要识别完了才直接执行 程序计数器(PC) &#x3D; 指令计数器 程序执行的方式：顺序执行&#x2F;转移执行（不按顺序跳） pc内容由cpu修改，pc起始地址在内存加载时确定，顺序执行就pc+1（0x1）&#x2F; 转移执行是当前指令地址+位移量 or 直接地址 地址寄存器(AR) 保存当前CPU所访问内存单元的地址 因为CPU和内存存在操作速度差异，所以需要保持到内存的读写操作完成为止 指令译码器(ID) 指令&#x3D;操作码+地址码 操作码：+ - * &#x2F; &amp; 等 执行指令必须对操作码进行分析 功能：识别指令的操作，向操作控制器发出控制信号控制工作 硬件系统核心 CPU 数据处理、逻辑运算、控制 获取程序指令，译码指令，执行 对系统内外中断（异常）做出响应 存储器 内部 速度高、容量小、临时存放 外部 外部输出设备（外设） 输入、输出设备"},{"title":"校内项目","path":"/undefined/school/","content":"基于socket的在线聊天室（原生+socket） 不给学分的课 地址：https://github.com/abulili/online-chat技术：socket + express + jquery描述：用户在自主选择头像和输入昵称后进入聊天室，实现跨浏览器(express + socket)的带图片、表情(jquery)的实时交流。在交流过程中可以使用文字转语音(pinyin)的功能 难点：太久了，有点忘了，感觉挺简单的功能。 老照片修复（django） 学校内的项目，投了个校刊，另一个项目拿的新型实用专利，感觉和当初想的内容隔了十万八千里。 修复算法是两个开源代码结合在一起的，只负责结合。 太大了传到svn上了，但是域名现在应该过期了 技术：django描述：用户在上传一张照片后可以选择修复划痕&#x2F;修复颜色&#x2F;都修复的功能，选择好之后后台进行处理跳转显示出处理前和出来后的照片。 难点：第一次接触，试了很多种方法想把这两个算法合起来，没成功，最后还是决定分开调用。 二手交易平台（vue2+springboot，前后端分离） 毕业论文产物 感觉还可以往里塞东西补充完美，再说吧 项目地址：https://github.com/abulili/secondStore技术：vue2 + elementui + springboot + mybatis-plus + mysql描述：用户在登录前只能访问主页、商品详情、登录注册页，在商品详情页进行任何操作跳转登录页。登陆后以身份的不同决定主页功能，实现管理员圈定范围内定点交易(腾讯地图 + 凸包)，在线交易、评论、交谈，商品收藏、加入购物车，相关管理，信息举报等功能。 难点： 写完一刷新，信息都没了，引入vuex-persistedstate进行持久化 地图选点的时候，由于用的vue2和官方文档不太一样，没法把圈定范围的点显示，引入vue-bmap-gl解决 上传商品图图片太大，需要压缩图片，引入image-compressor解决 在交流中用户和用户之间一对一的对话失败，并且在用户1主动私信用户2时，用户2必须也点击用户1才能看到用户1的对话，在传输信息过程中在头部加上主动用户的用户名长度和用户名，信息尾部加上被动用户的用户名长度和用户名。 后端由于部分是由mybatis-plus生成的，所以用到哪学到哪，主要是从数据库拿东西有点问题。 优化点： 前端部分： 要花钱的：身份证识别&#x2F;手机号码验证 地图交易那部分可以联通学校库，不同的学校有不同的范围&#x2F;管理 后端部分： 总之就是缺少的电商那一套 基于百度地图的练手项（springboot+html） 给学分的课，这老师教得蛮好 项目地址：https://github.com/abulili/spring-simpleCase技术：springboot + mysql + 原生html描述：对员工基本信息进行显示和管理。网站登录、员工信息的添加、查询、修改、删除操作；对员工的位置信息通过百度地图 API 来进行显示。 难点：jwt 基于vue2和nodejs的音乐系统 不给学分的课 项目地址：https://github.com/abulili/webMusicPlayer技术栈：vue2 + express + elementui + mysql描述：一个播放音乐的网站，用户的登陆注册，能对音乐进行收藏、上传、删除上传，暂停、播放。 难点：音乐播放时进度条的移动，采用组件监听的方式通过播放时长与总时长的百分比，借助vue的双向绑定特性改变。 优化点：播放时字幕随着音乐滚动 调节音量 当时的记录：BFC 使用的fixed，块级格式上下文，规定内部区域元素不会影响到外部区域，最重要的是内部box垂直放置，浮动元素参与计算，垂直距离margin塌陷（clearfix）， 如何创建BFC？(在某些情况下，特定的CSS属性值会使元素自动创建BFC) 根元素，即HTML元素 (每当浏览器遇到一个HTML文档时，它会自动创建一个BFC，这个BFC包含了整个HTML文档的内容) float的值不为none position为absolute或fixed display的值为inline-block (指定对象为内联块元素)、table-cell (指定对象作为表格单元个,类似td)、table-caption (指定对象作为表格标题。类同于html标签caption) overflow的值不为visible BFC的使用场景 去除边距重叠现象 清除浮动（让父元素的高度包含子浮动元素） 避免某元素被浮动元素覆盖 避免多列布局由于宽度计算四舍五入而自动换行 session express-session模块 提一嘴使用v-if和v-show（css） nextTick 解决了异步渲染获取不到更新后DOM的问题了 我也有简单了解nextTick实现，它会在callbacks里面加入我们传入的函数，然后用timerFunc异步方式调用它们，首选的异步方式会是Promise。这让我明白了为什么可以在nextTick中看到dom操作结果。 对数据竖着 ceil取条数，slice进行分割 123&lt;el-row :gutter=&quot;20&quot; v-for=&quot;(row, rowIndex) in Math.ceil(MusicList.length / 4)&quot; :key=&quot;rowIndex&quot;&gt; &lt;el-col :span=&quot;6&quot; v-for=&quot;(item, colIndex) in MusicList.slice(rowIndex * 4, (rowIndex + 1) * 4)&quot; :key=&quot;colIndex&quot;&gt; 还有时间提一嘴如何进行监听去更新音乐播放器进度条 setTimeout，setinterval每个两秒重算 1234567891011this.audio.addEventListener(&#x27;timeupdate&#x27;, () =&gt; &#123; let duration = this.audio.duration; setTimeout(() =&gt; &#123; let currentTime = this.audio.currentTime this.current = currentTime console.log(&#x27;当前播放时间:&#x27;, currentTime) this.percentage = (currentTime / duration) * 100 this.percentage = this.percentage.toFixed(0) console.log(&#x27;播放进度百分比:&#x27;, this.percentage) &#125;, 1000);&#125;); 基于微信小程序的在线论坛（云开发） 给学分的课，软件工程结课产物 忘了，没啥难点吧，写起来还挺顺利的，边查边写 项目地址：https://github.com/abulili/wechat_cloudComment描述：一个可以进行对发帖进行管理、查看浏览历史、收藏的论坛。 难点：评论楼中楼的加载，最终选择评论套评论，仅显示一条，剩下的在用户点击查看更多再进行请求。 当时的记录：节流 节流：（时间内）事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用最先被触发的那次，直到这波过了。所以适用于函数被频繁调用的场景。 防抖： 只有过了设定的时间&amp;&amp;没在设定时间内操作后，才会执行 全局 说一下和vuex很像 vuex:数据存储中心。Vuex其实就是一个状态管理工具，所谓的状态，就是数据，通过这个工具进行管理某些数据。当多个组件都需要同一个数据时，可以将这个数据交给Vuex进行统一的管理. state:vuex的基本数据，用来存储变量，存放的数据是响应式的。 mutations:提交更改数据，同步更新状态。 actions:提交mutations，可异步操作。 getters：是store的计算属性。 modules:模块，每个模块里面有四个属性。 async&#x2F;await async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。 自执行的generate函数。利用generate函数的特性把异步的代码写成“同步”的形式,第一个请求的返回值作为后面一个请求的参数,其中每一个参数都是一个promise对象. 打僵尸游戏（unity） 跟着视频做的，排除了游戏行业，素材实在麻烦，c++写起来还是很爽，做太久都忘了 现在版本落后了，要运行得大改 项目地址：https://github.com/abulili/first_game-购物网站（jsp） 最早的课，怎么又是购物网站，忘了 jsp比较起来真难用，还得是前后端分离 项目地址：https://github.com/abulili/jsp_Web_mysql_SHOP/tree/main其他的课太落后就不管了"},{"title":"其它1","path":"/undefined/compang1/","content":"这样应该不算违反保密协议吧… 大屏项目负责部分：对接口 封装当时存在的一部分babylon方法为SDK，使其可以直接被引用 打包apk 实现大屏适配 通过优化遗留下来的方法，使响应速度提升30%，优化请求数 优化控制端分辨率 参与处理rtsp监控视频流 模型替换及改变（threeJs） 修改模型及交互条件（babylonJs） 其它网页端项目录制网页，全景图 照模板写调研文档，写招标文件 地图调研，接口调用 手机端项目迁移网页端项目至app端 uniapp"},{"title":"实习1","path":"/undefined/workOne/","content":"对我做的第一个在公司的项目做一个总结 看不懂要表达什么，再说吧 html123456&lt;el-table-column label=&quot;操作&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button size=&quot;mini&quot; @click.native.prevent=&quot;handleEdit(scope.$index, wordsLists)&quot;&gt;编辑&lt;/el-button&gt; &lt;el-button size=&quot;mini&quot; type=&quot;danger&quot; @click.native.prevent=&quot;handleDelete(scope.$index, wordsLists)&quot;&gt;移除 &lt;/el-button&gt; &lt;/template&gt;&lt;/el-table-column&gt; 12345&lt;el-table-column fixed prop=&quot;a&quot; label=&quot;详情链接&quot; width=&quot;220px&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button size=&quot;mini&quot; @click=&quot;jumpBaidu(scope.row)&quot;&gt;点击跳转百度百科&lt;/el-button&gt; &lt;/template&gt;&lt;/el-table-column&gt; vue:在引用时 1234const requestMethods = &#123; // 得到后端的服务，存关键路名（暂时只处理路名） onSuccess(response, file, fileList) &#123;&#125; &#125; 1234&lt;script src=&quot;./../../http/request.js&quot;&gt;&lt;/script&gt;methods: &#123;\tonSuccess: requestMethods.onSuccess,&#125; 获取图片imgNode,在无法用自带的file时 12345678910111213onChange(file) &#123; console.log(&#x27;onChange&#x27;, file) let id = setInterval(() =&gt; &#123; const images = document.getElementsByTagName(&#x27;img&#x27;); if (images.length != 0) &#123; // 后面记得清空 v.imgNode = images[0] clearInterval(id) // console.log(v.imgNode.src.substring(5, v.imgNode.src.length)) v.getImgLocation() &#125; &#125;, 1000); &#125;, 添加的时候就去重了 12345678910if (!v.data1.includes(&#123; key: i, label: v.wordsLists[i].content, disabled: false &#125;)) v.data1.push(&#123; key: i, label: v.wordsLists[i].content, disabled: false &#125;) 杂筛选以市州结尾，前面不带市州的字符串 1234567891011var pattern = /[^市州]+[市州]/g;var matches = word.match(pattern);if (matches) &#123; matches.forEach(function (match) &#123; if (!v.ProvinceList.includes(match)) v.ProvinceList.push(match) return true &#125;); &#125; else &#123; return false &#125; axios.post上传file 123456789101112131415imgTags(file) &#123; const formData = new FormData(); formData.append(&#x27;file&#x27;, file.__ob__.value.raw); // 将文件添加到FormData对象中 axios.post(&#x27;&#x27;, formData, &#123; // 使用axios发送POST请求到服务器 headers: &#123; &#x27;Content-Type&#x27;: &#x27;multipart/form-data&#x27; // 设置请求头为multipart/form-data &#125; &#125;).then(response =&gt; &#123; console.log(response.data.result) v.TagsDeal(response.data.result) // 处理响应数据 &#125;).catch(error =&gt; &#123; // 处理错误信息 &#125;); &#125;,"},{"title":"BFS","path":"/undefined/BFS/","content":"🔗 对于步骤一直出错，不如直接queue&lt;pair&lt;int, int&gt;&gt;; 以下为贪心推导 双端队列bfs:基本用法差不多，但是 w &#x3D; 0放头， w &#x3D; 1放尾（类似与dp）"},{"title":"背包合集","path":"/undefined/bagT/","content":"复习下 01背包、完全背包、多重背包、混合背包的板子 基础P1216 [USACO1.5] [IOI1994]数字三角形 Number Triangleshttps://www.luogu.com.cn/problem/P1216 这道题说明了背包的最终态与初始态之间的关系。 在我的理解里就是所有的路径汇总到一起形成一个唯一的最终态（值是唯一，因为是最大值） 最长公共子序列字符串 abcde 与字符串 acde 最长公共子序列acde 当出现两个不同的需要计算状态，并需要得到最终统一态，则分开计算共同判断 12f[i][j] i为A前i个字符，j为B前i个字符A的前i个字符和B的前j个字符最大有多少个相同的 最长不下降子序列以怎么样的、什么结尾是这道的核心 以ai结尾 upper_bound找出可替换的数替换 [NOIP2005] 采药https://www.luogu.com.cn/problem/P1048"},{"title":"2882. 「JOISC 2014 Day4」两个人的星座","path":"/undefined/joisc2014/","content":"题目链接oi-wiki链接题解参考 先看oi-wiki的，不懂再看这个 将[-180°,+180°] &#x3D;&gt; [0°,360°] 12if(b[i].tan &lt;= 0) b[i].tan += pi; 由极轴定义：极轴是原点向正y延伸的射线或线段。 故b[i].y &lt; 0代表极轴下半轴；当b[i].y &#x3D;&#x3D; 0 时代表点在极轴上，当b[i].x &gt; 0时表示$&#x2F;theta$为0而不为Π，在极轴下方 1if(b[i].y &lt; 0 || (b[i].y == 0 &amp;&amp; b[i].x &gt; 0)) 在u点进行极轴的改变（旋转），上下点的数量发生变化，该减减，该加加 一个点b[i]可能会被用于多个三角形的构造中，因此需要在统计完一个三角形后将涉及到的点b[i]的状态取反（即从极轴上方变为下方或从下方变为上方），以避免重复统计。 123456for (int i = 1; i &lt;= st; ++i) &#123; sum[bl[i]][b[i].c]--; ans += calc(0, b[i].c) * calc(1, a[u].c); ans += calc(1, b[i].c) * calc(0, a[u].c); sum[bl[i] ^= 1][b[i].c]++;&#125; 对每个三角形而言，涉及到的两个点都会被a[u]更新，同一条公切线会被枚举两次。 1cout &lt;&lt; ans / 4;"},{"title":"springboot","path":"/undefined/springboot/","content":"以前（见：springboot大作业）虽然也使用过，但是没有系统学过。 还是边看视频边学吧 最终目标：基础-&gt;高并发 锋迷商城视频地址：https://www.bilibili.com/video/BV12p4y187Dj 运营模式 B2C:平台与买家（小米商城） ​ 维护商品、用户 C2B2C:都是平台用户（淘宝&#x2F;闲鱼） ​ 维护买家、卖家、商品、服务 开发模式 企业级开发（供企业内部使用，无注册） 互联网开发（所有用–用户量级） 技术选型SSM企业开发框架–基础开发技术，可以用springboot代替 演化：单体-前后端分离-分布式-微服务 单体项目：一个项目里面包含这个项目中全部代码,一个应用搞定全部功能,部署到服务器上，然后用户进行请求.jsp 前后端分离：.html + ajax 分布式项目：把一个项目按照特定要求（模块或功能）拆分成多个项目，每个项目分别部署到不同的服务器上。mysql可能会挂，多个服务器访问一个mysql 基于redis实现分布式锁 分布式数据库mysql redis集群 数据库中间件 消息中间件 微服务：将一个单一应用程序开发为一组小型服务的方法，单独开发和部署 关于tomcat Tomcat只能处理200-300个请求 java部署只能用tomcat Tomcat后端的服务器可以再加（服务器集群），但可能会造成忙的忙死闲的闲死，所以需要在之前设置一个总的服务器来处理请求交给哪个服务器（负载均衡） 服务器集群：多个服务器构成的整体 服务器节点：集群中的某台服务器 负载：服务器压力 将对集群的并发请求按需分配到不同的服务器节点上 此项目涉及到的技术 项目架构：前后端分离 前端：vue+axios+layui+bootstrap+ui 后端：springboot+MyBatis+RESTful+swagger 服务器搭建：Linux、Nginx MyBatis:基于Java语言的持久层框架,它通过XML描述符或注解将对象与存储过程或SQL语句进行映射,并提供了普通SQL查询、存储过程和高级映射等操作方式 RESTful:一种架构的规范与约束、原则，符合这种规范的架构就是RESTful架构。 swagger是一款可以根据resutful风格生成的生成的接口开发文档，并且支持做测试的一款中间软件。 Nginx 可以作为静态页面的 web 服务器，万级并发 SpringBootSpringboot应用需要依赖远程服务器进行创建 springboot官方：https://start.spring.io 阿里：https://start.aliyun.com 创建要联网 Version 是项目的版本号，例：1.0-SNAPSHOT 。其中1.0是版本号，SNAPSHOT版本代表不稳定、尚处于开发中的版本。而衍生的有Release版本则代表稳定的版本 snapshot不用，平台不稳定 第二种是网页创建 解决方法： https://blog.csdn.net/C_Engineer/article/details/130835522 或者在网页上打开https://start.aliyun.com/ https://start.spring.io/ 配置springboot完成通用性配置 深色可删 maven窗口打开：https://blog.csdn.net/weixin_44438032/article/details/121701104 对自创建的文件夹和包作映射 12mybatis.mapper-locations=classpath:mappers/*Mapper.xmlmybatis.type-aliases-package=com.abc.spring.demo.entity 在启动界面给出dao包的路径就可以使用了 1@MapperScan(&quot;com.abc.spring.demo.dao&quot;) 因为springboot应用自带servlet容器-tomcat，因此无需进行额外的服务配置，所以应用只需要启动类就可以了 启动失败之源发行版 17 需要目标发行版 17 https://blog.51cto.com/u_16213423/7066869 啊啊啊啊啊今天就看不懂了-2023.11.26 换一个看算了 版本管理https://www.bilibili.com/video/BV12p4y187Dj?t=848.7&amp;p=14 https://www.bilibili.com/video/BV13a411q753 https://www.bilibili.com/video/BV1bf4y1V7Bx 电脑商城https://www.bilibili.com/video/BV1bf4y1V7Bx/?spm_id_from=333.999.0.0&amp;vd_source=32c7f6ec6ba676c7527b509106db968a 某一模块的开发 持久层开发：依据前端页面的设置规划相关的sql语句 业务层开发：核心功能控制、业务操作、异常处理 控制层开发：接收请求、处理响应 版本jdk：1.8以上，maven：3.6.1，mariadb&#x2F;mysql：5.1以上 企业电商项目建立项目 maven&#x2F;java web&#x2F;mybatis framwork&#x2F;mysql driver 数据库配置 src&#x2F;main&#x2F;resources&#x2F;application.properties 现在只用前三个 创建数据库测试连接启动Springboot主类，是否有对应Spring图形输出，有无报错（例如版本） 在单元测试类中测试数据库连接是否可以正常加载 test文件就是整个目录的测试类 在test的主类下面 12345678如果要测试某个单元，需要加载数据源信息需要Spring自动装配,使用注解进行修饰的描述@Autowired这个数据源信息是类的对象，所以要声明出来private DataSource dataSource;@Test 写注解表明是测试类void getConnection()&#123;&#125; 鼠标，是自动抛异常 现在输出看有没有这个类 有Hikar代表跑通了 出问题了老师 源发行版 17 需要目标发行版 17 jdk版本之类不匹配，要统一 project structure-&gt;project-&gt;sdk版本 ​ -&gt;modules-&gt;language level settings-&gt;javacomplier-&gt;project bytecode version选择 ​ -&gt;module选择 pom文件java.version检查 请删除该文件或确保该文件位于正确的类路径子目录中 springboot与jdk版本冲突，3.x版本不支持jdk1.8 springboot所有版本号：https://zhuanlan.zhihu.com/p/652895555 dependencies.dependency.version‘ for mysql:mysql-connector-java:jar is missing Unable to instantiate org.springframework.boot.sql.init.dependency.DependsOnDatabaseInitializationDetector [org.mybatis.spring.boot.autoconfigure.MybatisDependsOnDatabaseInitializationDetector] mybatis版本与spring不匹配 改为了2.3.0 点下面的dependency可以直接修改版本，就不用去找哪个版本号才是存在的了 所有静态资源复制到static目录下 idea对于js代码兼容性较差，编写了js代码又是不能加载 1.idea缓存清理 2.clear-&gt;install 3.rebuild 4.重启idea和操作系统 web下是要访问的静态资源 所以 localhost:8080&#x2F;web&#x2F;index.html 又肯初次加载不成功，就2，打开侧栏maven&#x2F;lifecycle&#x2F;clean双击等待加载完后install 123456789101112131415161718comment注解 盐值指加密create table t_user(\tuid int auto_increment comment &#x27;用户id&#x27;,\tusername varchar(20) not null comment &#x27;用户名&#x27;,\tpassword char(32) not null comment &#x27;密码&#x27;,\tsalt char(36) comment &#x27;盐值&#x27;,\tphone varchar(20) comment &#x27;电话号码&#x27;,\temail varchar(30) comment &#x27;电子邮箱&#x27;,\tgender int comment &#x27;性别：0-女，1-男&#x27;,\tavatar varchar(50) comment &#x27;头像&#x27;,\tis_delete int comment &#x27;是否删除：0-未删除，1-已删除&#x27;,\tcreated_user varchar(20) comment &#x27;日志-创建人&#x27;,\tcreated_time DATETIME comment &#x27;日志-创建时间&#x27;,\tmodified_user varchar(20) comment &#x27;日志-最后修改执行人&#x27;,\tmodified_time DATETIME comment &#x27;日志-最后修改事件&#x27;,\tPRIMARY key (uid)) ENGINE=INNODB DEFAULT CHARSET=utf8; 有些公司直接校验is_delete是不是1已删除，没有做真删除的操作 12345678910111213141516171819202122create table t_address(\taid int auto_increment comment &#x27;用户id&#x27;,\tuid int comment &#x27;归属的用户id&#x27;,\tname varchar(20) comment &#x27;收货人姓名&#x27;,\tprovince_name varchar(15) comment &#x27;省-名称&#x27;,\tprovince_code char(6) comment &#x27;省-行政代号&#x27;,\tcity_name varchar(15) comment &#x27;市-名称&#x27;,\tcity_code char(6) comment &#x27;市-行政代号&#x27;,\tarea_name varchar(15) comment &#x27;区-名称&#x27;,\tarea_code char(6) comment &#x27;区-行政代号&#x27;,\tzip char(6) comment &#x27;邮政编码&#x27;,\taddress varchar(50) comment &#x27;详细地址&#x27;,\tphone varchar(20) comment &#x27;手机&#x27;,\ttel varchar(20) comment &#x27;固话&#x27;,\ttag varchar(6) comment &#x27;标签&#x27;,\tis_default int comment &#x27;是否默认：0-不默认，1-默认&#x27;,\tcreated_user varchar(20) comment &#x27;创建人&#x27;,\tcreated_time Datetime comment &#x27;创建事件&#x27;,\tmodified_user varchar(20) comment &#x27;修改人&#x27;,\tmodified_time datetime comment &#x27;修改时间&#x27;,\tPRIMARY key (aid)) ENGINE=INNODB DEFAULT CHARSET=utf8; 用户注册创建用户的实体类公共字段放在实体类的基类中，BaseEntity 1public class BaseEntity implements Serializable Serializable是一个对象序列化的接口,一个类只有实现了Serializable接口,它的对象才是可序列化的 序列化就是将对象属性转变为二进制数据 1java变量命名规范--createdUser 声明方法 @Data或者generate来生成 对于老版本来说lombok有时候兼容性差 这里使用generator-getter ans setter 然后是equal的hashcode方法 -比较两个对象是否相等，定义相等的规则 toString方法 -方便进行测试 创建用户的实体类这里需要继承BaseEntity的基类 非传统三大层要用@Component修饰，spring才能自动进行对象的创建维护 而SpringBoot开发更简洁，遵循约定大于配置 持久层 规划需要执行的sql语句，通过mybatis操作数据库，做mybatis开发的流程 用户注册 insert into t_user(username, password) values (值列表) select * from t_user where username=? 123456789- **设计接口和抽象方法**，定义Mapper接口 - 目录结构下创建mapper包，在这个包下根据不同的功能模块创建不同的mapper接口,要在接口中定义sql语句抽象方法 - 创建UserMapper接口（interface） - ```java public interface UserMapper - （快速注释/**回车） - ![image-20231210215628176](D:\\Typeeasy\\image-20231210215628176.png) - 添加Mappe注解修饰 - 缺陷：一个项目中很多Mapper - 解决：主添加包路径 - ![image-20231210215845733](D:\\Typeeasy\\image-20231210215845733.png) 编写映射，定义xml映射文件，与对应的接口进行关联 资源文件，放resoureces&#x2F;mapper&#x2F; 创建接口对应的映射文件，和接口名称保持一致 https://mybatis.org/mybatis-3/zh/getting-started.html &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; namespace属性用于指当前的映射文件和哪个接口进行映射，需要指定接口的文件路径，需要标注包的完整路径接口 namespace=&quot;org.cy.store.UserMapper&quot; &lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt; &lt;select id=&quot;selectBlog&quot; resultType=&quot;Blog&quot;&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; 12345- 配置接口中的方法对应上sql语句，需要借助标签完成 - ``` insert/update/delete/select 比以前直接在方法里写sql语句好，起到了解耦的作用，sql语句变了，但是java代码不用做任何改变 建议关键词用大写，#{}占位符，因为里面的数据是动态的 id关联 select查询返回的是1~n个对象 resultType：要求表字段和属性一模一样 resultMap：表资源和类的对象属性字段名称不一致时，来自定义查询结果的映射规则 映射规则一般放在前面，resultMap标签来完成映射规则的定义 column是数据库表的字段，property是属性的名字 把id值作为下面结果的映射 改一下下划线为大写 id=&quot;insert&quot; uid没有进行插入操作，mybatis不会自动做这个表值的触发，所以要开启主键自增 加配置 mybatis.mapper-locations=classpath:mapper/*.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071- **单元测试** - 每个独立的层编写完毕后需要编写单元测试，测试当前功能 - test/mapper/下进行测试 ![image-20231211125504470](D:\\Typeeasy\\image-20231211125504470.png) - ![image-20231211125609548](D:\\Typeeasy\\image-20231211125609548.png) - 因为mybatis帮忙创建了这个接口的动态代理的实现类，现在才能用这个接口 ![image-20231211221114223](D:\\Typeeasy\\image-20231211221114223.png) - 或者![image-20231211221338913](D:\\Typeeasy\\image-20231211221338913.png) - 注解也可以，但麻烦一点##### 业务层- 规划异常 - 用户进行注册时，可能会产生被占用的错误，抛出一个异常（RuntimeException）：java自带异常太宽泛，所以自己写比较好，但自己写的可以作为自带异常的子类来继承这个异常。业务层异常的基类，ServiceException异常。异常机制 - 关于业务层的异常E - 异常的接口I -因为面向接口编程 - 接口依赖于实现类 impl - alt + fn + insert选择override重写RuntimeException父类的全部方法 - 就有很多可以new的不同的异常信息了 - 根据业务层不同的功能来详细定义具体的异常的类型，统一继承ServiceException - 正在执行数据插入操作时，服务器、数据库宕机，处于正在执行插入的过程中出现的错误InsertException- 设计接口 + 抽象方法 - 命名：I开头，业务层末尾跟上Service - 创建一个实现类的UserServiceImpl类，实现这个接口，并且实现抽象方法 - 重写接口 - 看底层需要什么参数（mapper/UserMapper），声明后再自动装配 - 做操作，思考可能出现的异常（在这里是插入异常，查询异常，也可以认为是不该出现的/不想出现的结果） - 根据数据库来决定- 单元测试 UserServiceTests - 为UserServicceImpl添加@Service业务层描述 - @Service：将当前类的对象交给Spring管理，自动创建对象及对象的维护- 测试完后想把密码不以明文形式展示，采用md5进行加密 - 串 + password + 串 ---&gt; md5算法进行加密，连续加密三次 盐值 + password + 盐值 --- 盐值本身是一个随机的字符串 - `String salt = UUID.randomUUID().toString().toUpperCase();` - 整体加密，用byte版的（因为字符串很容易转换为字节） - 将加密之后的密码重新补全设置到user对象中 - 忽略了原有莫玛强度，提示了数据的安全性 - 盐值salt也要记下来，不然没法验证密码对不对##### 控制层- 创建响应、状态描述信息、数据，这部分功能封装到一个类中，将这类方法作为返回值，返回给前端浏览器 - JsonResult - 要实现返回json数据的格式，需要继承Serializable ![img](D:\\Typeeasy\\OR@KW@80RP7XDA82(7@)N`A.png) - 方法按可能出现的返回结果进行构造- 设计请求 - 根据当前业务功能模块进行请求的设计 - ``` 请求路径：/user/reg 请求参数：User user 请求类型：POST 响应结果：JsonResult&lt;Void&gt; 处理请求 创建一个控制层对应的类UserController类，依赖于业务层的接口，要添加相应的注解@Controller @RequestMapping(&quot;users&quot;)定义什么样的接口会被拦截测试 @ResponseBody 表示此方法的响应结果以json格式进行数据的响应给前端 但是这样就每一个都要写，麻烦 推荐按组合注解 @RestController ( &#x3D; @Controller + @RespenseBody) package com.cy.store.controller; import com.cy.store.entity.User; import com.cy.store.service.IUserService; import com.cy.store.service.ex.InsertException; import com.cy.store.service.ex.UsernameDuplicatedException; import com.cy.store.util.JsonResult; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(&quot;users&quot;) public class UserController &#123; @Autowired private IUserService userService; @RequestMapping(&quot;reg&quot;) public JsonResult&lt;Void&gt; req(User user) &#123; // 创建响应结果对象 JsonResult&lt;Void&gt; result = new JsonResult&lt;&gt;(); try &#123; userService.reg(user); result.setState(200); result.setMessage(&quot;用户注册成功&quot;); &#125; catch (UsernameDuplicatedException e) &#123; // 可能碰到用户名被占用的错误 result.setState(4000); result.setMessage(&quot;用户名被占用&quot;); &#125; catch (InsertException e) &#123; // 可能碰到用户名插入时的错误 result.setState(5000); result.setMessage(&quot;注册时产生位置异常&quot;); &#125; return result; &#125; &#125; 123456789101112131415161718192021222324252627282930- 但是这样有点麻烦了，因为业务层抛出的所有异常都需要控制层去处理，如果其它业务层也有这些问题，那就还要改- 控制层优化设计 - 在控制层抽离一个父类，在这个父类中统一的去处理关于异常的相关操作。BaseController统一处理 - @ExceptionHandler 用于统一处理抛出的异常，定义在方法上面，会自动将异常对象传递给此方法的参数列表上 - @ExceptionHandler(ServerCloneException.class) 凡是ServerCloneException.class抛出的异常都会被这个方法拦截##### 前端页面注册- 点击事件，($(&quot;选择器&quot;))，再去添加点击的事件，`$.ajax()`函数是jquery封装的一个函数，通过对象调用了ajax函数，可以异步加载相关的请求。依靠的是javascript提供的一个对象XHR（XmlHttpResponse），封装了这个对象- ajax使用方式，需要传递一个方法体作为方法的参数使用；一堆大括号：方法体 接收多个参数，参数与参数之间使用&quot;,&quot;分割，每一组参数之间使用&quot;:&quot;分割，参数的值要求用字符串来标识，参数声明顺序没有要求 ```javascript $.ajax(&#123; url: &quot;&quot;, type: &quot;&quot;, data: &quot;&quot;, dataType: &quot;&quot;,//提交的数据类型，一般指定为jsons success: funciton() &#123; //当服务器正常响应客户端时，会自动调用success参数的方法，并且将服务器返回的数据以参数的形式传递给这个方法的参数上 &#125;, error: function() &#123; &#125; &#125;); 但是这样还是麻烦了 jquery提供的序列化api，#form-reg是表单的id 由后端返回的数据类型 js代码无法正常被服务器解析执行，体现在点击页面中的按钮没有任何的响应。解决方案： 在项目的maven中clear清理项目-install重新部署 在项目的file选项下-cash清理缓存 重新构建项目：build-rebuild 重启idea 重启电脑 用户登录当用户输入用户名和密码将数据提交给后台数据库进行查询，如果存在对应的用户名和密码，则登陆成功，登录成功后跳转index.html，跳转在前端 持久层 规划需要执行的sql语句 依据用户提交的用户名和密码做select查询，密码的比较在业务层执行 1select * from t_user where username=? 说明：如果在分析过程中发现某个功能模块已经被开发完成，就可以省略当前的开打步骤，但分析过程不能省略 接口设计和抽象方法 不用重复开发，单元测试无需单独执行 业务层 规划异常 用户名对应的密码错误，密码匹配失败的异常：PasswordNotMatchException异常，属于 运行时异常，业务异常 用户名未找到，UsernameNotFoundException，运行时异常，业务异常 异常编写： 业务层异常需要继承ServiceException异常类 在具体的异常类中定义构造方法（可以使用快捷键来生成，有5个构造方法） 设计业务层接口和抽象方法 直接在IUserService接口中编写抽象方法，login(String username, String password)。将当前登录成功的用户数据以当前用户对象的形式进行返回。状态管理：可以将数据保存在cookie或session中，可以避免重复度很高的数据多次频繁操作数据进行获取（用户名、用户ID等存在session中，用户头像存在cookie中） 在这里写了之后回到UserserviceImpl出现了波浪号，按波浪号导入方法即可 抽象方法实现 需要在实现类中实现父接口中抽象方法 检测用户是否存在 检测用户密码是否匹配 先获取盐值 将用户密码按相同的md5算法规则进行加密 将密码进行比较 判断用户是不是已经注销过了 在测试类中测试业务层登录的方法是否可以执行通过。 如果一个类没有手动创建就直接将这个类复制到项目，idea找不到这个类，之前缓存导致补能够正常找到这个类的符号，就重新构建项目 build-rebuild 1java: 找不到符号 控制层 处理异常 关注业务层抛出的异常，需要在统一异常处理类中进行统一的捕获和处理，如果抛出的异常类型已经在统一异常处理类中处理过，则不需要重复复添加 1234567else if(e instanceof UsernameNotFoundException) &#123; result.setState(5001); result.setMessage(&quot;用户数据不存在的异常&quot;); &#125; else if(e instanceof PasswordNotMatchException) &#123; result.setState(5002); result.setMessage(&quot;用户名密码错误的异常&quot;); &#125; 设计请求 1234请求路径：/user/login请求方式：POST请求数据：String username,String password请求结果：JSONResult&lt;User&gt; 处理请求 在UserController类中变系处理请求的方法 前端 优化 存储登陆的数据 用户会话session 存在服务器端，用于保存服务器的临时数据对象 seesion.getAttrbute(&quot;key&quot;)可以将获取seesion中的数据这种行为进行封装，因为都要经过Base层，所以封装在baseController层 封装seesion对象中数据的获取（封装父类中）、数据的设置（当用户登录成功够进行数据的设置，设置到全局的session对象） 在父类中封装两个数据：获取uid和username对应的两个方法。用户头像暂时不考虑，将来封装到cookie中 在登录的方法中将数据封装在session对象中。子类登录方法那里。服务器本身自动创建有session对象，已经是一个全局的session对象。SpringBoot可以直接使用session对象，直接将HttpSession类型的对象作为请求处理方法的参数，会自动将全局的Session对象注入到请求处理方法的session形参上。 发现之前设计的请求不再满足要求了 1234请求路径：/user/login请求方式：POST请求数据：String username,String password，HttpSession session请求结果：JSONResult&lt;User&gt; 如果服务器有session，那session会随同客户端发送给服务器，客户端的存在cookie中，每一次发送请求时，cookie又将里面的所有信息重新提交给客户端；只要服务端每次相应一个id，那客户端就会提交一次id 拦截器 统一将所有请求拦截到拦截器中，可以在拦截器中定义过滤的规则，若不满足系统设置的过滤规则，统一的处理是冲洗去打开login.html页面（重定向和转发），推荐使用重定向 有时候可能是把一个模块的分支代码部署到另一个服务器上，所以如果转发就可能出现不在一台服务器上没法转发。 SpringBoot本质是依靠springMVC来完成的。SprngMVC提供了一个HandlerInterceptor接口，用于表示定义一个拦截器。受限于自定义类，在这个类中实现这个接口。 定义一个LoginInterceptor类继承接口HandlerInterceptor 分析源码： 123456789101112//在调用所有处理请求的方法之前被自动调用执行的方法default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return true; &#125;// （jsp/login响应完之后调）在ModelAndView对象返回之后调 default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123; &#125;// 在整个请求所关联的资源被执行完毕最后所执行的方法// 一般用于资源回收// 一般最后两个都用不到 default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123; &#125; 因为下图，所以要在前端控制器之前进行拦截 注册过滤器：添加白名单（哪些资源可以在不登陆的情况下访问）、黑名单 注册过滤器的技术：借助WebMvcConfigure接口，可以将用户定义的拦截器进行注册，才可以保证拦截器能够生效和使用。定义一个类，然后让这个类实现WebMvcConfigure接口。配置信息建议存放在项目的config包结构下。 LoginInterceptorConfigurer.java 继承WebMvcConfigurer类 addInterceptors将自定义拦截器进行注册，也实现了一个接口 不要一直回车测试，浏览器机制，会提醒重定向次数过多，login.html页面无法打开，白名单黑名单都不见了 cookie清除，浏览器设为初始设置 修改密码 需要用户提交原始密码和新密码，再根据给当前登录的用户进行信息的修改操作 持久层 规划sql语句 根据uid修改用户password的值 12update t_user set password=?,modified_user=?,modified_time=? where uid=?跟踪用户的修改 根据uid查询用户数据，确保用户存在，是否被标记为已删除，输入的原始密码是否正确 1select * from t_user where uid=? 设计接口、抽象方法 UserMapper接口，将以上的两个方法的抽象定义出来，将来映射到sql语句上 sql的映射 配置到映射文件userMapper.xml中 1234567891011&lt;update id=&quot;updatePasswordByUid&quot;&gt; UPDATE t_user SET password=#&#123;password&#125;, modified_user=#&#123;modified_user&#125;, modified_time=#&#123;modified_time&#125; where uid=#&#123;uid&#125; &lt;/update&gt; &lt;select id=&quot;findByUid&quot; resultMap=&quot;UserEnityMap&quot;&gt; SELECT * FROM t_user WHERE uid=#&#123;uid&#125; &lt;/select&gt; 单元测试 业务层 规划异常 原密码错误，is_delete&#x3D;&#x3D;1、uid找不到，在用户没有发现的异常UsernotFounfException(之前有) update更新时产生的未知异常UpdateException 设计接口和抽象方法 执行用户修改密码的核心方法 之前的findByUid要放在UpdatePasswordByUid中进行辅助 在实现类中实现当前的抽象方法UserServiceImpl -changePassword 单元测试 UserServiceTests 控制层 处理异常 业务层有没有抛出异常，有就写，没有就过 新增的UpdatePasswordByUid需要配置再统一的异常处理方法中 BaseController 设计请求 /users/change_password post String oldPassword, String newPassword,HttpSession session //需要和表单中的name属性值保持一致 JsonResult&lt;void&gt; 123456789101112131415161718192021222324252627- 处理请求 - 到控制类UserController中声明出来 - 登录之后才能进行测试 ![image-20231227214643944](D:\\Typeeasy\\image-20231227214643944.png)##### 前端![image-20231227214950117](D:\\Typeeasy\\image-20231227214950117.png)#### 资料修改先分析，用户名已经放在session当中了第二部分类似密码修改![image-20231227215326182](D:\\Typeeasy\\image-20231227215326182.png)##### 持久层- 规划sql语句 ```sql update t_user set phone=?, email=?, gender=?,modified_user=?, modified_time=? where uid=? 1select * from t_user where uid=? https://www.bilibili.com/video/BV1bf4y1V7Bx?t=499.0&amp;p=12 业务层控制层前端瑞吉外卖https://www.bilibili.com/video/BV13a411q753/?p=2&amp;vd_source=32c7f6ec6ba676c7527b509106db968a 前后端分离项目1 前端技术 说明 vue vuex 全局状态管理框架 elementui axios vue-element-admin 项目脚手架（开源） 后端技术 说明 springboot 容器+mvc框架 mybatis orm框架 mybatis-plus（使用） mybatis增强工具 redis 非关系型数据库 数据库xdb用户表 1234567891011create table x_user &#123;\tid int(11) not null auto_increment,\tusername varchar(50) not null,\tpassword varchar(100) default null,\temail varchar(50) default null,\tphone varchar(20) default null,\tstatus int(1) default null,\tavatar varcahr(200) default null,\tdeleted int(1) default 0,\tprimary key(id)&#125; engine=innodb auto_increment=3 default charset=utf8 角色表 菜单表 用户角色映射表 角色菜单映射表 环境 node 稍低-v16.12.0 vue-admin-template https://panjiachen.gitee.io/vue-element-admin-site/zh/guide/ D:\\pdf\\vue-admin-template-4.4.0\\vue-admin-template-4.4.0 index.html是单页面应用（？） request.js里就有对axios的拦截配置，往里面写东西、返回相应的请求时判断成不成功 安装依赖可以设置淘宝镜像 npm config set registry http://registry.npm.taobao.org/ npm i 运行npm run dev 配置修改 关闭lint校验 后端https://start.spring.io/ https://start.aliyun.com/"},{"title":"最短路（路径规划）","path":"/undefined/road/","content":"找到实习了，想起面试的时候问了一嘴会不会路径规划和DP，这两天复习一下。打个标记，这公司还要前端还要3D oi-wiki定义 做的题在 知乎-如何加快城市路网中最短路径查询效率？ 快速总结 Floyd任意两点最短路，时间O(n3), 空间O(n2) Bellman–Ford最短路，可判负环，时间O(nm),空间O(m) SPFA卡常，但是最坏时间是O(nm),开发中稀疏图应该能用（存疑） Dijkstra非负最短路，开发用这个才最合适吧 Johnson任意两点最短路,类似Floyd，时间O(NMlogM) 其它：A*（a到b所有路径中第k短）等 Dij拓展基本都用的优先队列，没深挖，在当时已经够用了 n为边，m为顶点 暴力：时间复杂度O(n2) 二叉堆：插入修改时间复杂度O(logn),总时间复杂度O(mlogn) 优先队列：时间复杂度O(mlogm) Fibonacci 堆：插入O(1),时间复杂度O(nlogn+m)，时间复杂度最优 参考1 参考2 相对于优先队列，只是改变了抽最小节点出来的方式 …这代码也太长了 1之后再补充 线段树：类似二叉堆原理，时间复杂度O(mlogn) Johnson补充 虚拟节点0向其它所有点边权为0，bf找出0到其他店的最短路（hi） 重设边的边权w+hu-hv 跑dij A*k短路-A* 最坏O(nklogn) f(x) &#x3D; g(x) + h(x) a-&gt;b的第k小 g(x)为初始点a到当前的x点的距离；h(x)为x点到b点的最小距离， 先将其余点到a的最小值求出来（优先队列&#x2F;operator&lt;） 同时取出优先队列最小的状态，枚举点的出边，对应的子状态计入优先队列 重复操作,相当于dij 再次当访问b点达到了k次，完成"},{"title":"面试准备","path":"/undefined/faceReady/","content":"第一次面试，应该不太可能找到工作。先准备好，看看有哪些欠缺吧。 记得录音，好复盘自我介绍，语速放慢点 &lt;&#x3D;2min 先破冰：你好，请问怎么称呼您呢？ x老师非常高兴你今天来面试我 （不用破冰也行，） 再进行自我介绍，拆段说项目、生活 与这个岗位适配理由，例如专业能力（毕竟面试官也需要向上汇报） 你好，很高兴今天你来面试我。我叫xx，是明年毕业计科专业，我想应聘公司的xxxx，一直对这个专业很感兴趣，我相信前端在未来几年内还是不可替代的。在校期间成绩还不错，同时参加了一些相关竞赛，做了一些项目。获得并学习到了xx。我也是一个很喜欢进行探索学习，喜欢新事物的人，希望可以在这方面进行发展，有机会进入贵公司工作。 我做的项目巴拉巴拉巴拉，怎么做的，有什么难点，才好提问 其它问题： 为什么选择我们公司首先是我个人的职业发展规划，我觉得自己认真的性格加上专业，很适合这个岗位，也希望能在xx岗位长期发展。我举得贵公司可以让我发挥自己的优势，得到成长。 职业发展规划：分阶段，快速熟悉，接触核心业务，独立带项目 你认为你最大的优点是什么？执行能力强，学习探索能力较强，不懂的问题能主动通过自己的方式解决，解决问题念能力强。比如竞赛经历使我对调bug很擅长 缺点在有人解决问题时看见错误会怀疑自己有问题，不敢提。-会委婉说有没有可能&#x2F; 公开演讲能力欠缺。 作为应届生，在工具使用趋势方面缺乏经验，关注一些博主，保持信息获取 加班作为新人刚进新岗位加班很正常，为跟上工作节奏，我也会在初期投入时间学习，尽快熟悉业务。其此，随着工作的熟练，我会替身自己的工作效率，减少无效加班，请问公司的加班情况什么样？ 期望薪资4500 有什么问的工作内容，转正， 第一次面试还挺紧张，谢谢你的时间，我们聊完之后，1-10分对我感兴趣的程度是几分，为什么是这个分数呢能告诉我吗"},{"title":"vue3后台管理系统","path":"/undefined/vue3.2后台管理心得/","content":"思维导图说不清楚的放在这里 vue-cli: 基于插件的架构，所以依赖名：@vue/cli-plugin- 开头 插件可以修改 webpack 的内部配置，也可以向 vue-cli-service 注入命令 以vue-cli-service访问 不是每个应用都需要是一个单页应用。Vue CLI 支持使用 vue.config.js 中的 pages 选项构建一个多页面的应用。构建好的应用将会在不同的入口之间高效共享通用的 chunk 以获得最佳的加载性能。 静态资源可以通过两种方式进行处理： 在 JavaScript 被导入或在 template&#x2F;CSS 中通过相对路径被引用。这类引用会被 webpack 处理。 放置在 public 目录下或通过绝对路径被引用。这类资源将会直接被拷贝，而不会经过 webpack 的处理。 当你在 JavaScript、CSS 或 *.vue 文件中使用相对路径 (必须以 . 开头) 引用一个静态资源时，该资源将会被包含进入 webpack 的依赖图中。在其编译过程中，所有诸如 &lt;img src=&quot;...&quot;&gt;、background: url(...) 和 CSS @import 的资源 URL 都会被解析为一个模块依赖。 例如，url(./image.png) 会被翻译为 require(&#39;./image.png&#39;)，而： 1&lt;img src=&quot;./image.png&quot;&gt; 将会被编译到： 1h(&#x27;img&#x27;, &#123; attrs: &#123; src: require(&#x27;./image.png&#x27;) &#125;&#125;) 在其内部，我们通过 webpack 的 Assets Modules 配置，用版本哈希值和正确的公共基础路径来决定最终的文件路径，并将小于 8KiB 的资源内联，以减少 HTTP 请求的数量。 你可以通过 chainWebpack 调整内联文件的大小限制。例如，下列代码会将内联图片资源限制设置为 4KiB： 123456789101112// vue.config.jsmodule.exports = &#123; chainWebpack: config =&gt; &#123; config.module .rule(&#x27;images&#x27;) .set(&#x27;parser&#x27;, &#123; dataUrlCondition: &#123; maxSize: 4 * 1024 // 4KiB &#125; &#125;) &#125;&#125; URL 转换规则 # 如果 URL 是一个绝对路径 (例如 /images/foo.png)，它将会被保留不变。 如果 URL 以 . 开头，它会作为一个相对模块请求被解释且基于你的文件系统中的目录结构进行解析。 如果 URL 以 ~ 开头，其后的任何内容都会作为一个模块请求被解析。这意味着你甚至可以引用 Node 模块中的资源： 1&lt;img src=&quot;~some-npm-package/foo.png&quot;&gt; 如果 URL 以 @ 开头，它也会作为一个模块请求被解析。它的用处在于 Vue CLI 默认会设置一个指向 &lt;projectRoot&gt;/src 的别名 @。**(仅作用于模版中)** 任何放置在 public 文件夹的静态资源都会被简单的复制，而不经过 webpack。你需要通过绝对路径来引用它们。 注意我们推荐将资源作为你的模块依赖图的一部分导入，这样它们会通过 webpack 的处理并获得如下好处： 脚本和样式表会被压缩且打包在一起，从而避免额外的网络请求。 文件丢失会直接在编译时报错，而不是到了用户端才产生 404 错误。 最终生成的文件名包含了内容哈希，因此你不必担心浏览器会缓存它们的老版本。 public 目录提供的是一个应急手段，当你通过绝对路径引用它时，留意应用将会部署到哪里。如果你的应用没有部署在域名的根部，那么你需要为你的 URL 配置 publicPath 在模板中，你首先需要向你的组件传入基础 URL： 12345data () &#123; return &#123; publicPath: process.env.BASE_URL &#125;&#125; 然后： 1&lt;img :src=&quot;`$&#123;publicPath&#125;my-image.png`&quot;&gt; 何时使用 public 文件夹 # 你需要在构建输出中指定一个文件的名字。 你有上千个图片，需要动态引用它们的路径。 有些库可能和 webpack 不兼容，这时你除了将其用一个独立的 &lt;script&gt; 标签引入没有别的选择。 非必要不用public文件夹 调整 webpack 配置最简单的方式就是在 vue.config.js 中的 configureWebpack 选项提供一个对象： 12345678// vue.config.jsmodule.exports = &#123; configureWebpack: &#123; plugins: [ new MyAwesomeWebpackPlugin() ] &#125;&#125; 该对象将会被 webpack-merge 合并入最终的 webpack 配置。 警告 有些 webpack 选项是基于 vue.config.js 中的值设置的，所以不能直接修改。例如你应该修改 vue.config.js 中的 outputDir 选项而不是修改 output.path；你应该修改 vue.config.js 中的 publicPath 选项而不是修改 output.publicPath。这样做是因为 vue.config.js 中的值会被用在配置里的多个地方，以确保所有的部分都能正常工作在一起。 如果你需要基于环境有条件地配置行为，或者想要直接修改配置，那就换成一个函数 (该函数会在环境变量被设置之后懒执行)。该方法的第一个参数会收到已经解析好的配置。在函数内，你可以直接修改配置，或者返回一个将会被合并的对象： 12345678910// vue.config.jsmodule.exports = &#123; configureWebpack: config =&gt; &#123; if (process.env.NODE_ENV === &#x27;production&#x27;) &#123; // 为生产环境修改配置... &#125; else &#123; // 为开发环境修改配置... &#125; &#125;&#125; Vue CLI 内部的 webpack 配置是通过 webpack-chain 维护的。这个库提供了一个 webpack 原始配置的上层抽象，使其可以定义具名的 loader 规则和具名插件，并有机会在后期进入这些规则并对它们的选项进行修改。 你可以通过传递 --mode 选项参数为命令行覆写默认的模式。例如，如果你想要在构建命令中使用开发环境变量： 1vue-cli-service build --mode development —官方文档 package.json 文件里的 browserslist 字段 (或一个单独的 .browserslistrc 文件)，指定了项目的目标浏览器的范围。这个值会被 @babel&#x2F;preset-env 和 Autoprefixer 用来确定需要转译的 JavaScript 特性和需要添加的 CSS 浏览器前缀。 12345&quot;config&quot;: &#123; &quot;commitizen&quot;: &#123; &quot;path&quot;: &quot;node_modules/cz-customizable&quot; &#125; &#125; commitizen” 配置项用于指定使用的 Commitizen 工具的路径。Commitizen 是一个用于规范化提交信息的工具，它有助于生成符合规范的 Git 提交消息，使项目的提交历史更加清晰和易于理解。具体来说： &#x2F;&#x2F; “path” 指定了 Commitizen 工具的路径，这里指定为 “node_modules&#x2F;cz-customizable”。这表示项目将使用 cz-customizable 包中的 Commitizen 工具。 可以使用 git cz 命令来生成规范化的提交消息，然后按照提示填写相应的信息。 service.interceptors.response.use 是 Axios 中的一个拦截器（interceptor）用于在发送网络请求后，在接收响应之前对响应数据进行处理。这是一个非常有用的功能，可用于全局或局部地处理响应数据，例如处理错误、添加通用的处理逻辑等。 具体来说，service.interceptors.response.use 通常用于以下目的： 处理成功的响应数据：您可以在这个拦截器中处理成功的响应数据，例如提取有用的数据或进行某些后续操作。如果您的网络请求成功，那么这个拦截器将接收到服务器返回的响应数据。 处理错误响应：您可以在这个拦截器中处理请求失败或服务器返回的错误。这包括处理 HTTP 错误状态码（如 404、500 等）或应用程序定义的错误（例如，如果服务器返回一个错误的 JSON 格式或特定错误消息）。 对响应进行通用处理：您可以在这里执行一些通用的处理，例如显示通知、记录请求和响应等。这可以用于全局错误处理或应用程序级别的通用逻辑。 123456789101112service.interceptors.response.use( // 第一个参数处理成功响应 function (response) &#123; // 处理成功的响应逻辑 return response; &#125;, // 第二个参数处理错误响应 function (error) &#123; // 处理错误响应逻辑 return Promise.reject(error); &#125;); service.interceptors.request.use 是 Axios 中用于添加请求拦截器的方法，它允许您在发送请求之前对请求进行修改或添加自定义逻辑。让我详细解释它的意义： service: 这是一个之前通过 axios.create(&#123;&#125;) 创建的 Axios 实例，它代表了一个可以用于发起网络请求的对象。 interceptors: Axios 拥有请求拦截器和响应拦截器，这里使用的是请求拦截器。拦截器允许您在请求发送或响应返回时执行一些操作。 request.use(callback, errorCallback): 这个方法用于添加一个请求拦截器，其中 callback 是一个函数，它会在发送请求之前执行。errorCallback 是一个可选的函数，它会在请求拦截器发生错误时执行。 在具体的代码中，您可以看到以下操作： 如果本地存储中存在一个名为 ‘token’ 的数据，就会执行请求拦截器的 config 回调函数，该函数用于修改请求的配置对象 config。 在这个回调函数中，首先检查了一个名为 ‘token’ 的数据，如果存在并且满足 diffTokenTime() 的条件，将执行以下操作： 调用 this.$store.dispatch(&#39;app/logout&#39;) 以触发 Vuex 中的 app/logout 动作（通常用于用户退出登录的操作）。 返回一个 Promise，拒绝它并抛出一个 ‘token 失效’ 的错误。 如果没有满足条件，将在请求的 config 对象中设置 Authorization 头部，以包含存储在本地的 ‘token’ 数据。 这种方式允许您在每个请求发起之前对请求进行检查和修改。通常，它用于添加身份验证信息、设置请求头、记录请求日志等操作。 utils 文件夹通常用于存放各种实用工具函数、帮助函数以及通用工具类。这些工具函数和类可以在整个项目中共享和重复使用，以提高代码的可维护性和可重用性。 以下是一些常见的用途，通常会在 utils 文件夹中放置的内容： 工具函数：包括各种通用的 JavaScript 函数，例如日期处理、字符串操作、数组操作、数学计算等。这些函数可以帮助简化代码，减少重复劳动。 HTTP 请求处理：如果您的应用程序需要与后端进行 HTTP 请求，您可以将处理请求和响应的功能封装到一个或多个文件中，以便在整个应用程序中重用。 验证函数：如果您需要对用户输入的数据进行验证，可以创建一些验证函数，以确保数据的完整性和合法性。 配置文件：存放一些应用程序的配置信息，例如 API 地址、密钥、常量等。这些配置信息可以集中管理，方便在应用程序中引用。 日志记录器：如果您需要记录应用程序的日志，可以创建一个日志记录器工具，用于记录和管理日志消息。 路由帮助函数：在使用路由库（如 Vue Router 或 React Router）时，可以创建一些帮助函数来处理路由导航、权限控制等。 格式化函数：用于格式化数据的函数，例如货币格式、日期时间格式、数字格式等。 通用组件：如果您的应用程序包含可在多个页面或组件中重复使用的通用组件，可以将这些组件放在 utils 文件夹中。 测试工具：用于单元测试或集成测试的工具函数和测试辅助函数。 总之，utils 文件夹通常包含与项目相关的各种通用工具，这些工具可以帮助简化代码、提高开发效率并提供更好的代码组织和维护。但请确保按照项目的需求和规范来组织和命名这些工具函数和类。 api 文件夹通常用于存放与后端 API 通信相关的代码。这包括定义和管理 API 请求、处理响应以及与后端服务进行数据交互的功能 &lt;router-view /&gt; 是 Vue Router 的核心概念之一，它用于渲染匹配当前路由的组件内容。具体来说： 当你的应用程序导航到不同的路由时，Vue Router 会根据路由规则确定要显示哪个组件。 &lt;router-view /&gt; 元素充当容器，用于呈现这些匹配的组件。 你可以将 &lt;router-view /&gt; 放在你的应用程序布局中的任何地方，以确保匹配的组件被正确渲染。 所以，这个代码片段表示你的组件模板中唯一的内容是一个用于呈现路由组件的 &lt;router-view /&gt; 元素。这是构建具有多个视图和页面的单页应用程序时常见的方式。 URL 中的哈希值（hash）和传统的浏览器历史记录中的路径在使用方式和行为上有一些区别： 哈希值路径（例如 #/home）： 这种方式使用 URL 中的哈希部分（通常是 # 后面的内容）来表示路由路径。 哈希路径的变化不会触发浏览器向服务器发送请求。这意味着，对于前端路由，页面的切换是在客户端完成的，不会导致页面的完全重新加载。 哈希路径在单页应用程序（SPA）中常用，因为它不需要服务器端配置，且可以在前端路由中进行导航。 传统路径（例如 /home）： 这种方式使用 URL 中的标准路径来表示路由路径，不涉及哈希部分。 传统路径的变化通常会导致浏览器向服务器发送请求，服务器需要响应并提供相应的页面。这会导致页面完全重新加载。 传统路径通常用于传统的多页应用程序，其中每个不同的路径对应于服务器上的不同页面。 在前端开发中，哈希路径通常更适用于单页应用程序（SPA），因为它们可以在不刷新整个页面的情况下进行页面切换，提供更好的用户体验。传统路径通常用于传统的多页应用程序或需要与服务器进行交互的情况。不过，也可以使用前端路由库（如 Vue Router）来实现传统路径的前端导航，而不需要完全重新加载页面。 表单验证通常是通过 Vue 的 v-model 指令和 ref 来处理的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;form ref=&quot;myForm&quot; @submit.prevent=&quot;submitForm&quot;&gt; &lt;input v-model=&quot;formData.username&quot; placeholder=&quot;Username&quot; /&gt; &lt;input v-model=&quot;formData.password&quot; type=&quot;password&quot; placeholder=&quot;Password&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref &#125; from &#x27;vue&#x27;;export default &#123; setup() &#123; // 创建表单引用 const formRef = ref(null); // 表单数据 const formData = &#123; username: &#x27;&#x27;, password: &#x27;&#x27;, &#125;; // 提交表单时的处理函数 const submitForm = () =&gt; &#123; // 使用 formRef.value.validate 来触发表单验证 formRef.value.validate((valid) =&gt; &#123; if (valid) &#123; // 表单验证通过，可以执行提交操作 console.log(&#x27;Form is valid&#x27;); // 这里可以执行提交表单的逻辑 &#125; else &#123; // 表单验证失败 console.log(&#x27;Form is invalid&#x27;); &#125; &#125;); &#125;; return &#123; formRef, formData, submitForm, &#125;; &#125;,&#125;;&lt;/script&gt; 1234567891011在 &lt;el-form-item&gt; 元素中配置 prop 属性的作用是将该表单项与表单数据对象中的字段关联起来，从而使表单项的值能够正确地绑定到数据对象的对应字段。具体来说，prop 属性的值应该与表单数据对象中的字段名一致，例如 prop=&quot;username&quot; 表示该表单项与表单数据对象中的 username 字段相关联。这样，当用户在表单项中输入数据时，Vue.js 就会自动将这些数据更新到 form.username 这个字段中。配置 prop 属性的好处包括： 数据绑定：可以确保表单项的值与数据对象中的字段保持同步，无需手动处理数据的收集和更新。 表单验证：如果使用了 Element UI 的表单验证功能，配置了 prop 属性后，会自动应用表单验证规则到关联的字段上，从而方便地进行表单验证。 表单提交：在提交表单时，可以直接使用数据对象，而不需要单独获取每个表单项的值。 v-slot 是 Vue 3 中的新语法，用于定义具名插槽。 #default 是 Vue 2 中的语法，用于定义匿名插槽。 在 Vue 2 中，你可以使用 v-slot 来定义具名插槽，但一般情况下，#default 用于匿名插槽，而具名插槽则使用 v-slot:name Vue Router 是 Vue.js 官方的路由管理器 带name “没有硬编码的 URL” 意味着你不需要在应用程序的各个地方手动编写 URL。而是使用路由的名称（name）来引用路由，使得在整个应用程序中，路由的 URL 都是自动生成和管理的。 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 全局单例模式管理： 这是一种设计模式，通常用于在应用程序中维护全局状态。在 Vue.js 中，这可以通过 Vuex 来实现，它是一个专门用于状态管理的库。使用 Vuex，你可以将应用程序的共享状态抽取出来，以一个全局单例（单一的数据存储）的方式管理。这意味着无论在你的应用程序中的哪个组件，都可以访问和修改相同的状态，而不需要手动传递数据或处理事件。 Vue.js 的默认组件通信方式（父组件传递给子组件或通过事件传递）变得不太适用，因为兄弟组件之间没有直接的父子关系。(vuex-store) 每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的**状态 (state)**。Vuex 和单纯的全局对象有以下两点不同： Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 https://vuex.vuejs.org/zh/guide/#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84-store 在 Vuex 中，所有的应用程序状态都存储在一个单一的 JavaScript 对象中，这个对象被称为“状态树”或“存储”（store）。这个状态树包含了整个应用程序的状态，无论应用中有多少组件或模块，它们都共享这个状态树。 关键点如下： 单一数据源 (SSOT)： Vuex 鼓励将应用程序的所有状态集中管理，这意味着你不需要在不同的组件之间传递状态或维护多个分散的状态副本。这种集中式管理使得状态更加可维护和可预测。 一个 store 实例： 在一个 Vue.js 应用中，通常只会创建一个 Vuex store 实例。这个实例在整个应用中起到全局状态管理的作用。无论你在哪个组件中需要访问状态，都可以通过这个 store 实例来获取或修改状态。 模块化： 虽然整个应用共享一个状态树，但你可以使用 Vuex 的模块化系统来将状态树拆分为多个模块。这可以帮助你在大型应用中更好地组织状态，每个模块都有自己的状态、mutations、actions 等。 数据响应式系统： Vue 使用响应式系统来追踪数据的变化。当数据发生变化时，Vue 会自动更新视图以反映这些变化。这个系统依赖于 JavaScript 的事件循环（Event Loop）机制。如果 mutation 是异步的，那么它可能无法在数据变化之前同步提交变化，从而导致视图和状态不一致。 开发者工具： Vuex 提供了强大的开发者工具，可以追踪和调试状态的变化。如果 mutation 是异步的，这些工具将变得不可靠，因为它们无法准确地追踪异步操作的状态变化。 同步函数是一种在执行过程中不会阻塞或暂停程序执行的函数。当调用一个同步函数时，它会立即执行其中的代码，并在执行完毕后返回结果。同步函数通常用于处理那些不涉及异步操作（如网络请求、文件读写等）的任务。 异步函数是一种可能会在执行过程中暂停程序，等待某些操作完成后再继续执行的函数 timer &amp;&amp; clearTimeout(timer);：这一行是在每次滚动事件触发时，首先清除之前设置的定时器，以确保在下一次滚动事件之前不会执行函数。"},{"title":"vue项目的创建过程","path":"/undefined/vue项目创建过程/","content":"首先打开cmd，键入vue ui打开vue图形界面 将建好的空白文件夹路径粘贴到更多-管理-创建 手动配置，不保存预设 涉及到sass&#x2F;css&#x2F;eslink、linter&#x2F;vuex&#x2F;router、axios、husky、vue-vli app.vue好像是整体都有的 “app.vue是vue页面资源的首加载项，是主组件，页面入口文件，所有页面都是在App.vue下进行切换的；也是整个项目的关键，app.vue负责构建定义及页面组件归集。 app.vue中不但可以当做是网站首页,也可以写所有页面中公共需要的动画或者样式， 所有的页面都是在app.vue中进行切换的 ref 属性 ref 属性被用来给元素或子组件注册引用信息(id的替代者),相当于对页面元素或子组件标识 import { Edit } from ‘@element-plus&#x2F;icons-vue’ 直接引用，组件首字母大小 aria-hiddenhttps://blog.csdn.net/qq_54334713/article/details/127344641 1--legacy-peer-deps npm run serve 拖入prettierrc的配置文件 在配置下.eslintrc.js里的rules 新增 为了解决eslint与prettier冲突indent: 0,‘space-before-function-paren’: 0 git commit代码提交规范 npm install -g &#99;&#111;&#x6d;&#x6d;&#x69;&#116;&#105;&#x7a;&#x65;&#110;&#64;&#52;&#46;&#x32;&#x2e;&#x34;npm i &#99;&#x7a;&#x2d;&#x63;&#x75;&#x73;&#116;&#x6f;&#109;&#x69;&#122;&#x61;&#98;&#x6c;&#x65;&#64;&#54;&#x2e;&#x33;&#x2e;&#48; –save-dev 123456789101112131415&lt;template&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;router-view /&gt;&lt;/template&gt;&lt;script setup&gt;const boxWidth = &#x27;100px&#x27;&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt;.box &#123;width: v-bind(boxWidth);height: 100px;background-color: red;&#125;&lt;/style&gt;vue3.0 css绑定js"},{"title":"linee","path":"/undefined/linee/","content":"线段是否相交123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;template&lt;class T&gt; bool judge2(T a, T b, T c, T d)&#123; if(max(a.first , b.first) &gt;= min(c.first, d.first) &amp;&amp; max(c.first, d.first) &gt;= min(a.first, b.first) &amp;&amp; max(a.second, b.second) &gt;= min(c.second, d.second) &amp;&amp; max(c.second, d.second) &gt;= min(a.second, b.second)) return true; return false; &#125;template&lt;class T&gt; bool judge1(T a, T b, T c, T d)&#123;//跨立实验 if(!judge2(a, b, c, d)) return false; double d1 = (a.first - c.first) * (d.second - c.second) - (d.first - c.first) * (a.second - c.second); double d2 = (d.first - c.first) * (b.second - c.second) - (b.first - c.first) * (d.second - c.second); double d3 = (c.first - a.first) * (b.second - a.second) - (b.first - a.first) * (c.second - a.second); double d4 = (b.first - a.first) * (d.second - a.second) - (d.first - a.first) * (b.second - a.second); if(d3 * d4 &gt;= 0 &amp;&amp; d1 * d2 &gt;= 0) return true; else return false;&#125;//一般做题是先快速排斥， 后跨立int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; pair&lt;double, double&gt; p[4]; cin &gt;&gt; p[0].first &gt;&gt; p[0].second &gt;&gt; p[1].first &gt;&gt; p[1].second &gt;&gt; p[2].first &gt;&gt; p[2].second &gt;&gt; p[3].first &gt;&gt; p[3].second; if (judge1(p[0], p[1], p[2], p[3])) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; return 0;&#125; 线段相交是否规范（只能过90%数据，先占个位） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//#include&lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;vector&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;climits&gt;#define IOS ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL);using namespace std;const int maxx = 1e4 + 5;const int maxn = 1e6 + 5;#define N 10000100#define ll long long#define endl &#x27; &#x27;const ll mod = 998244353;#define test printf(&quot;-------------------------- &quot;);#define re(a) memset((a), 0, sizeof((a)))#define remax(a) memset((a), 0x3f3f3f3f, sizeof((a)))#define PII pair&lt;int, int&gt;const double pi=acos(-1.0);inline int llog(int n)&#123; return 31 - __builtin_clz(n);&#125; //取对数// struct cmp&#123;// friend bool operator &gt; (const struct scoree &amp;a, const struct scoree &amp;b)&#123;// return a.score &gt; b.score;// &#125;// &#125;;template&lt;class T&gt; bool judge2(T a, T b, T c, T d)&#123; if(max(a.first , b.first) &gt;= min(c.first, d.first) &amp;&amp; max(c.first, d.first) &gt;= min(a.first, b.first) &amp;&amp; max(a.second, b.second) &gt;= min(c.second, d.second) &amp;&amp; max(c.second, d.second) &gt;= min(a.second, b.second)) return true; return false;&#125;template&lt;class T&gt; bool judge1(T a, T b, T c, T d)&#123; if(!judge2(a, b, c, d))&#123; return 0; &#125; double d1 = (a.first - c.first) * (d.second - c.second) - (d.first - c.first) * (a.second - c.second); double d2 = (d.first - c.first) * (b.second - c.second) - (b.first - c.first) * (d.second - c.second); double d3 = (c.first - a.first) * (b.second - a.second) - (b.first - a.first) * (c.second - a.second); double d4 = (b.first - a.first) * (d.second - a.second) - (d.first - a.first) * (b.second - a.second); if(d3 * d4 &gt;= 0 &amp;&amp; d1 * d2 &gt;= 0)&#123; return true; &#125; else return false;&#125;bool judge3(PII a, PII b, PII c, PII d) &#123; if((b.first - a.first) * (c.first - d.first) + (b.second - a.second) * (d.second - c.second) == 0) &#123; return true; &#125; return false;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; pair&lt;double, double&gt; p[4]; cin &gt;&gt; p[0].first &gt;&gt; p[0].second &gt;&gt; p[1].first &gt;&gt; p[1].second &gt;&gt; p[2].first &gt;&gt; p[2].second &gt;&gt; p[3].first &gt;&gt; p[3].second; if(judge1(p[0], p[1], p[2], p[3]))&#123; if(judge3(p[0], p[1], p[2], p[3])) cout &lt;&lt; 1 &lt;&lt; endl; else cout &lt;&lt; 2 &lt;&lt; endl; &#125; else cout &lt;&lt; 0 &lt;&lt; endl; &#125; return 0;&#125;"},{"title":"lca(最近公共祖先)","path":"/undefined/lca/","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 5e5 + 5;const int DEG = 30;#define re(a) memset(a, -1, sizeof(a))struct Edge&#123; int to, next;&#125;edge[maxn * 2];int head[maxn], tot;void addedge(int u, int v)&#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;void init()&#123; tot = 0; re(head);&#125;int fa[maxn][DEG], deg[maxn];void bfs(int root)&#123; queue&lt;int&gt; que; deg[root] = 0; fa[root][0] = root; que.push(root); while(!que.empty())&#123; int tmp = que.front(); que.pop(); for(int i = 1; i &lt; DEG; ++i)&#123; fa[tmp][i] = fa[fa[tmp][i - 1]][i - 1]; &#125; for (int i = head[tmp]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(v == fa[tmp][0]) continue; deg[v] = deg[tmp] + 1; fa[v][0] = tmp; que.push(v); &#125; &#125;&#125;int lca(int u, int v)&#123; if(deg[u] &gt; deg[v])&#123; swap(u, v); &#125; int hu = deg[u], hv = deg[v]; int tu = u, tv = v; for (int det = hv - hu, i = 0; det; det &gt;&gt;= 1, ++i)&#123; if(det &amp; 1) tv = fa[tv][i]; &#125; if(tu == tv) return tu; for(int i = DEG - 1; i &gt;= 0; --i)&#123; if(fa[tu][i] == fa[tv][i])&#123; continue; &#125; tu = fa[tu][i]; tv = fa[tv][i]; &#125; return fa[tu][0];&#125;bool flag[maxn];int main()&#123; int n, m, s; init(); memset(flag, false, sizeof(flag)); cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for (int i = 1; i &lt; n; ++i)&#123; int a, b; cin &gt;&gt; a &gt;&gt; b; addedge(a, b); addedge(b, a); flag[b] = true; &#125; int root; for (int i = 1; i &lt;= n; ++i)&#123; if(!flag[i]) &#123; root = i; break; &#125; &#125; bfs(s);//根节点 for (int i = 0; i &lt; m; ++i)&#123; int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; lca(a, b) &lt;&lt; endl; &#125; return 0;&#125; cost12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 5e5 + 5;#define re(a) memset(a, 0, sizeof(a));vector&lt;int&gt; v[maxn], w[maxn];int fa[maxn][31], cost[maxn][31], dep[maxn];int n, m;int a, b, c;void dfs(int root, int faa)&#123; fa[root][0] = faa; dep[root] = dep[fa[root][0]] + 1; for(int i = 1; i &lt; 31; ++i)&#123; fa[root][i] = fa[fa[root][i - 1]][i - 1]; //cost[root][i] = cost[fa[root][i - 1]][i - 1]; &#125; int sz = v[root].size(); for (int i = 0; i &lt; sz; ++i)&#123; if(v[root][i] == faa) continue; //cost[v[root][i]][0] = w[root][i]; dfs(v[root][i], root); &#125;&#125;int lca(int x, int y)&#123; if(dep[x] &gt; dep[y]) swap(x, y); int temp = dep[y] - dep[x]; //, ans = 0; for (int j = 0; temp; ++j, temp &gt;&gt;= 1) if(temp &amp; 1) // ans += cost[y][j]; y = fa[y][j]; if (y == x) return y; for (int j = 30; j &gt;= 0 &amp;&amp; y != x; --j)&#123; if(fa[x][j] != fa[y][j]) &#123; //ans += cost[x][j] + cost[y][j]; x = fa[x][j]; y = fa[y][j]; &#125; &#125; //ans += cost[x][0] + cost[y][0]; return fa[x][0];&#125;bool flag[maxn];int main()&#123; re(fa); re(cost); re(dep); int s; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for(int i = 1; i &lt; n; ++i)&#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b; //++a, ++b; v[a].push_back(b); v[b].push_back(a); // w[a].push_back(c); // w[b].push_back(c); &#125; dfs(s, 0); //cin &gt;&gt; m; for (int i = 0; i &lt; m; ++i)&#123; int a, b; cin &gt;&gt; a &gt;&gt; b; //++a, ++b; cout &lt;&lt; lca(a, b) &lt;&lt; endl; &#125; return 0;&#125;"},{"title":"最小生成树","path":"/undefined/tree-min/","content":"Kruskal123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;const int maxn = 1e5 + 5;int pre[maxn];struct node&#123; int from, to, w;&#125;g[maxn];bool cmp(node a, node b)&#123; return a.w &lt; b.w;&#125;void init()&#123; for(int i = 1; i &lt;= n; ++i)&#123; pre[i] = i; &#125;&#125;int find(int x)&#123; if(pre[x] == x) return x; return pre[x] = find(pre[x]);&#125;// void merge(int x, int y)&#123;//看个人习惯，也可以写到kru内部// x = find(x);// y = find(y);// if(x != y)// pre[x] = y;// &#125;int kru(int n, int m)&#123; int ans = 0, cnt_edge = 0; sort(g, g + m, cmp); for (int i = 0; i &lt; m; ++i)&#123; int x = g[i].from; int y = g[i].to; x = find(x), y = find(y); if(x != y)&#123; pre[x] = y; ans += g[i].w; ++cnt_edge; if(cnt_edge == n - 1) &#123; cout &lt;&lt; ans; return; &#125; &#125; &#125; cout &lt;&lt; &quot;没连通&quot;;&#125;int main()&#123; init(); return 0;&#125; prim123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;#define re(a) memset(a, 0, sizeof(a));#define remax(a) memset(a, 0x3f, sizeof(a));#define PII pair&lt;int, int&gt;const int maxn = 1e4 + 5;int dis[maxn], e[maxn][maxn];int n;bool vis[maxn];int ans;int prim(int s)&#123; remax(dis); re(vis); priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; q; dis[s] = 0; for (int i = 0; i &lt; n; ++i)&#123; int u = -1, minx = 0x3f3f3f; for (int j = 0; j &lt; n; ++j)&#123; if(!vis[j] &amp;&amp; dis[j] &lt; minx)&#123; u = j; minx = dis[j]; &#125; &#125; if(u == -1) return -1; vis[u] = true; ans += dis[u]; for (int v = 0; v &lt; n; ++v)&#123;//中间点 if(!vis[v] &amp;&amp; e[u][v] != 0x3f3f3f3f) dis[v] = min(dis[v], e[u][v]); &#125; &#125; return ans;&#125;int main()&#123; return 0;&#125;"},{"title":"树状数组","path":"/undefined/treeArray/","content":"差分12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1e5;int a[maxn];int sum[maxn];int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; a[i]; sum[i] = a[i] - a[i - 1]; &#125; int l, r, c; for (int i = 1; i &lt;= m; ++i)&#123; cin &gt;&gt; l &gt;&gt; r &gt;&gt; c; sum[l] += c; sum[r + 1] -= c; &#125; for (int i = 1; i &lt;= n; ++i)&#123; a[i] = sum[i] + a[i - 1]; // if (i == 1) // cout &lt;&lt; (sum[i] + a[i - 1]); // else cout &lt;&lt; &quot; &quot; &lt;&lt; (sum[i] + a[i - 1]); //这样是错误的， 前面 a[i - 1] 会影响到后续的计算 if (i == 1) cout &lt;&lt; a[i]; else cout &lt;&lt; &quot; &quot; &lt;&lt; a[i]; &#125; cout &lt;&lt; endl; return 0;&#125; 单点更新区间查询12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;const int maxn = 2e4;int n;int a[maxn], C[maxn];inline int lowbit(int x)&#123;//lowbit（）函数用来取一个二进制最低位的一与后边的0组成的数 return x &amp; (-x);&#125;int sum(int x)&#123; //sum[1, i] int sum = 0; while(x &gt; 0)&#123; sum += C[x]; x -= lowbit(x);// &#125; return sum;&#125;//单点更新void updata(int x, int val)&#123;//更新（由小到大）是查询的逆过程 while(x &lt;= n)&#123;//可能会是maxn C[x] += val; x += lowbit(x);// &#125;&#125;int main()&#123; return 0;&#125; 区间更新单点查询123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;const int maxn = 1e5;int n;int a[maxn], C[maxn];//这样就把，原来要更新一个区间的值变成了只需要更新两个点//通过两个端点的更新inline int lowbit(int x)&#123; return x &amp; (-x);&#125;int sum(int i)&#123; //sum[1, i] int sum = 0; while(i &gt; 0)&#123; sum += C[i]; i -= lowbit(i);// &#125; return sum;&#125;//单点更新void updata(int i, int val)&#123;//更新（由小到大）是查询的逆过程 while(i &lt;= n)&#123; C[i] += val; i += lowbit(i);// &#125;&#125;int main()&#123; int x, y, k; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; a[i]; updata(i, a[i] - a[i - 1]); &#125; //[x, y] 加 k updata(x, k);//a[x] - a[x - 1] 加 k updata(y + 1, -k); //a[y + 1] - a[y] 减 k int i; //查询i位置的值 int sum_ = sum(i); return 0;&#125; 区间更新区间查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;const int maxn = 1e5;int n;int a[maxn], C[maxn];inline int lowbit(int x)&#123; return x &amp; (-x);&#125;int sum1[maxn], sum2[maxn];int sum(int i)&#123; //sum[1, i] int sum = 0, x = i; while(i &gt; 0)&#123; sum += x *sum1[i] - sum2[i]; i -= lowbit(i);// &#125; return sum;&#125;//单点更新void updata(int i, int val)&#123;//更新（由小到大）是查询的逆过程 int x = i; while(i &lt;= n)&#123; sum1[i] += val; sum2[i] += val; i += lowbit(i);// &#125;&#125;int main()&#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; a[i]; updata(i, a[i] - a[i - 1]); &#125; int x, y, k; //[x, y] 加 k updata(x, k);//a[x] - a[x - 1] 加 k updata(y + 1, -k); //a[y + 1] - a[y] 减 k int i; //[x, y]区间和 int sum_ = sum(y) - sum(x - 1); return 0;&#125;"},{"title":"背包板子","path":"/undefined/bag/","content":"01背包12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;deque&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;queue&gt;using namespace std;// N 件物品和一个容量是 V 的背包。每件物品只能使用一次#define re(a) memset((a), 0, sizeof((a)))#define rem(a) memset((a), 0x3f, sizeof((a)))#define ll long longint n, m;const int maxn = 1e6 + 5;ll a[maxn], b[maxn], pre[maxn], aft[maxn];ll dp[1005];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; a[i] &gt;&gt; b[i]; &#125; dp[0] = 0; for(int i = 1; i &lt;= n; ++i) for (int j = m; j &gt;= 0; --j)&#123;//倒着 //dp[j] = dp[j]; if(j - a[i] &gt;= 0) dp[j] = max(dp[j], dp[j - a[i]] + b[i]); &#125; cout &lt;&lt; dp[m]; return 0;&#125; 完全背包1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;deque&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;queue&gt;using namespace std;//N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。#define re(a) memset((a), 0, sizeof((a)))#define rem(a) memset((a), 0x3f, sizeof((a)))#define ll long longint n, m;const int maxn = 1e6 + 5;ll a[maxn], b[maxn], pre[maxn], aft[maxn];ll dp[1005][1005];int main()&#123; cin &gt;&gt; n &gt;&gt; m; //n件物品，m的体积 for (int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; a[i] &gt;&gt; b[i]; &#125; dp[0][0] = 0; for(int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt;= m; ++j)&#123;//顺着 dp[i][j] = dp[i - 1][j]; if(j - a[i] &gt;= 0) dp[i][j] = max(dp[i - 1][j], dp[i][j - a[i]] + b[i]); &#125; cout &lt;&lt; dp[n][m]; return 0;&#125; 多重背包1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;#include&lt;vector&gt;//N 种物品和一个容量是 V 的背包。//第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。using namespace std;int dp[105];int main()&#123; int v, w, s; int N, V; cin &gt;&gt; N &gt;&gt; V; //------------------------------朴素 for(int i = 0; i &lt; N; ++i)&#123; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; for(int j = V; j &gt;= 0; --j)&#123; for(int k = 0; k &lt;= s &amp;&amp; k * v &lt;= j; ++k)&#123; dp[j] = max(dp[j], dp[j - k * v] + k * w); &#125; &#125; &#125; cout &lt;&lt; dp[V]; //--------------------------2000内优化 vector&lt;pair&lt;int, int&gt;&gt; vv; int f[2005]; for (int i = 0; i &lt; N; ++i)&#123; int v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; for (int k = 1; s &gt;= k; k *= 2)&#123; s -= k; vv.push_back(&#123;v * k, w * k&#125;); &#125; if(s &gt; 0) vv.push_back(&#123;v * s, w * s&#125;); &#125; for(auto w: vv)&#123; for (int i = V; i &gt;= w.first; --i)&#123; f[i] = max(f[i], f[i - w.first] + w.second); &#125; &#125; cout &lt;&lt; f[V] &lt;&lt; endl; //-----------------------------20000数组模拟单调队列优化 int q[20002], g[20002], dp[20002]; int N, V; cin &gt;&gt; N &gt;&gt; V; for (int i = 0; i &lt; N; ++i)&#123; int v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; memcpy(g, dp, sizeof dp); for (int j = 0; j &lt; v; ++j)&#123;//枚举余数即等价类 int head = 0, tail = -1; for (int k = j; k &lt;= V; k += v)&#123;//枚举同一等价类的背包体积 if(head &lt;= tail &amp;&amp; k - s * v &gt; q[head])//当前编号-队列最大容积（间隔v 容积s * v）＞首元素，则需将首元素出队 ++head;//要维护一个不超过s的集合。 while(head &lt;= tail &amp;&amp; g[q[tail]] - (q[tail] - j) / v * w &lt;= g[k] - (k - j) / v * w) --tail;//分别表示队尾元素的值和当前元素的值 f[0] if(head &lt;= tail)// dp[i - 1] dp[k] = max(dp[k], g[q[head]] + (k - q[head]) / v * w); //f[v] - 1 * w f[2v] - 2 * w q[++tail] = k;//k个 去除了比当前小的元素，保证队列里的元素都比当前元素大，入队 &#125; &#125; &#125; cout &lt;&lt; dp[V] &lt;&lt; endl; return 0;&#125; 混合背包1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;struct node&#123; int v, w, flag;&#125;;vector&lt;node&gt; ve;int dp[1005];int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; ++i)&#123; int v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; if(s &lt;= 0) ve.push_back(&#123;v, w, s&#125;); else &#123; int k; for (int k = 1; k &lt;= s; k *= 2)&#123; s -= k; ve.push_back(&#123;v * k, w * k, -1&#125;);//拆成01 &#125; if(s &gt; 0) ve.push_back(&#123;v * s, w * s, -1&#125;); &#125; &#125; for(auto w: ve)&#123; if(w.flag &lt; 0)&#123; for (int j = m; j &gt;= w.v; --j)&#123; dp[j] = max(dp[j], dp[j - w.v] + w.w); &#125; &#125; else &#123; for (int j = w.v; j &lt;= m; ++j)&#123; dp[j]= max(dp[j], dp[j - w.v] + w.w); &#125; &#125; &#125; cout &lt;&lt; dp[m]; return 0;&#125;"},{"title":"线段相交判定板子","path":"/undefined/线段相交判定/","content":"线段是否相交1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;using namespace std;// template&lt;class T&gt; double chaji(T c, T d, T a)&#123;// // return (p3.x - p1.x) * (p3.y - p2.y) - (p3.x - p2.x) * (p3.y - p1.y);// return (a.first - c.first) * (d.second - c.second) - (d.first - c.first) * (a.second - c.second);// &#125;template&lt;class T&gt; bool judge2(T a, T b, T c, T d)&#123; if(max(a.first , b.first) &gt;= min(c.first, d.first) &amp;&amp; max(c.first, d.first) &gt;= min(a.first, b.first) &amp;&amp; max(a.second, b.second) &gt;= min(c.second, d.second) &amp;&amp; max(c.second, d.second) &gt;= min(a.second, b.second)) return true; return false; &#125;template&lt;class T&gt; bool judge1(T a, T b, T c, T d)&#123;//跨立实验 if(!judge2(a, b, c, d)) return false; double d1 = (a.first - c.first) * (d.second - c.second) - (d.first - c.first) * (a.second - c.second); double d2 = (d.first - c.first) * (b.second - c.second) - (b.first - c.first) * (d.second - c.second); double d3 = (c.first - a.first) * (b.second - a.second) - (b.first - a.first) * (c.second - a.second); double d4 = (b.first - a.first) * (d.second - a.second) - (d.first - a.first) * (b.second - a.second); if(d3 * d4 &gt;= 0 &amp;&amp; d1 * d2 &gt;= 0) return true; else return false;&#125;//一般做题是先快速排斥， 后跨立int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; pair&lt;double, double&gt; p[4]; cin &gt;&gt; p[0].first &gt;&gt; p[0].second &gt;&gt; p[1].first &gt;&gt; p[1].second &gt;&gt; p[2].first &gt;&gt; p[2].second &gt;&gt; p[3].first &gt;&gt; p[3].second; if (judge1(p[0], p[1], p[2], p[3])) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; return 0;&#125; 线段相交是否规范（只能过90%数据，先占个位） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//#include&lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;vector&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;climits&gt;#define IOS ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL);using namespace std;const int maxx = 1e4 + 5;const int maxn = 1e6 + 5;#define N 10000100#define ll long long#define endl &#x27; &#x27;const ll mod = 998244353;#define test printf(&quot;-------------------------- &quot;);#define re(a) memset((a), 0, sizeof((a)))#define remax(a) memset((a), 0x3f3f3f3f, sizeof((a)))#define PII pair&lt;int, int&gt;const double pi=acos(-1.0);inline int llog(int n)&#123; return 31 - __builtin_clz(n);&#125; //取对数// struct cmp&#123;// friend bool operator &gt; (const struct scoree &amp;a, const struct scoree &amp;b)&#123;// return a.score &gt; b.score;// &#125;// &#125;;template&lt;class T&gt; bool judge2(T a, T b, T c, T d)&#123; if(max(a.first , b.first) &gt;= min(c.first, d.first) &amp;&amp; max(c.first, d.first) &gt;= min(a.first, b.first) &amp;&amp; max(a.second, b.second) &gt;= min(c.second, d.second) &amp;&amp; max(c.second, d.second) &gt;= min(a.second, b.second)) return true; return false;&#125;template&lt;class T&gt; bool judge1(T a, T b, T c, T d)&#123; if(!judge2(a, b, c, d))&#123; return 0; &#125; double d1 = (a.first - c.first) * (d.second - c.second) - (d.first - c.first) * (a.second - c.second); double d2 = (d.first - c.first) * (b.second - c.second) - (b.first - c.first) * (d.second - c.second); double d3 = (c.first - a.first) * (b.second - a.second) - (b.first - a.first) * (c.second - a.second); double d4 = (b.first - a.first) * (d.second - a.second) - (d.first - a.first) * (b.second - a.second); if(d3 * d4 &gt;= 0 &amp;&amp; d1 * d2 &gt;= 0)&#123; return true; &#125; else return false;&#125;bool judge3(PII a, PII b, PII c, PII d) &#123; if((b.first - a.first) * (c.first - d.first) + (b.second - a.second) * (d.second - c.second) == 0) &#123; return true; &#125; return false;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; pair&lt;double, double&gt; p[4]; cin &gt;&gt; p[0].first &gt;&gt; p[0].second &gt;&gt; p[1].first &gt;&gt; p[1].second &gt;&gt; p[2].first &gt;&gt; p[2].second &gt;&gt; p[3].first &gt;&gt; p[3].second; if(judge1(p[0], p[1], p[2], p[3]))&#123; if(judge3(p[0], p[1], p[2], p[3])) cout &lt;&lt; 1 &lt;&lt; endl; else cout &lt;&lt; 2 &lt;&lt; endl; &#125; else cout &lt;&lt; 0 &lt;&lt; endl; &#125; return 0;&#125;"},{"title":"最短路","path":"/undefined/dij/","content":"##先总结吧 学习链接Floyd 任意两个结点之间的最短路 我觉得像dp 12345678//自己到自己标为0或1， 没有通路为∞ for (int k = 1; k &lt;= n; ++k)&#123;//是否经过k的最短路 for(int i = 1; i &lt;= n; ++i)&#123; for (int j = 1; j &lt;=n; ++j)&#123; map[i][j] = min(map[i][j], map[i][k] + map[k][j]); &#125; &#125; &#125; 只允许经过规定结点 123456789101112131415161718192021//只允许经过3 for(int i = 1; i &lt;= n; ++i)&#123; for(int j = 1; j &lt;= n; ++j)&#123; if(map[i][j] &gt; map[i][3] + map[3][j]) map[i][j] = map[i][3] + map[3][j]; &#125; &#125; //只允许经过3、4 for(int i = 1; i &lt;= n; ++i)&#123; for(int j = 1; j &lt;= n; ++j)&#123; if(map[i][j] &gt; map[i][3] + map[3][j]) map[i][j] = map[i][3] + map[3][j]; &#125; &#125; for(int i = 1; i &lt;= n; ++i)&#123; for(int j = 1; j &lt;= n; ++j)&#123; if(map[i][j] &gt; map[i][4] + map[4][j]) map[i][j] = map[i][4] + map[4][j]; &#125; &#125; 点到点连通 12345678910111213141516171819//1 for(int i = 1; i &lt;= n; ++i)&#123; bool flag = true; for(int j = 1; j &lt;= n; ++j)&#123; if(!g[j][i])&#123; flag = false; break; &#125;\t&#125;\tif(flag) &#123; cout &lt;&lt; i &lt;&lt; endl; return 0;\t&#125;&#125;//2 边权变为0/1std::bitset&lt;SIZE&gt; f[SIZE];for (k = 1; k &lt;= n; k++) for (i = 1; i &lt;= n; i++) if (f[i][k]) f[i] = f[i] | f[k]; johnson进阶版floyd bellman-ford 含负权，单源最短路, 不能出现负权回路 初始所有的点位∞，起点为0 循环n次， 遍历m松弛操作（逐步接近，移动，取min） 容易理解的版本 123456789101112131415161718192021222324252627bool bf()&#123; int n, m; int map[105][105]; int s = 1; int d[105]; memset(d, INF, sizeof(d)); int flag = 0; for (int i = 0; i &lt;= n; ++i)&#123; for (int j = 1; j &lt;= n; ++j)&#123; for (int k = 1; k &lt;= n; ++k)&#123; if(d[k] &gt; d[j] + map[j][k])&#123; d[k] = d[j] + map[j][k]; flag = 1; &#125; &#125; &#125; if(!flag) return true; &#125; for (int i = 1; i &lt;= n; ++i)&#123; for (int j = 1; j &lt;= m; ++j)&#123; if(d[j] &gt; d[i] + map[i][j])&#123; return false;//判断是否有负环 &#125; &#125; &#125;&#125; 这个代码更好 12345678910111213141516171819202122232425262728293031323334//oi wiki// C++ Versionstruct edge &#123; int v, w;&#125;;vector&lt;edge&gt; e[maxn];int dis[maxn];const int inf = 0x3f3f3f3f;bool bellmanford(int n, int s) &#123; memset(dis, 63, sizeof(dis)); dis[s] = 0; bool flag; // 判断一轮循环过程中是否发生松弛操作 for (int i = 1; i &lt;= n; i++) &#123; flag = false; for (int u = 1; u &lt;= n; u++) &#123; if (dis[u] == inf) continue; // 无穷大与常数加减仍然为无穷大 // 因此最短路长度为 inf 的点引出的边不可能发生松弛操作 for (auto ed : e[u]) &#123; int v = ed.v, w = ed.w; if (dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; flag = true; &#125; &#125; &#125; // 没有可以松弛的边时就停止算法 if (!flag) break; &#125; // 第 n 轮循环仍然可以松弛时说明 s 点可以抵达一个负环 return flag;&#125; spfa:反正被卡是基操就不写了，最坏时间复杂度和bf一样Dijkstra相当于bfs 123456789101112131415161718192021void dij(int s)&#123; memset(dis, 0x3f, sizeof(dis)); memset(vis, false, sizeof(vis)); priority_queue &lt; pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; q;//也可以用struct代替 dis[s] = 0; q.push(&#123;dis[s], s&#125;); while(!q.empty())&#123; int now = q.top().second; q.pop(); if(vis[now]) continue; vis[now] = true; for (int i = head[now]; ~i; i = edge[i].next)&#123; int v = edge[i].to; if(!vis[v] &amp;&amp; edge[i].w + dis[now] &lt; dis[v])&#123; dis[v] = edge[i].w + dis[now]; q.push(&#123;dis[v], v&#125;); &#125; &#125; &#125;&#125; ##题荐 青蛙思路：单源最短路，两两之间取max floyd 123456789101112131415161718192021222324252627282930313233343536//5552mspair&lt;int, int&gt; p[210];double dist[210][210];int t;int pre[210];int main() &#123;\tIOS;\tint cnt = 1;\twhile (cin &gt;&gt; t &amp;&amp; t) &#123; re(p); re(dist); re(pre); for (int i = 1; i &lt;= t; ++i) cin &gt;&gt; p[i].first &gt;&gt; p[i].second; //求距离 for (int i = 1; i &lt;= t - 1; ++i) &#123;//这里注意范围，否则要错 for (int j = i + 1; j &lt;= t; ++j) &#123; dist[i][j] = dist[j][i] = sqrt((p[i].first - p[j].first) * (p[i].first - p[j].first) + (p[i].second - p[j].second) * (p[i].second - p[j].second)); &#125; &#125; //floyd for (int k = 1; k &lt;= t; ++k) &#123; for (int i = 1; i &lt;= t - 1; ++i) &#123;//范围 for (int j = i + 1; j &lt;= t; ++j) &#123; if (dist[i][k] &lt; dist[i][j] &amp;&amp; dist[k][j] &lt; dist[i][j]) dist[i][j] = dist[j][i] = max(dist[i][k], dist[k][j]); &#125; &#125; &#125; printf(&quot;Scenario #%d &quot;, cnt++); printf(&quot;Frog Distance = %.3f &quot;, dist[1][2]);\t&#125;\treturn 0;&#125; dij太久没用优先队列都不会了orz优先队列用法最大的收获是：在while里面定义，记得初始化，最好用全int，最后再改值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//1947mspair&lt;int, int&gt; p[210];int t;int dis[210];bool vis[210];struct node&#123; int j, dist;&#125;;int main() &#123;\tIOS;\tint cnt = 1;\twhile (cin &gt;&gt; t &amp;&amp; t) &#123; re(p); remax(dis); re(vis); vector&lt;node&gt; a[210]; for (int i = 1; i &lt;= t; ++i) cin &gt;&gt; p[i].first &gt;&gt; p[i].second; for(int i = 1; i &lt;= t; ++i)&#123; for (int j = i + 1; j &lt;= t; ++j)&#123; if(i != j)&#123; int w = (p[i].first - p[j].first) * (p[i].first - p[j].first) + (p[i].second - p[j].second) * (p[i].second - p[j].second); a[i].push_back(&#123;j, w&#125;); a[j].push_back(&#123;i, w&#125;); &#125; &#125; &#125; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; q; q.push(&#123;0, 1&#125;); dis[1] = 0; while(!q.empty())&#123; int now = q.top().second; q.pop(); if(vis[now]) continue; vis[now] = true; for(auto w : a[now])&#123; int j = w.j; if(dis[j] &gt; max(dis[now], w.dist))&#123; dis[j] = max(dis[now], w.dist); q.push(&#123;dis[j], j&#125;); &#125; &#125; &#125; printf(&quot;Scenario #%d &quot;, cnt++); printf(&quot;Frog Distance = %.3f &quot;, sqrt(dis[2]));\t&#125;\treturn 0;&#125; 货物运输和上一道思路一模一样，怎么说呢，做了和没做好像没有什么区别，还给我整焦虑了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct node&#123; int v, w;&#125;;bool vis[1005];int dist[1005];void dij(vector&lt;node&gt; v[])&#123; re(vis); re(dist); priority_queue&lt;pair&lt;int, int&gt;&gt; q; q.push(&#123;2e9,1&#125;); dist[1] = 2e9;//相当于要求的是最大的最长的路径，和上一题唯一不同点 while(!q.empty())&#123; pair&lt;int, int&gt; temp = q.top(); q.pop(); if(vis[temp.second]) continue; vis[temp.second] = true; for(auto w : v[temp.second])&#123; int v = w.v; if(dist[v] &lt; min(dist[temp.second], w.w))&#123; dist[v] = min(dist[temp.second], w.w); q.push(&#123;dist[v], v&#125;); &#125; &#125; &#125;&#125;int main() &#123;\tIOS;\t// freopen(&quot;P1908_6.in&quot;,&quot;r&quot;,stdin);//读入数据\t// freopen(&quot;P1908.out&quot;,&quot;w&quot;,stdout); //输出数据 int t; cin &gt;&gt; t; for(int c = 1; c &lt;= t; ++c)&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; //来建图 vector&lt;node&gt; v[1005]; for (int i = 1; i &lt;= m; ++i)&#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; v[a].push_back(&#123;b, c&#125;); v[b].push_back(&#123;a, c&#125;); &#125; dij(v); printf(&quot;Scenario #%d: &quot;,c); printf(&quot;%d &quot;, dist[n]); &#125; return 0;&#125; 最小值中的最大值初始化: ans &#x3D; 0;最大值中的最小值出初始化： ans &#x3D; 0x3f3f3f;然后ans逐渐缩小范围，得到最优解"},{"title":"树的中/后序遍历（简易）","path":"/undefined/tree-round/","content":"全部都是先左子树，再右子树 中序: 先往左下走，无再向左的决策，输出该点回到上一点(父节点)再次判断。后序:先往左下走，无可选择的决策，输出该点回到上一点判断 决策: 决定这一步向左子树走还是向右子树走。 递归也是这样的道理"},{"title":"蓝桥杯","path":"/undefined/蓝桥杯/","content":"枚举模拟、数论、图论、动规、贪心 dijkstra、floyd、gcd、素数筛、质因数分解 dp简单的就那几个，挨个挨个方法试（-1啊、|、max、*） 这个看不清就换个方式看或者打表 excel会自动忽略第一天 遇到不知道的：暴力枚举骗分 不明所以的数可能是比例 找出必定成立的地方 二分是最优策略 dp相同的限制可以矩阵快速幂 感觉少了就加一维 裴蜀定理解方程 组合数可以用二位前缀和 组合 -&gt; 递归 &#x2F; dp（主要看数据范围） 矩阵快速幂 123456789101112void mul(int a[][2], int b[][2], int c[][2])&#123; int temp[][2] = &#123;&#123;0, 0&#125;, &#123;0, 0&#125;&#125;; for (int i = 0; i &lt; 2; i ++ ) for (int j = 0; j &lt; 2; j ++ ) for (int k = 0; k &lt; 2; k ++ ) &#123; long long x = temp[i][j] + (long long)a[i][k] * b[k][j]; temp[i][j] = x % MOD; &#125; memcpy(a, temp, sizeof temp);&#125; 快速幂 123456789ll fast_power(ll a, ll b, ll p)&#123; ll pr = 1; while(b &gt; 0)&#123; if(b &amp; 1) pr = pr * a % p; a = a * a % p; b &gt;&gt;= 1; &#125;&#125; 拓展欧几里得 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;int exgcd(int a, int b, int &amp;x, int &amp;y)&#123; if(!b)&#123;//因为那个式子是以y的 x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x;//----!!! return d;&#125;int main()&#123; int a, b, x, y; cin &gt;&gt; a &gt;&gt; b; int d = exgcd(a, b, x, y); printf(&quot;%d * %d + %d * %d = %d&quot;, a, x, b, y, d); //同时扩大 if((b - a) % d)&#123; cout &lt;&lt; &quot;FOREVER&quot; &lt;&lt; endl; &#125; else &#123; x *= (b - a) / d; mod /= d; cout &lt;&lt; (x % mod + mod) % mod &lt;&lt; endl;\t&#125; return 0;&#125; 素数筛（注意范围） 1234567891011121314151617int cnt = 0;int prime[maxn];bool p[maxn];void ola()&#123; for (int i = 2; i &lt; 1048575; ++i)&#123; if(!p[i]) prime[++cnt] = i; for (int j = 1; j &lt;= cnt &amp;&amp; prime[j] &lt; 1048575 / i; ++j)&#123; p[i * prime[j]] = true; if(i % prime[j] == 0) break; &#125; &#125;&#125;//找因子的可以先把因子（含合数）全弄出来（% == 0），再看 龟速乘 123456789101112131415using namespace std;typedef long long ll;int n;ll fast_mult(ll a, ll b) &#123; ll res = 0; while (b &gt; 0) &#123; if (b &amp; 1) &#123; res = (res + a) % n; &#125; b &gt;&gt;= 1; a = (a + a) % n; &#125; return res % n;&#125; dijkstra（负权不行） 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int dis[105], vis[105], head[105];void dij(int s)&#123; memset(dis, 0x3f, sizeof(dis)); memset(vis, false, sizeof(vis)); priority_queue &lt; pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; q; dis[s] = 0; q.push(&#123;dis[s], s&#125;); while(!q.empty())&#123; int now = q.top().second; q.pop(); if(vis[now]) continue; vis[now] = true; for (int i = head[now]; ~i; i = edge[i].next)&#123; int v = edge[i].to; if(!vis[v] &amp;&amp; edge[i].w + dis[now] &lt; dis[v])&#123; dis[v] = edge[i].w + dis[now]; q.push(&#123;dis[v], v&#125;); &#125; &#125; &#125;&#125;int main()&#123; //一个节点到其他所有节点的最短路， 类似bfs， 不带负权 return 0;&#125; floyd 12345678for (int k = 1; k &lt;= n; ++k)&#123; for(int i = 1; i &lt;= n; ++i)&#123; for (int j = 1; j &lt;=n; ++j)&#123; if(map[i][j] &gt; map[i][k] + map[k][j]) map[i][j] = map[i][k] + map[k][j]; &#125; &#125; &#125; 并查集 1234567891011121314151617181920212223242526void init(int n)&#123; for(int i = 1; i &lt;= n; ++i)&#123; pre[i] = i;//初始化自己 &#125;&#125;int find(int x)&#123;//不是直接用的 if(pre[x] == x) return x; return pre[x] = find(pre[x]);&#125;void merge(int x, int y)&#123; x = find(x); y = find(y); if(x == y) return; if(rankk[x] &gt; rankk[y])//高度 pre[y] = x; else &#123; if(rankk[x] == rankk[y]) rankk[y]++; pre[x] = y; &#125;&#125; 背包考前看视频吧，其余dp看一下 12345678//01 dp[0] = 0; for(int i = 1; i &lt;= n; ++i) for (int j = m; j &gt;= 0; --j)&#123;//倒着 //dp[j] = dp[j]; if(j - a[i] &gt;= 0) dp[j] = max(dp[j], dp[j - a[i]] + b[i]); &#125; cout &lt;&lt; dp[m]; 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;deque&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;queue&gt;using namespace std;//N 种物品和一个容量是 V 的背包，每种物品都有无限件可用 完全背包#define re(a) memset((a), 0, sizeof((a)))#define rem(a) memset((a), 0x3f, sizeof((a)))#define ll long longint n, m;const int maxn = 1e6 + 5;ll a[maxn], b[maxn], pre[maxn], aft[maxn];ll dp[1005][1005];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; a[i] &gt;&gt; b[i]; &#125; dp[0][0] = 0; for(int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt;= m; ++j)&#123;//顺着 dp[i][j] = dp[i - 1][j]; if(j - a[i] &gt;= 0) dp[i][j] = max(dp[i - 1][j], dp[i][j - a[i]] + b[i]); &#125; cout &lt;&lt; dp[n][m]; return 0;&#125; 树状数组 12345678910111213141516171819202122232425262728293031323334inline int lowbit(int x)&#123; return x &amp; (-x);&#125;int sum(int i)&#123; //sum[1, i] int sum = 0; while(i &gt; 0)&#123; sum += C[i]; i -= lowbit(i);// &#125; return sum;&#125;//单点更新void updata(int i, int val)&#123;//更新（由小到大）是查询的逆过程 while(i &lt;= n)&#123; C[i] += val; i += lowbit(i);// &#125;&#125;int main()&#123; int x, y, k; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; a[i]; updata(i, a[i] - a[i - 1]); &#125; //[x, y] 加 k updata(x, k);//a[x] - a[x - 1] 加 k updata(y + 1, -k); //a[y + 1] - a[y] 减 k int i; //查询i位置的值 int sum_ = sum(i);"},{"title":"寒假新学总结","path":"/undefined/寒假新学总结/","content":"123456789map&lt;int, multiset&lt;int&gt;, greater&lt;int&gt;&gt; mp;for (auto w : mp) &#123; cout &lt;&lt; w.first; for (auto v : w.second) &#123; cout &lt;&lt; v; cout &lt;&lt; w.first; &#125;\t&#125; 12345678910#include&lt;algorithm&gt;对给定范围进行&quot;排序&quot; nth_element(l, set, r, compare)a中第k小的值，第二个参数就应该填a+k-1当元素较多时平均时间复杂度为O(N)，元素较少时最坏情况下时间复杂度为O(N^2)。 求[first, last]这个区间中第n大小的元素，如果参数加入了compare函数，就按compare函数的方式比较。 sort函数底层使用的是快速排序算法 O(nlog2n) 其它：https://www.jianshu.com/p/a68390d78386 因此此题直接将字符画贴源码里直接交(PHP)能过。 $$a_i| a_j &gt;&#x3D; lcm(a_i, a_j)$$ 12对于 x,y (x≤y)，若x∣y，那么 lcm(x, y) = y是一组解。否则lcm(x, y) ≥ 2y &gt; x or y，不可能是解。于是就变成找序列中是不是存在一个数是另一个数的因数 LL其实代表long long，*1LL是为了在计算时，把int类型的变量转化为long long，然后再赋值给long long类型的变量不至于后面计算溢出 （1ll &#x3D; 1, 2ll &#x3D; 2） 看第 i 位是不是1，可以右移 i 位再 &amp;1 看 u &gt;&gt; i &amp; 1 （要从0开始枚举） 看取不取： state的u位置成1，说明选这个数，某种程度上可以代替数组 state | (1 &lt;&lt; u) 奇偶本质是01 边权是0或者是1就可以转化成双端队列 scanf(“%*d“, &amp;v[i]); 那个是跳过不读的意思 10进制转n进制： 取余倒排 二分： 123int mid = (l + r) / 2; l = mid + 1, r = mid;int mid = (l + r + 1) / 2; l = mid, r = mid - 1; memeset( , 0x3f, ); 相当于每个都是0x3f3f3f3f (4个) 1state |= x &lt;&lt; i //不重，记数字 把x加到state的i位 &lt;=&gt; 第i位是x 1auto &amp;[k, v] : mp 将 xx 的二进制写两次等价于将 xx 后面添加一些’0’ 离正方体最远最近的点是中心和脚 二分就是 最优化问题转化为判定性问题： ​\t判断一下满足或是不满足能不能再细分 问最小值的我们一般都会想到二分 一个二叉树的小常识： 二叉树节点 向下投影，映射成的数组序列就是 中序遍历序列 区间合并"},{"title":"小函数","path":"/undefined/小函数/","content":"大小写转化： 12transform(src.begin(), src.end(), src.begin(), ::toupper);transform(src.begin(), src.end(), dst.begin(), ::tolower); 全排列： 1234do &#123; cout &lt;&lt; s &lt;&lt; endl;\t&#125; while (next_permutation(s.begin(), s.end()));//升序prev_permutation(s,s+3) 读入空格： 12345cin &gt;&gt; noskipws; //设置cin读取空白符；char ch;//cout &lt;&lt; s &lt;&lt; &quot; &quot;;//真无语还有空格while (cin &gt;&gt; ch) if(ch == &#x27; &#x27;) ++cnt; cin &gt;&gt; skipws;//恢复 字符互转： 1atoi(tem.c_str());"},{"title":"离散化","path":"/undefined/离散化/","content":"不是算法，只是一个降低复杂度的Trick 把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率 你有一个10^3个数据，数据大小在10^12之内，如果直接开一个10^12的数组就肯定会超，而开一个10^3的long long数组就不会超。 map可以实现离散化 所以，我们只需要先把数据存在一个结构体数组里面，对数据排序后再将结构体数组中的数据位置转存到另一个数组上就完全可以避免MLE 题目只需要各元素之间的大小关系而与元素具体大小无关（相对关系） 排序之后，枚举着放回原数组 用一个结构体存下原数和位置，按照原数排序 结构体里面写个重载，也可以写一个比较函数 最后离散化后数在b[]里面 12345678910111213141516171819202122232425262728293031323334复杂度更优，但不能处理重复元素int b[500010];离散后的数据struct in&#123; int shu;实际元素大小 int weizhi;元素所在的位置&#125;dian[500010];bool cmp(in a , in b)&#123; if(a.shu == b.shu) return a.weizhi &lt; b.weizhi; return a.shu &lt; b.shu;&#125;for(int i = 1 ; i &lt;= n ; i ++) &#123; cin &gt;&gt; dian[i].shu; dian[i].weizhi = i;\t&#125;\tsort(dian + 1 , dian + 1 + n , cmp);\tfor(int i = 1 ; i &lt;= n ; i ++)&#123; b[dian[i].weizhi] = i;\t&#125;\tv: 3 6 5 10 8 id:1 2 3 4 5 排序以后： v: 3 5 6 8 10 id:1 3 2 5 4 所以离散化以后： v: 3 5 6 8 10 id:1 3 2 5 4 rk:1 2 3 4 5 在按原来的顺序排列： v: 3 6 5 10 8 rk:1 3 2 5 4 用一个辅助的数组把你要离散的所有数据存下来。 然后排序，排序是为了后面的二分。 去重，因为我们要保证相同的元素离散化后数字相同。 再用二分把离散化后的数字放回原数组。 1234567891011121314151617#include&lt;algorithm&gt; // 头文件 //n 原数组大小 num 原数组中的元素 lsh 离散化的数组 cnt 离散化后的数组大小 int lsh[MAXN] , cnt , num[MAXN] , n;for(int i=1; i&lt;=n; i++) &#123;\tscanf(&quot;%d&quot;,&amp;num[i]);\tlsh[i] = num[i];\t&#125;sort(lsh+1 , lsh+n+1);cnt = unique(lsh+1 , lsh+n+1) - lsh - 1; //unique是c++自带的一个函数，表示对一个数列去重,然后返回不重复的元素个数，当然在后面要减去首地 址//原序列：6 9 4 6 4//排序后：4 4 6 6 9//unique（元素去掉重复的）后：4 6 9 6 9for(int i=1; i&lt;=n; i++)\tnum[i] = lower_bound(lsh+1 , lsh+cnt+1 , num[i]) - lsh;//离散化之后的排名（即新编号）&#123;6,8,4,9,5,6,7,4&#125;，首先排序后得到&#123;4,4,5,6,6,7,8,9&#125;，去重&#123;4,5,6,7,8,9&#125;，然后原序列就变成了&#123;3,5,1,6,2,3,4,1&#125;。 注意事项： 1.去重并不是把数组中的元素删去，而是重复的部分元素在数组末尾，去重之后数组的大小要减一 2.二分的时候，注意二分的区间范围，一定是离散化后的区间 3.如果需要多个数组同时离散化，那就把这些数组中的数都用数组存下来 123456789101112//mp[i]=j;i表示这个数字,j表示这个数所在的位置map&lt;int,int&gt; mp;int n,c[maxn],st[maxn];for (int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;c[i]); st[i]=c[i];&#125;sort(st+1,st+n+1);for (int i=1;i&lt;=n;i++) mp[st[i]]=i;所以对于一个无序数组c,我们找c中任意一个数都可以快速知道它是第几大的数,且mp.size()的值就是数组c的不重复的元素个数 题： [USACO1.2]挤牛奶Milking Cows 人为离散化： 12v.erase(unique(v.begin(), v.end()), v.end());//去重(v.erase(pos, v.end()))"},{"title":"区间问题","path":"/undefined/区间问题/","content":"校门外的树🔗 12345int ans = 0;ans += r - L + 1;//(循环结束后必须再来一个这个)int res = n + 1;res -= r - l + 1; 12345678910111213sort(p, p + m, cmp);int ans = 0;int L = p[0].first, r = p[0].second;for (int i = 1; i &lt; m; ++i) &#123;\tif (p[i].first &gt; r) &#123; ans += r - L + 1; L = p[i].first; r = p[i].second;\t&#125; else &#123; r = max(p[i].second, r);\t&#125;&#125;ans += r - L + 1; cout &lt;&lt; l + 1 - ans&lt;&lt; endl; 区间合并🔗 1234567891011几个区间\tfor (int i = 1; i &lt; m; ++i) &#123; if (p[i].first &gt; r) &#123; ++ans; L = p[i].first; r = p[i].second; &#125; else &#123; r = max(p[i].second, r); &#125;\t&#125;\tcout &lt;&lt; ans + 1 &lt;&lt; endl;//(毕竟最后一个无论如何都要算) 二维的地毯🔗 画图🔗 差分： O(1) 123456789 //++a, ++b;视具体情况而定 ++g[a][b]; --g[c + 1][b]; --g[a][d + 1]; ++g[c + 1][d + 1];for (int i = 1; i &lt;= 100 + 1; ++i) &#123; for (int j = 1; j &lt;= 100 + 1; ++j) &#123; g[i][j] += g[i - 1][j] + g[i][j - 1] - g[i - 1][j - 1]; 前缀和： O(mn + n^2) 1234567891011121314for (int i = 0; i &lt; n; ++i) &#123;\tint a, b, c, d;\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;\tfor (int j = a; j &lt;= c - 1; ++j) &#123;//c-1 / c g[j][b]++; g[j][d]--;//d / d + 1\t&#125;&#125;for (int i = 0; i &lt;= 100 + 1; ++i) &#123;\tfor (int j = 0; j &lt;= 100 + 1; ++j) &#123; ans += g[i][j]; an[i][j] = ans;\t&#125;&#125; 再复杂 ： 1e5 扫描线+线段树（在差分不可用情况下）"},{"title":"字符串","path":"/undefined/字符串/","content":"🔗 类似于字符串匹配 最小的 K 的值，使得他查看任意连续 K 个邮箱序列，可以唯一确定这一序列在道路上的位置。 例如，假设沿路的邮箱序列为 ABCDABC 。 &#x3D;&#x3D;&gt; 4 ABCD 麻烦的是 rrabcrra这种 set即可解决，暴力，关键set.size() &#x3D;&#x3D; num 从1开始暴力循环，因为是长度"},{"title":"易错点","path":"/undefined/易错点/","content":"出现死循环还可能是if else差情况判断 不开long long死得不明不白 string s比大小必须是两步 12if (s.size() &gt; temp.size()) temp = s, max = cnt;else if(s.size() == temp.size() &amp;&amp; s &gt; temp) temp = s, max = cnt;"},{"title":"线段树做题总结","path":"/undefined/线段树做题总结/","content":"线段树的本质 ： 查询 + 修改 [TJOI2018]数学计算 抽象问题 不是所有函数都必须用上 不一定要在所有输入完之后才建树 修改一般是在 add[q] &#x2F; tree[q];"},{"title":"树状数组 、线段树总结","path":"/undefined/树状数组易错点总结/","content":"数星星 步骤： lowbit(int x) 12return x &amp; (-x);关键在于需要跳着去找上一步的东西 updata(int i, int val) 123456while(i &lt;= n)&#123; //这里可能是 i &lt; maxn，acwing数星星，坐标，从0开始的（记得x++） C[i] += val; i += lowbit(i);&#125;直接传 1234567891011int x = i;while(i &lt;= n)&#123; sum1[i] += val; sum2[i] += val; i += lowbit(i);&#125;cin &gt;&gt; a[i];updata(i, a[i] - a[i - 1]);updata(x, k);//a[x] - a[x - 1] 加 kupdata(y + 1, -k); //a[y + 1] - a[y] 减 k sum(int i) ​ sum(y) - sum(x - 1); 表示目标值小于等于i的前缀和 12345int sum = 0;while(i &gt; 0)&#123; sum += C[i]; i -= lowbit(i);&#125; 12345int sum = 0, x = i;while(i &gt; 0)&#123; sum += x * sum1[i] - sum2[i]; i -= lowbit(i); &#125; ———————————————————————————————————————————— 每个区间[L,R]都分解为少量特定的子区间，通过这些少量子区间的修改或统计来实现操作 全部都是从1开始！！！ 它要1e5，数组全开4 * 1e5； 如果感觉时间会被卡可以将*2的操作改为&lt;&lt;1 ， +1改为|1 记得开long long 一般1e5, 1e6是极限，scanf才能过 build(int node, int start, int end) ​ 根据数组在那个点递归构造树，同时把add[]初始为0 12345678910111213if(start == end)&#123; tree[node] = a[start];//注意下标 add[node] = 0;// return; &#125; int mid = (start + end) / 2; int left = 2 * node + 1; int right = 2 * node + 2; build(left, start, mid); build(right, mid + 1, end); tree[node] = tree[left] + tree[right];//更新 pushup add[node] = 0;// updata1(int i, int l, int r,int set, int num) ​ 单点修改，不用add[] 12345678910if(l == set &amp;&amp; r == set) &#123; tree[i] += num; return; &#125; int mid = (l + r) / 2; if(mid &gt;= set) updata1(i * 2 + 1, l, mid, set, num); else updata1(i * 2 + 2, mid + 1, r, set, num); tree[i] = tree[i * 2 + 1] + tree[i * 2 + 2]; pushdown(int k, int l, int r) 将要改变的结点向下传递 123456789int mid = (l + r) / 2; add[2 * k + 1] += add[k];//他可能不只继承一个标记tree[2 * k + 1] += (mid - l + 1) * add[k]; //加上下面那群增加的数，毕竟它代表的是区间和 add[2 * k + 2] += add[k]; tree[2 * k + 2] += (r - mid) * add[k]; add[k] = 0;//使命完成，消去标记 updata2(int q,int l,int r,int tl,int tr,int num) 对区间进行操作 12345678910111213if(l&gt;=tl&amp;&amp;r&lt;=tr)&#123; tree[q] += num * (r - l + 1); add[q] += num; return;\t&#125;if(add[q]) //除了这一步和上面那一步，其余都相同 毕竟只是引入了add这个概念 pushdown(q, l, r); int mid = (l + r) / 2; if(tl&lt;=mid) updata2(q * 2 + 1, l, mid, tl, tr, num); if(tr&gt;mid) updata2(q * 2 + 2, mid + 1, r, tl, tr, num);tree[q] = tree[q * 2 + 1] + tree[q * 2 + 2]; query(int q, int l, int r, int tl, int tr) 递归 query [tl, tr] 1234567891011if(tl &lt;= l &amp;&amp; r &lt;= tr) return tree[q]; if(add[q]) // pushdown(q, l, r); int mid = (l + r) / 2; int sum = 0; if(tl &lt;= mid)//mid决定了它在哪边找 sum += query(q * 2 + 1, l, mid, tl, tr); if(tr &gt; mid) sum += query(q * 2 + 2, mid + 1, r, tl, tr); return sum; 线段树乘法， 与之前有较大差别1ll tree[Maxn&lt;&lt;2],mul[Maxn&lt;&lt;2],add[Maxn&lt;&lt;2],a[Maxn] build(ll p,ll l,ll r) 123456789101112ll m=(l+r)&gt;&gt;1;if(l==r)&#123;\ttree[p]=a[l];//tr[p]=leaf[r];\treturn;&#125;build(p&lt;&lt;1,l,m);build(p&lt;&lt;1|1,m+1,r);tree[p]=tree[p&lt;&lt;1]+tree[p&lt;&lt;1|1];tree[p]%=md;mul[p]=1;return; pushdown(ll p,ll l,ll r) 123456789101112ll m=(l+r)&gt;&gt;1;tree[p&lt;&lt;1]=(tree[p&lt;&lt;1]*mul[p]+add[p]*(m-l+1))%md;//向左儿子传结果tree[p&lt;&lt;1|1]=(tree[p&lt;&lt;1|1]*mul[p]+add[p]*(r-m))%md;//向右儿子传结果mul[p&lt;&lt;1]=(mul[p&lt;&lt;1]*mul[p])%md;//向左儿子传乘法tagmul[p&lt;&lt;1|1]=(mul[p&lt;&lt;1|1]*mul[p])%md;//向右儿子传乘法tagadd[p&lt;&lt;1]=(add[p&lt;&lt;1]*mul[p]+add[p])%md;//向左儿子传加法tagadd[p&lt;&lt;1|1]=(add[p&lt;&lt;1|1]*mul[p]+add[p])%md;//向右儿子传加法tagmul[p]=1;add[p]=0; updmul(ll p,ll l,ll r,ll tl,ll tr,ll k) 12345678910111213if(tr&lt;l||tl&gt;r)return;//若不在此区间就返回上一层，下同if(tl&lt;=l&amp;&amp;tr&gt;=r)&#123;\ttree[p]=(tree[p]*k)%md;\tmul[p]=(mul[p]*k)%md;\tadd[p]=(add[p]*k)%md;\treturn;&#125;pushdown(p,l,r);ll m=(l+r)&gt;&gt;1;updmul(p&lt;&lt;1,l,m,tl,tr,k);//不同之处updmul(p&lt;&lt;1|1,m+1,r,tl,tr,k);tree[p] = (tree[p &lt;&lt; 1] + tree[p &lt;&lt; 1 | 1]) % md; updadd(ll p,ll l,ll r,ll tl,ll tr,ll k) 123456789101112if(tl&gt;r||tr&lt;l)return;if(tl&lt;=l&amp;&amp;tr&gt;=r)&#123;\ttree[p]=(tree[p]+(r-l+1)*k)%md;\tadd[p]=(add[p]+k)%md;\treturn;&#125;pushdown(p,l,r);ll m=(l+r)&gt;&gt;1;updadd(p&lt;&lt;1,l,m,tl,tr,k);updadd(p&lt;&lt;1|1,m+1,r,tl,tr,k);tree[p] = (tree[p &lt;&lt; 1] + tree[p &lt;&lt; 1 | 1]) % md; query(ll p,ll l,ll r,ll tl,ll tr) 12345678if(tl&gt;r||tr&lt;l)return 0;if(tl&lt;=l&amp;&amp;tr&gt;=r)&#123;\treturn tree[p];&#125;pushdown(p,l,r);ll m=(l+r)&gt;&gt;1;return (query(p&lt;&lt;1,l,m,tl,tr)+query(p&lt;&lt;1|1,m+1,r,tl,tr))%md; 区间最大值只修改为max即可，注意如果是不超过2^31 - 1,sum就等于这个数取max **&#x2F;**INT_MIN(climits) zkw线段树"},{"title":"素数筛","path":"/undefined/素数筛/","content":"12345678910111213141516int p[maxx];int cnt = 0;bool prime[maxx]; void ola() &#123; prime[0] = prime[1] = true; for (int i = 2; i &lt; maxx; ++i) &#123; if (!prime[i]) p[++cnt] = i; for (int j = 1; j &lt;= cnt &amp;&amp; i * p[j] &lt; maxx; ++j) &#123; prime[i * p[j]] = true; if (i % p[j] == 0) break; &#125; &#125;&#125;"},{"title":"mysql总结","path":"/undefined/数据库/","content":"12345Show databases;information_schema:存储系统中数据库对象信息Mysql:存储账户信息、权限信息、时区信息Pre_formance_schema:收集数据库服务器性能参数sys：通过视图将information_schema和Pre_formance_schema结合起来，查询出更容易理解的数据 12create database jwgl;use jwgl; 修改数据库: 修改已经被创建或者存在的数据库相关参数，更改全局特性 123alter database jwgl;/ alter schemadefault character set gb312;指定字符集修改default collate gb2312_chinese_ci;默认校对规则 删除数据库 1drop database jwgl; 数据类型： tinyint 8字节 -128-127 smallint 2 -32768-32767 mediumint 3 8e6 int 4 2e9 bigint 8 9e18 小数类型： float 4 单精度浮点数 double 8 双精度浮点数 decimal (m,d), dec m + 2 压缩的“严格”定点数 时间&#x2F;日期类型： year 1 YYYY time 3 HH:MM:SS date 3 YYYY-MM-DD datetime 8 YYYY-MM-DD HH:MM:SS timestamp 4 YYYY-MM-DD HH:MM:SS 字符串类型： char m[1,255] varchar l+1 l[1,255] 固定长度 tinyetext l+1 l&lt;2^8 变长 text l+2 l&lt;2^16 非常小 mediumtext l+3 l&lt;2^24 中等大小 longtext l+4 l&lt;2^32 大的 enum 1或2，取决于枚举值的数目（最大值为65535） 枚举类型，只能有一个枚举字符串值 set 1、2、3、4、8,取决于集合成员的数量（最多64） 一个设置，字符串对象可以有0个或多个set成员 二进制类型： bit (m + 7) &#x2F; 8 binary m varbinary m+1 tinyblob l+1 l&lt;28 blob l+1 l&lt;216 mediumblob l+2 l&lt;224 longblob l+4 l&lt;232 创建数据库表： 123456create table stu(\tsno 数据类型 约束条件)engine=innodb 存储引擎是innodb创建/复制数据库表create table stu like xsjbxxb;stu结果和xsjbxxb相同(like 复制表的结构)create table stu select* from xsjbxxb;完全相同 查看表结构(desc) 1describe xsjbxxb; 查看建表语句（变量） 1show create table xsjbxxb; 修改数据库表 1234567alter table stu [add啊之类的] 改变表原有的结构alter table stu add column tel int(11);添加一个int telalter table stu modify tel varchar(8); 把int tel改为varchar telalter table stu drop tel; alter table stu change tel tell int;修改字段名称varchar tel-&gt;int tellalter table stu rename stuu; 修改表名 删除表 1drop table [if exists] stu; 表记录的插入 12345insert into stu[(行的名称)] values(具体数值);指定字段及其对应的值时，字段可以不按照表中字段的顺序排列，但字段 和值要一一对应不指定时，值的顺序必须和表中顺序完全一样insert into stu values(具体数值)，(具体数值);同时插入多条数据insert into stu(字段列表) select (xsjbxxb的字段列表) from xsjbxxb [where 2的=xxx];将其他表的数据插入表中 表记录的修改 1update stu set xb = &#x27;男&#x27; where xm = &#x27;张三&#x27;;把所有姓名为张三的学生性别改为男 表记录的删除 123delete from stu [where xm = &#x27;张三&#x27;];删除stu里的xm为张三的truncate table stu;删除stu表的全部数据 主键约束： 主键（主码）由表中的一个字段或 多个字段组成，可以唯一的标识表中的一条记录。主键的取值不能为null，且取值唯一，不能重复，以此保证实体完整性。 12345678910创建时 xm varchar(12) primary key;复合主键，在末尾完了后 primary key(xm, xh)如果约束是多列定义的，某个列值可以重复，但这多列里所有列的组合值必须唯一当主键只有一个字段时，既可以将主键定义为列级完整性约束，也能是表级完整性约束；多个字段只能表级完整性约束alter table stu modify xh varchar(12) not null primaty key;对于已存在的表alter table stu add primary(xm, xh);复合主键alter table stu drop primary;删除主键约束 外键约束： 引用另一个表的一列或多列，被引用的列应该具有主键约束或唯一性约束，包含外键的表称为子表，（父表） 表在外键上的取值要么是父表中的某个主键值，要么取空值，以此保证两个表之间的连接确保实体的参照完整性;否则会失败 主属性字段在插入时，子表不允许有父表没有的。 refrences:参照性，定义中包含了外键所参照的表和列 on delete| on update:为每个外键定义参照动作 restrict 当在父表（即外键的来源表）中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。 casade 删除&#x2F;更新 A 表的数据时，对应 B 表的数据也会删除&#x2F;更新； set null on delete set null：删除&#x2F;更新 A 表的数据时，对应 B 表的外键字段置为空（前提是该字段可以为空）如果添加外键时没加上面内容，删除&#x2F;更新 A 表的数据时，如果对应 B 表有数据就会报错； no action 意思同restrict.即如果存在从数据，不允许删除&#x2F;更新主数据。 1234建表时，将学号设置为外键，在最后 foreign key(xh) references xsjbxxb(xh);已存在的表 alter table stu add foreign key(xh) references xsjbxxb(xh);删除外键约束 alter table stu drop foreign key 外键名; 指定外键注意点： 先有父表，再创子表。或者是当前正在创建的表，在这种情况下，子表（参照表），被参照表和参照表是同一个表，自参照完整性。 必须为父表定义主键，父表名后指定列名，这个列必须是这个表的主键或唯一键 外键中的列数据类型必须和被参照表中的主键的列数据类型一致或兼容，且含义一样 唯一性约束： 保证表中字段取值的唯一性，可以有一个或多个，使得它们的值在任何时候都是唯一的 12345建表时 xm varchar(12) not null unique; 或者 unique(xm,xh);已存在 alter table stu modify xm varchar(12) not null unique;删除唯一性约束 alter table stu drop index xm; 唯一键和主键的区别： 只能有一个主键，可以有多个唯一键 主键不能null,唯一键可以，但必须有null声明，且只能有一个 索引不同 非空约束： 123xm varchar(20) not null;alter stu modify sex varchar(20) not null;删除 alter table stu modify sex varchar(20); 检查约束： 添加数据时会判断是否满足约束条件 123456sex char(1) not null check(sex in(&#x27;男&#x27;,&#x27;女&#x27;))列级约束（只一个check时）birth date not null,check(birth&gt;&#x27;1990-1-1&#x27;)表级约束，大于等于一个checkalter table stu add check(sex in(&#x27;男&#x27;,&#x27;女&#x27;));alter table stu drop check sex; 默认值约束： 没赋值给的默认值 1234sex varchar(2) default &#x27;男&#x27;alter table stu modify sex varchar(2) default &#x27;男&#x27;;alter table stu modify sex varchar(2); group by: 用于将查询结果按指定的列进行排序 asc|desc 升序|降序 limit: 用于限制查询的行数，其中offset为偏移量，从0开始 into: 保存查询结果到哪 查询 1234指定字段（列） select xm, xh from stu;去掉重复值 select distinct xh from stu;表达式查询 select xm, year(now() - year(csrq)) from stu where xb = &#x27;女&#x27;;岁数，单独的一列，year(now() - year(csrq))查询指定记录 where 123in:判断某个字段的值是否在指定的集合中\tselect xh,kcdm,cj from stu where kcdm in(&#x27;01&#x27;,&#x27;20&#x27;);查询课程代码为01/02的学生选课信息select xh,kcdm,cj from stu where cj between 80 and 90; like 模糊查询 12345678910mysql不区分大小写，要区分大小写时需要更换字符集的校对规则% ：0个或多个字符_ ：单个字符like&#x27;ab%&#x27;以ab开头的任意字符串like&#x27;%ab&#x27;以ab结束…………………………like &#x27;%ab%&#x27;包含ab…………………………like &#x27;_ab&#x27;以ab结束的三个字符的字符串使用转义字符要加escapeselect xm, xh from stu where xm like &#x27;%@_%&#x27; escape &#x27;@&#x27;;查为空的 where xh is null; 设置别名 希望查询结果中的列显示时使用自己选择的列标题，as子句 1select csrq as 出生日期,xh as 学号 from stu; 聚合函数查询 1234count() 统计满足条件的记录数\tselect count(*)as 学生人数 from stu;查询记录总数 *（非null）/ all/ distinct(去除重复值)select sum(cj) as 总成绩 from stu where xh=&#x27;2001&#x27;;avg、 max、 min同理 group by分组查询 需要按某列数据的值进行分组，在分组的基础上再进行查询 12345select xb as 性别,count(*) as 人数 from stu group by xb;按男女的人数统计总的 select xb as 性别,count(*) as 人数 from stu group by xb with rollup;每个分类的汇总值having 根据条件对已分组结果进行筛选过滤执行顺序where-&gt; group by-&gt; 聚合函数-&gt; having 对所选信息进行排序 12select xb, csrq from stu where xb = &#x27;女&#x27; order by csrq desc;限制所选行数 直接在末尾加 limit 3 / limit 3,4 从3开始4行 从0开始 多表查询： 内连接： 只需返回满足连接条件的数据行。两个表在进行连接时，连接字段的名称可以不相同，但必须有相同的数据类型、长度和精度，且标答同一范畴的意义，连接列字段一般是数据表的主键和外键。系统默认 using 子句为同系列的列命名(选择) 123select xs.xh,xm,kcmc,cj from xsjbxxb as xs join xsxkb on xs.xh=xsxkb.xh join kcdmb.kcdm=kcdmb.kcdm where xs.xh=&#x27;2001&#x27;;select xs.xh,xm,kcmc,cj from xsjbxxb as xs join xsxkb using(xh) join kcdmb using(kcdm) where xs.xh=&#x27;2001&#x27;; 外连接： 返回的结果集除包括符合条件的记录外，还会返回from子句中至少一个表中的所有行，不满足条件的数据行将显示为空值，又分左外连接、右外连接、全外连接 left join:结果集中除包括满足连接条件的行外，还包括左表中不满足条件的记录行。当左表中不满足条件的记录与右表记录进行组合时，游标相应值为null right join:同理 12左外连接select xs.xh, xm, kcdm, cj from xsjbxxb as xs left join xsxkb on xs.xh=xsxkb.xh where xs.xh=&#x27;2001&#x27;; 交叉连接： 在没有where子句的情况下，产生的表的笛卡尔积 1select 字段名 from stu cross join xsjbxxb; 自连接： 一个表的两个副本之间的内连接（自己和自己连接），为了区别，还必须对表指定不同的别名 1select xs1.sh, xs1.xm from stu as xs1, stu as xs2 where xs1.zymc=xs2.zymc and xs2.xm=&#x27;王三&#x27; and xs1.xm!=&#x27;王三&#x27;;查询与王三同一个专业的学生学号和姓名 子查询：嵌套查询 比较子查询：嵌套 带in的子查询：in(嵌套) 批量比较子查询：all（指定表达式要与子查询结果集中的每个值进行比较，只有当表达式与每个值都满足比较关系时，true）、some、any（表达式与子查询结果集中的某个值满足比较关系时，就会返回true） 12select xm from xsjbxxb where xh=some(select xh from xsxkb where cj&lt;60);select xm from xsjbxxb where csrq&lt;=all(select crsq from xsjbxxb); exist子查询：只返回一个逻辑值 1select xm from xsjbxxb where exists(select * from xsxkb where xsjbxxb.xh=xsxkb.xh); 子查询和连接查询在很多情况下可以互换： 查询语句要输出的字段来自多个表时，连接居多 输出字段来自一个表，where子句涉及另一个表，连接居多 只涉及一个表，但涉及聚合函数比较，子居多 正则表达式的模糊查询： regexp是正则表达式的缩写，但不是sql标准的一部分，可和rlike互换 ^ 匹配字符串开始字符 ^a -&gt; abc $ ………………结束字符 ing$ -&gt; string . ……任意单个字符，包括回车和换行 b.g -&gt; big * ……*之前的0个或多个字符 *c -&gt; abc、bc + ……该字符前面的字符1次或多次 p+hp -&gt; php 以hp结尾，前面至少一个p 12select xh,xm,xb from xsjbxxb where xm regexp &#x27;^张&#x27;;select xh,xm,xb from xsjbxxb where xm like &#x27;张%&#x27;; union合并结果集： 将多个select语句的返回结果组合到一个结果集中。当要检索的数据在不同的结果集中，并且不能利用一个单独的查询语句得到时 12select bjbh,bmh,bjzwmc from bjdmb where bmh=&#x27;01&#x27; union select bjbh,bmh,bjzwmc from bjdmb where bmh=&#x27;03&#x27;;查询部门号01、03的班级信息 索引：加速对数据进行检索而创建的一种分散的、物理的数据结构；根据表中一列或多列按照一定顺序建立的列值与记录行之间的对应关系表；所有数据类型都能被索引。 索引分类： 普通索引index：基本索引类型，允许在定义索引的字段插入重复值和空值 唯一索引unique：值必须唯一且允许有空值；组合索引字段值的组合必须唯一；一个表上可以有多个 主键索引primary key:取值唯一且不允许有空值；一般在建表时被创建，也可以通过修改表时添加主键索引；一张表只能有一个 全文索引fulltext:在定义索引的字段上支持值的全文查找；允许插入重复值和空值；总在整个字段上创建，不支持字段前缀索引 空间索引spatil:在空间数据类型字段上建立的索引；空间列上的索引必须时空间索引，并且仅适用于单个空间列；不能为空，不能用于主键或唯一索引 索引名称必须唯一 主键索引必须是唯一的，但唯一索引不一定是主键索引 创建主键约束可自动生成主键索引，创建唯一性约束时也会自动创建唯一索引。应保证索引满足约束条件。 创建索引键值列数：单列、复合 存储方式：hash、btree 索引原则： 并非越多越好 避免对经常更新的表创建过多的索引，对经常查询的表建立索引 经常需要排序、分组、联合操作的字段建立 不要对含有大量重复值的字段建索引 不要对数据量小的表建立索引 创建索引 12345678910create table course(\tcid varchar(6) not null, cname varchar(20) not null, credit float(3,1), semester int(1), index(cname desc));在cname上建立普通索引并降序排序alter table xsjbxxb add index index_xm(xm); index_xm时索引的名称create index index_xm_bj on xsjbxxb(xm desc, nj asc); 查看索引 123456已创建索引的情况show index from xsjbxxb;show create table xsjbxxb;索引的使用情况explain select * from xsjbxxb where 条件表达式; 删除索引 12drop index index_kcmc on kcdmb;alter table xsjbxxb drop index index_kcmc; 视图 虚拟表。是从一个或多个表及其它视图中通过select语句导出的表，其内容由查询定义派生出视图的表称为基表。视图包含一系列带有名称的字段和记录，但是只放了定义，没有放数据，浏览视图时所对应的数据行和列数据来自定义视图查询所引用的表，并且在引用视图时动态生成。 只有查询没有任何限制 优点：简化数据查询和处理、屏蔽数据库的复杂性、安全性 创建视图 在指定的数据库表上建立视图。视图可以建立在一张表上，也可以建立在多张表或已有视图上。需要权限 or replace:当已具有同名视图时，替换已有视图 alogrithm：视图算法可影响查询语句的解析方式 ​ undefined：默认，自动选择算法 ​ merge：将视图定义和查询视图时的select语句合并起来查询 ​ temptable：先将视图结果存入临时表，然后用临时表进行查询 definer:定义视图的用户与安全控制有关，默认为当前用户 ​ user|current_user sql security：用于视图的安全控制 ​ definer|invoker with (cascaded|local) check option：对于视图数据操作时的检查条件 ​ cascaded、local：决定了检查测试的范围。默认，在一个视图的基础上创建另一个视图时，进行级联检查|操作数据时满足该视图本身定义的条件即可 123create view xs_1 as select xh,xm,xb,zymc from xsjbxxb where zymc=&#x27;通信工程&#x27; with check option;create view xs_cj_avg(专业名称，平均成绩) as select zymc,avg(cj) from xsjbxxb,xsxkb where xsjbxxb.xh=xsxkb.xh group by zymc;建立一个计算每个专业平均成绩 查看视图 1234desc 视图名;show table status like &#x27;视图名&#x27;;(为null是虚表)show create view 视图名;select table_a, table_b, view_a from information_a.views where table_name=&#x27;视图名&#x27;;查看视图详细信息 修改视图 对已存在的 12create or replace view 名字 as select ……;alter view 名字 as select ……; 查询视图 1select *from xs_kc where xb=&#x27;男&#x27;; 更新视图 通过视图修改基表。不是所有视图都能更新，只有满足条件的视图才可以更新 不能更新的情况: 含聚合函数 含union&#x2F;union all&#x2F;distinct&#x2F;top&#x2F;group by&#x2F;having等关键字 定义视图的select中包含子查询 由不可更新的视图导出的视图 视图上对应的数据表上存在没有默认值且不为空的列，该列没有被包含在视图里 from子句中包含多个表 12345678910和正常插入一 insert在创建视图中使用了 with check option，所有对视图进行修改的语句必须符合这个限定条件一次插入只能作用到一个基表上更新 updateupdate xs_kc set cj=80 where xm=&#x27;张三&#x27;;删除数据 delete对视图操作，基表同时被操作当一个视图连了两个以上的基表，对数据的删除不会成功 删除视图 只删了定义，不会影响基表中的数据 1drop view xs_kc; 最好仅将视图作为虚表，不要通过视图更新数据 常量 实型常量 12.3，-56.4，12e3 整型常量 字符串常量 ‘ab #3’、”abc def “ 日期&#x2F;时间常量 ‘2010-04-02’ 布尔值 null值 表示无数据，但不同于空字符串和数字0 unicode字符前面有一个N标志符，必须为大写 N&#39;hello&#39; 变量 全局变量:系统定义，自动初始化陌生值，用户不能定义；值可以通过my.ini修改，但必须有super权限；影响整个服务器 12345678910查看所有全局变量的值 show global variables;指定显示某个全局变量的值 select @@global.变量名;设置全局变量set global var_name=value;set @@global.var_name=value;调用全局变量是，需要在名称前加上&#x27;@@&#x27;，但在系统日期、系统时间、用户名等全局变量的值设为400 set global rang_alloc_block_size=400;这里的global不能省略，否则默认为会话变量 session 会话变量:每次建立一个新连接是，由mysql服务器将当前所有全局变量复制一份给会话变量完成初始化，它只影响当前的数据连接参数；只能更改自己的 12345678设置set session var_name=value;set @@session.var_name=value;set var_name=value;查看select @@var_name;select @@session.var_name;show session variables like &quot;th%&quot;; 用户变量:必须定义和初始化，没有则为null 1set @name=&#x27;王三&#x27;; 局部变量:declare 必须定义在函数、触发器、存储过程等存储程序中，不能单独使用 1declare name char(6) default &#x27;张三&#x27;; &lt;&#x3D;&gt; 安全等于，不会返回unknown （true、false） &lt;&gt; 、!&#x3D; 不等于 least 返回最小值 greatest 返回最大值 in 判断一个值是in列表中的任意一个值 not in ………………不是……………………………… like 通配符匹配 regexp 正则表达式匹配 not ! and &amp;&amp; 有0为0 or || xor 有1为1 流程控制语句 123456789101112131415161718delimiter$$create preocedure getGrade(cj varchar(20))begin declare stu_grade float; select cj into stu_grade from xsxkb where xh=stu_no and kcdm=cour_no; if stu&gt;=90 then select stu_grade,&#x27;A&#x27;; elseif ; end if; case when stu_grade&gt;=90 then select stu_grade,&#x27;A&#x27;; end case;end $$delimiter; 1234567891011121314delimiter$$create preocedure getGrade(a int)begin declare i int default 1; loop_name: loop if i&gt;a then leave loop_name;--判断条件成立则结束循环 end if; set sum=sum+i; set i=i+1; end loop;--循环结束 select sum;end$$delimiter; 123456789declare sum int default 0;declare i int default 1; repeat --循环开始 if i&gt;a then set sum=sum+i; set i=i+1; until i&gt;a end repeat;--循环结束select sum; 1234while i&lt;=a do\tset sum=sum+i;\tset i=i+1;end while; 1234567label1:loop set p1=p1+1; if p1&lt;10 then inerate lable1; end if; leave lable1;end loop label1; 加密函数： md5() 计算字符串的md5校验和 sha() …………………安全散列算法(sha)校验和 sha2(str,hash_length) hash_length支持的值为224、256、384、512、0 自定义函数 12345create function 函数名（参数列表） returns 数据类型begin\t;return 值;end; 123456查看函数 show create function 函数名;\tshow function status;\talter function 函数名 选项;drop function 函数名; 存储过程的函数：一组经过编译并保存在数据库中sql语句的集合 ​ 允许标准组件式编程、较快的执行速度、减少网络流量、安全 存储过程的创建 12345678delimiter$$create procedure proc(out num int)begin\tselect count(*) into num from xsjbxxb;end $$delimiter;作用是将语句的结束符;修改为$$，不会出现错误proc的简单存储过程，用于获取表xsjbxxb中的记录数 存储过程的调用 12call proc(@num);select @num;--输出 查看存储过程 123456查看存储过程的状态show procedure status like &#x27;proc&#x27;;查看存储过程的定义show create procedure jwgl.proc;查看存储过程的信息select *from information_schema.routines where routine_name=&#x27;pf_name&#x27;; 修改存储过程 不能使用关键字alter更改存储过程的参数或子程序，如果需要修改，则必须删除存储过程后再重新创建 1alter procedure proc modify sql data sql security invoker;修改读写权限和安全类型 删除存储过程 1drop procedure [if exists] proc; 存储过程与函数的联系与区别： 存储过程实现的功能更复杂，函数的实现功能针对性比较强 存储过程可以返回参数，不需要返回类型；函数只能返回值或者表对象（一个） 存储过程可以使用非确定函数，不允许在用户定义函数主体中内置非确定函数 存储过程一般作为一个独立的部分来执行；函数在select后面；sql中不可以使用存储过程，但可以使用函数 在存储过程和函数中，当查询语句返回多条记录时，可以使用游标对结果集进行逐条读取 定义游标 declare 1declare youbiao cursor for select语句; 打开游标 在打开一个游标时，游标并不指向第一条记录，而是指向第一条记录的前面 1open youobiao; 使用游标 fetch 常与循环结构配合使用，用于遍历表中的所有记录 1fetch youbiao into 变量名; 将定义游标是查询出的数据赋予变量 关闭游标 1close youbiao; 例子： 创建存储过程，并显示前3名同学的xh、xm 123456789101112131415161718192021DELIMITER $$ CREATE PROCEDURE proc1() BEGIN DECLARE s_xh VARCHAR(20); DECLARE s_name VARCHAR(50); DECLARE stu CURSOR FOR SELECT xh, xm from xsjbxxb; OPEN stu; FETCH stu INTO s_xh, s_name; SELECT s_xh, s_name; FETCH stu INTO s_xh, s_name; SELECT s_xh, s_name; FETCH stu INTO s_xh, s_name; SELECT s_xh, s_name; SELECT s_xh, s_name; CLOSE stu; END $$DELIMITER; 统计xsjbxxb中age&gt;20 12345678910111213141516171819202122232425DELIMITER $$\tCREATE PROCEDURE proc2() BEGIN DECLARE total int; DECLARE id VARCHAR(20) CHARACTER SET utf8; DECLARE done INT DEFAULT 0; DECLARE cur CURSOR FOR SELECT xh FROM xsjbxxb WHERE age &gt; 20; DECLARE CONTINUE HANDLER FOR NOT found SET done = 1; 指定游标循环结束时的返回值 open cur; set total = 0; WHILE done != 1 DO FETCH cur INTO id; if done != 1 THEN SET total = total + 1; END IF; END WHILE; CLOSE cur; SELECT &quot;年龄大于20岁的有：&quot;,total,&quot;人&quot;; END $$DELIMITER ;call proc(); 触发器 与存储过程类似，也是一段程序代码。但触发器是由事件激发某个操作的（当表中出现特定事件时就会激发该对象） 是特殊存储过程，只要一个预定义的点事件发生就会被mysql自动调用 ​ 引发触发器执行的事件一般如下： 增加一条学生记录时，自动检查年龄是否符合范围要求 删除一条学生信息时，自动删除其成绩表上对应的记录 删除一条数据时，会在数据库存档表中保留一个备份副本 执行是自动的，当对触发器相关表的数据进行修改后可立即执行 触发器可以通过数据库相关的表层叠修改另外的表 触发器可以实施比外键约束、check约束更为复杂的检查和操作 与表关系密切，主要用于保护表中的数据。特别是当有多个表具有一定的相互联系时，触发器能让不同的表保持数据的一致性 insert触发器 在insert语句执行之前或之后响应的触发器（后面同理） 在insert触发器代码内，可引用一个名为new的虚拟表来访问被插入的行 …before insert………new中的值也可以被更新（可修改被插入的值（要有权限）） 对于auto_increment列，new在insert执行之前包含的值是0，在insert执行之后将包含新的自动生成值 update触发器 在update触发器代码内，可引用一个名为new的虚拟表来访问被更新的值 ……………………………………………………………old…………………………update语句执行之前的值 old中的值全是只读的 在before update触发器代码内，new中的值可能也会被更新，即允许更改将要用于update语句中的值 当触发器设计对触发表自身更新操作时，只能使用before类型的触发器，after类型 的则不被允许 delete触发器 在delete触发器代码内，可引用old的虚拟表来访问被删除的行 触发器出现错误，mysql的处理： 对于事务性表，触发程序失败，以及由此导致的整个语句失败，那么该语句所执行的所有更改将回滚；对于非事务性表，则不能执行此类回滚，即使语句失败，失败之前所作的任何更改依然有效 若before触发程序失败，则mysql将不执行相应行上的操作。若在before或after触发程序的执行过程中出现错误，则将导致调用触发程序的整个语句失败。仅当before触发程序和行操作均已被成功执行，mysql才会执行after触发程序 创建触发器 1create trigger 触发器名 before/after insert/update/delete on 表名 for each row 主体; 表名把必须是永久性表，不能把临时表或者视图和这个关联起来 同一个表不能拥有两个具有相同触发时刻和事件的触发器（不能同时有两个before insert） 主体:表示触发器的动作主体，包含激发器激活时要执行的mysql语句。如果有多个，即用begin……end复合语句结构 每个表最多支持6个触发器，每个表的每个事件每次只允许有一个触发器，即单一触发器不能与多个事件或多个表关联 before类型触发器 创建触发条件为向表tb_emp8插入数字之前，对新插入的salary字段值进行求和计算 123456create trigger Summ before insert on tb_emp8 for each row set @sum=@sum+new.salary;set @sum=0;insert into tb_emp8 values(1,&#x27;A&#x27;,1000),(2,&#x27;B&#x27;,2000);select @sum; after类型触发器 创建一个名为ds的触发器，触发条件是向表te6中插入数据后，再向te7中插入相同的数据，并且salary为te6中新插入的字段值的2倍 1create trigger ds after insert on te6 for each row insert into te7 value(new.id,new.name); 查看触发器 12345show triggers;查看某个表上的： show triggers from 数据库名 like 表名;精确查看某个触发器： show triggers where &#x27;trigger&#x27; like &#x27;名字%&#x27;;触发器的详细信息： select *from 数据库 where trigger_name=&#x27;&#x27;； 删除触发器 1drop trigger 数据库.触发器名字; 事件 调度事件：指按调度表运行的任务 创建事件时，可将其创建为命名数据库对象，其中包含在特定时间执行或定期重复的sql语句（或存储过程） 事件与触发器： 相同点： ​ 在某些事情发生时启动 不同点： ​ 事件基于特定时间周期来触发执行某些任务；触发器基于某个表所产生的事件来触发 查看事件状态 12345show variables like &#x27;event_scheduler&#x27;;select @@event_scheduler;set global event_scheduler=on/off/1/0;set @@global.event_scheduler=on/off/1/0; 创建事件 事件event_minute，设定在2022-06-01 09:40:00时每分钟向数据表ub_emp8中插入一条记录，然后创建事件，事件类型：间隔触发&#x2F;特定事件触发 12345678910DROP EVENTIF EXISTS event_minute;delimiter $$ CREATE DEFINER = &#x27;root&#x27;@&#x27;localhost&#x27; EVENT event_minue ON SCHEDULE EVERY 1 MINUTE STARTS &#x27;2022-06-01 09:40:00&#x27; ON COMPLETION NOT PRESERVE ENABLE DO BEGIN INSERT INTO tb_emp8 VALUES(3, &#x27;C&#x27;, 1000); INSERT INTO tb_emp8 VALUES(4, &#x27;D&#x27;, 1000);\tEND $$ 查看事件 1show events; 所有触发器的定义都存储在系统数据库中的information_schema的events表中 1select *from information_schema where events_name=&#x27;事件名&#x27;; 删除事件 1drop event [if exist] 事件名; 禁用事件 1alter event 事件名 disable; 开启事件 1alter event 事件名 enable; 修改事件 1alter event 事件名;"},{"title":"对拍","path":"/undefined/STL总结/","content":"STL总结1234567迭代器例子：`set&lt;int&gt;:: iterator it;for(it = x.begin(); it != x.end(); ++it) x.rbegin(); x.rend; ++ (反向迭代器)for(auto w: x) 排序： sort(v.begin(), v.end()) （包括字母）（less&lt;int&gt;() &#x2F; greater&lt;int&gt;()） vectorvector&lt;int&gt; a(n + 1);\t能先开辟先开辟，如果输入失败又可能这里出问题了 vector&lt;int&gt; b = a;\t定义的时候等于，否则可能会出问题 map默认key从小到大排序 自定义按value :sort cmp(pair&lt;int, int&gt;a, pair&lt;int, int&gt;b) return a.second &lt; b.second; 获取最大值： auto i = max_element(t.begin(), t.end(), cmp) (还有min_element) map&lt;int, set&lt;string&gt;&gt; m; word[len] = set&lt;string&gt;(); (只是创建空间， 会重置原数据) 返回出现次数：m.count(length) 可以mp.first(); mp.second(); pair先比较第一个，第一个相同再比较第二个 当想插入两个： q.push(make_pair(0, 0)); string大小转 小写：transform(s.begin(), s.end(), s.begin(),tolower) 小写转大写：toupper 有空格：getline(cin, s); s.substr(0，n): 从1开始数n个 s.reverse(s.begin(), s.end()) : 字符串翻转 12s.insert(pos, string, pos1, size_n) : 从pos1开始数的第n个字符插在pos前s.insert(pos, n, char c) : 在下标为pos前插入n个字符c (n个相同的) 1.count(begin, end, &quot;s&quot;); set去重 + 自动排序 multiset： 不去重（可以删除某个点） 123s.erase(pos) 删除pos迭代器所选元素s.erase(x.begin(), x.end()) 删除[begin, end)内所有元素s.erase(elem) 删除值为elem的元素 set.count(string s) ： set内有几个与s相同的 &#x2F;&#x2F;string同样可用 12set.count(begin, end, &quot;s&quot;);set.count(&quot;s&quot;); queue12345queue&lt;pair&lt;int, int&gt;&gt; q;q.insert(&#123;a, b&#125;);q.pop();int c = q.front().first;int d = q.front().second;"},{"title":"对拍","path":"/undefined/STL关于50条总结/","content":"STL关于50条总结（effective stl） 标准STL序列容器： vector、string、deque、list 标准STL关联容器（会按照某种排序规则插入）： set、mulitiset、map、multimap 非标准STL序列容器： slist、rope 非标准的关联容器hash_set、hase_multiset、hash_map和hash_multimap 几种标准的非STL容器，数组、bitset、valarray、stack、queue和priority_queue 序列容器支持push_front &#x2F; push_back 关联容器提供了对数时间的lower_bound、ipper_bound、equal_range 123456789连续内存容器：标准： vector、string、deque​ 非标准：rope基于节点的容器：容器内元素的插入删除只影响指向节点的指针（提供了双向迭代器）​ list、slist标准C++部分： 排除slist、rope对插入删除失败的回滚能力： 基于节点的容器deque的插入操作仅在末尾时，迭代器可能会失效，但指针和引用不会失效（特殊的） 任意位置插入： 序列容器 元素查找速度： 哈希 &gt; 排序的vector &gt; 标准关联容器 随机访问迭代器： vector、string、deque ​ 要求这个的： sort类的函数、nth_element 12345string是STL中在swap过程中会导致迭代器、指针和引用变为无效的唯一容器。STL容器是各自有优缺点的，不能混在一起用。\t有时候可能会改容器，这时候使用封装P14（暂时不想看懂）拷贝对象是STL的工作方式通过利用插入迭代器的方式来限定目标区间的copy调用，几乎全部应替换为对区间成员函数的调用 map&lt;string, vector&lt;类&gt;&gt;遍历： map&lt;string, vector&lt;类&gt; : : iterator&gt; : : const_iterator if(c.size() &#x3D;&#x3D; 0)\t&lt;&#x3D;&gt;\tif(c.empty()) (这个更优,对所有容器都为常数操作) 两个vector 使v1的内容和v2的后半部分相同的最简单操作： v1.assign(v2.begin() + v2.size() / 2, v2.end()); (copy也影响效率，不行) 对区间函数调用： v1.insert(v1.end(), v2.begin(), + v2.size() / 2, v2.end()); ​ （数组插到vector也可用） ​\tassign： 需要完全替换一个标准序列容器内容时 ​\toperator &#x3D; : 可选择的赋值函数 ？"},{"title":"dfs","path":"/undefined/DFS/","content":"DFS小技巧while(cin &gt;&gt; ch) 一般枚举所有的两种方案dfs （2^n）**&#x2F; ** 二进制(n * 2^n) 看第 i 位是不是1，可以右移 i 位再 &amp;1 看 u &gt;&gt; i &amp; 1 （要从0开始枚举） 如果需要拼接： dfs 能剪枝的就把它先剪了（在确认没错的情况下） 找区间： ret += upper_bound(a.begin(), a.end(), 3 * a[j] - 2 * a[i]) - lower_bound(a.begin(), a.end(), 2 * a[j] - a[i]);（找z） 二分也行啊，别再一个一个试了$$给出 n 根长度不一的木棍，第 i 根棍子长度为 a_i 。两根长度分别为a_b和a_c的木棍可以拼接成一根长度为a_b + a_c的木棍，同理3根,4根，甚至n根都能拼接。 问：使用这 n 根木棍作三角形的边（一根木棍至多使用一次，也可以不使用），能拼出的面积最大的三角形的面积。$$ 123456789101112double dfs(int l1, int l2, int l3, int cnt)&#123; if(cnt&gt;n) return -1;//最优性剪枝？？ if(judge(l1, l2, l3)) &#123; mx = max(mx,area(l1,l2,l3)); &#125; dfs(l1+a[cnt],l2,l3,cnt+1); dfs(l1,l2+a[cnt],l3,cnt+1); dfs(l1,l2,l3+a[cnt],cnt+1); dfs(l1,l2,l3,cnt+1); return mx;&#125; 12345678910111213141516string s = &quot;BESIGOM&quot;;\tmap&lt;char, int&gt; v;\tint ans = 0;\tfor (int i = 0; i &lt; (1 &lt;&lt; 7); ++i) &#123; for (int j = 0; j &lt; 7; ++j) v[s[j]] = i &gt;&gt; j &amp; 1;// for (auto w : v) &#123; cout &lt;&lt; w.first &lt;&lt; &quot; &quot; &lt;&lt; w.second &lt;&lt; endl; &#125; if ((v[&#x27;B&#x27;] + v[&#x27;I&#x27;]) * (v[&#x27;G&#x27;] + v[&#x27;O&#x27;] + v[&#x27;E&#x27;] + v[&#x27;S&#x27;]) * v[&#x27;M&#x27;] % 2 == 0) &#123; int temp = 1; for (int j = 0; j &lt; 7; ++j) temp *= mp[i &gt;&gt; j &amp; 1][s[j]];//组合数学 ans += temp; &#125;\t&#125; 12345678910111213141516171819202122232425最长正方形搜索， dp可做 （最好从1，1开始存） dp: 查上方，左方，左上方 f[i][j]=min(min(f[i][j-1],f[i-1][j]),f[i-1][j-1])+1 ans = max(f[i][j], ans); max说明了能取成功， f[n][m]不一定能取成功int a[105][105];int n, m, xx, yy, temp = 0;void dfs(int x, int y) &#123;\tif (!a[x][y]) return ;\tfor (int i = xx; i &lt; x; ++i) if (!a[i][y]) return ;\tfor (int i = yy; i &lt; y; ++i) if (!a[x][i]) return ;\t++temp;\tdfs(x + 1, y + 1);//直接搜下一层（）斜对角可以搜&#125;\tint ans = 0;\tfor (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (a[i][j]) &#123; temp = 0; xx = i, yy = j; dfs(i, j); ans = max(ans, temp);//是可以放出来的\t&#125;\t&#125;\t&#125; 12345678910111213141516171819202122232425262728293031323334int n, a[20];\tbool vis[20];\t//全部选择，对n升序排序// 一共tar个坑，当前枚举到第pos个坑void dfs(int pos, int tar) &#123; if (pos == tar + 1) &#123; for (int i = 1; i &lt;= tar; i ++ ) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return ; &#125; // 选数填坑，选择的数范围是1～n for (int i = 1; i &lt;= n; i ++) &#123; if (!vis[i]) &#123; vis[i] = true; a[pos] = i; dfs (pos + 1, tar); vis[i] = false; &#125;\t&#125;\t&#125; for (int i = 1; i &lt;= n; i++) dfs(1, i);//只需要小的在前，大的在后，增加条件// 当前枚举到第pos个坑， 上一个坑填的是start-1，这次只能从start开始找数填， 一共要填tar个坑void dfs(int pos, int start, int tar) &#123; if (pos == tar + 1) &#123; for (int i = 1; i &lt;= tar; i ++ ) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return ; &#125; // 选数填坑，选择的数范围是start～n for (int i = start; i &lt;= n; i ++) &#123; if (!vis[i]) &#123; vis[i] = true; a[pos] = i; dfs (pos + 1, i + 1, tar); vis[i] = false; &#125;\t&#125;\t&#125; for (int i = 1; i &lt;= n; i ++ )\tdfs(1, 1, i); 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#define x first\t#define y second\tusing namespace std;typedef pair&lt;int, int&gt; PII;\tconst int N = 55; //acwing奶牛选美int n, m;\tchar g[N][N];\tvector&lt;PII&gt; points[2];int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;//记住这种void dfs(int x, int y, vector&lt;PII&gt;&amp; ps)&#123;\tg[x][y] = &#x27;.&#x27;; ps.push_back(&#123;x, y&#125;);//这样放置 for (int i = 0; i &lt; 4; i ++ )&#123; int a = x + dx[i], b = y + dy[i]; if (a &gt;= 0 &amp;&amp; a &lt; n &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; m &amp;&amp; g[a][b] == &#x27;X&#x27;)// dfs(a, b, ps);//&#125;\t&#125;int main()&#123;\tcin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i ++ ) cin &gt;&gt; g[i];//输入 for (int i = 0, k = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; m; j ++ ) if (g[i][j] == &#x27;X&#x27;) dfs(i, j, points[k ++ ]);//求连通块的精妙之处，在dfs中早已处理好了这块 int res = 1e8; for (auto&amp; a: points[0]) for (auto&amp; b: points[1]) res = min(res, abs(a.x - b.x) + abs(a.y - b.y) - 1); return 0;&#125; 星空之夜🔗 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960char g[105][105];int m, n;\tint top;const double eps = 1e-6;\tpair&lt;int, int&gt; q[105 * 105];inline double dis(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) &#123;\tdouble dx = a.first - b.first;\tdouble dy = a.second - b.second;\treturn sqrt(dx * dx + dy * dy);&#125;double get_sum() &#123;//利用两两之间的距离hash映射\tdouble sum = 0;\tfor (int i = 0; i &lt; top; ++i) &#123; for (int j = i + 1; j &lt; top; ++j) &#123; sum += dis(q[i], q[j]); &#125;\t&#125;\treturn sum;&#125;char get_tu(double key) &#123;\tstatic double tu[30];\tstatic int id = 0;\tfor (int i = 0; i &lt; id; ++i) &#123; if (fabs(tu[i] - key) &lt; eps) return i + &#x27;a&#x27;;\t&#125;\ttu[id++] = key;\treturn id + &#x27;a&#x27; - 1;&#125;void dfs(int x, int y) &#123;\tq[top++] = &#123;x, y&#125;;\tg[x][y] = &#x27;0&#x27;;\tfor (int i = x - 1; i &lt;= x + 1; ++i) &#123; for (int j = y - 1; j &lt;= y + 1; ++j) &#123; if (i == x &amp;&amp; j == y) continue; if (i &gt;= 0 &amp;&amp; i &lt; n &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; m &amp;&amp; g[i][j] == &#x27;1&#x27;) dfs(i, j); &#125;\t&#125;&#125;int main() &#123;\tIOS\tcin &gt;&gt; m &gt;&gt; n;\tfor (int i = 0; i &lt; n; ++i) cin &gt;&gt; g[i];\tfor (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123;//连通块 if (g[i][j] == &#x27;1&#x27;) &#123; top = 0; dfs(i, j); char c = get_tu(get_sum()); for (int k = 0; k &lt; top; ++k) &#123; g[q[k].first][q[k].second] = c; &#125; &#125; &#125;\t&#125;\tfor (int i = 0; i &lt; n; ++i) cout &lt;&lt; g[i] &lt;&lt; endl;\treturn 0;&#125;"},{"title":"刷题1","path":"/undefined/关于题目/","content":"小红和紫准备玩一个游戏。她们拿到了一个只包含小写字母的字符串 s。两人轮流将一个小写字母添加到一个新串t的结尾，必须保证t时刻都是s的一个子序列。谁先无法操作则输掉游戏。t初始是一个空串。小红先手添加，假设两人都足够聪明，请问谁最终能获得胜利？ 🔗 123456789101112131415161718\tint i,j=s.length()-1; for(i=j-1;i &gt;= 0;i--)&#123;//注意i大于等于0 if(s[i]==s[j])j=i-1,i=j;\t&#125; if(j==-1)cout&lt;&lt;&quot;yukari&quot;; else cout&lt;&lt;&quot;kou&quot;;最后一个&#x27;b&#x27;，谁的 t 串添加到这里谁就赢了。那么字符串标记为afnabasfoa[b]afnabasfoa[b]。其中中括号为必胜区间。//ab cabc 取了b，无论选cab中的谁都没办法结束 是要赢只能选那个必胜区间，否则根本没法那么，这个 b 到上一个 b 之间所有的字母都是必败的。因为如果某人“不小心”取到了这些字母中的任意一个，对方只要在后面加一个 &#x27;b&#x27; ，就直接到了最后一个 b 了。因此，第五个字母 &#x27;b&#x27; 后面这些字母都是必败的。字符串标记为 afna(basfoa)[b]afna(basfoa)[b]。其中小括号为必败区间。那么第四个字母&#x27;a&#x27;就是必胜的，因为只要某人取到了这个 a ，对方就不得不取后面的小括号区间的某个字母，导致失败。以此类推，字符串可以标记为 (afn)[a](basfoa)[b](afn)[a](basfoa)[b]。标记的逻辑是：最后一个字母 chrchr 为必胜，那么找到它前面离它最近的那个 chrchr ，这段区间为必败。必败区间前面的那个字母为必胜，以此类推，标记出所有区间。那么怎么评定胜负的标准呢？很简单，若第一个字母在必败区间，那么小红必败。否则小红必胜，因为小红可以直接取到第一个必败区间前面的那一个字母，迫使紫m去取必败区间。 如果要求每次添加的时候t都是s的子串，解法是后缀自动机next指针dag图上求sg函数 炸鸡块君和同学们一共n个人去学校附近玩耍，先让m个人带校园卡进入学校，再派一个人带着所有m张校园卡出来，重复上述过程，直到所有人进入学校。 假设从外面进入学校和从校内出来到校外都需要花费一个单位的时间，求所有人都进入学校最少需要花费几个单位的时间。🔗 123456789 if(n &gt; 1 &amp;&amp; m == 1) &#123; cout &lt;&lt; -1 &lt;&lt; endl; continue;\t&#125; if(n &lt;= m)&#123; cout &lt;&lt; 1 &lt;&lt; endl; continue;\t&#125; ans = ceil(((double)(n - 1)) / (m-1));//之所以不是n/m-1 例如5 2 =&gt; 7 //必须往大了的去取整，时间毕竟是个整数，具体还是看要求 cout &lt;&lt; ans * 2 - 1 &lt;&lt; endl;就去硬模拟，不对一定有不对的地方，先改ll， 奇数奇数 奇数偶数 偶数奇数 奇数偶数 这样去试 逆洗牌🔗 123456for (int i = 1; i &lt;= n; ++i) &#123;\tcin &gt;&gt; tem; mp[tem] = i;\t&#125;//string temp;for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; s[i]; for (int i = 1; i &lt;= n; ++i) t[mp[mp[mp[i]]]] = s[i];//for (int i = 1; i &lt;= n; ++i)\tcout &lt;&lt; t[i] &lt;&lt; endl; 一定要抽象问题！！！状压dp: https://ac.nowcoder.com/acm/contest/11230/F 贪心： https://ac.nowcoder.com/acm/contest/11230/E 定理：当且仅当一个数组a1,a2,…,an满足以下两个约束条件时，它可以通过一连串的操作被完全删除。 n是偶数 数组中任何元素的最大频率最多为n&#x2F;2。 本题需要取模，而期望值并不一定是整数，所以要用到逆元和快速幂"},{"title":"对拍","path":"/undefined/对拍/","content":"只需要四个cpp文件生成的数据、对拍文件、你写的、暴力的绝对正解（按图的顺序）这个的输出格式就是你造数据的格式，对比的也是结果的文本，记得全部编译一次。 rand()：随机数； % 10 是为了取[0， 10）之间的数据，后面如果加减同理是为了得到区间里的数第7行是为了避免相同的数据这里这些是名字，名字改了就行直接点运行，运行那个duipai.cpp就可以了进阶后面再写本来是想在蓝桥杯用，似乎学校的两个编译器都不支持。"}]