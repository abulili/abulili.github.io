[{"title":"Hello World","path":"/undefined/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"linee","path":"/undefined/linee/","content":"线段是否相交123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;template&lt;class T&gt; bool judge2(T a, T b, T c, T d)&#123; if(max(a.first , b.first) &gt;= min(c.first, d.first) &amp;&amp; max(c.first, d.first) &gt;= min(a.first, b.first) &amp;&amp; max(a.second, b.second) &gt;= min(c.second, d.second) &amp;&amp; max(c.second, d.second) &gt;= min(a.second, b.second)) return true; return false; &#125;template&lt;class T&gt; bool judge1(T a, T b, T c, T d)&#123;//跨立实验 if(!judge2(a, b, c, d)) return false; double d1 = (a.first - c.first) * (d.second - c.second) - (d.first - c.first) * (a.second - c.second); double d2 = (d.first - c.first) * (b.second - c.second) - (b.first - c.first) * (d.second - c.second); double d3 = (c.first - a.first) * (b.second - a.second) - (b.first - a.first) * (c.second - a.second); double d4 = (b.first - a.first) * (d.second - a.second) - (d.first - a.first) * (b.second - a.second); if(d3 * d4 &gt;= 0 &amp;&amp; d1 * d2 &gt;= 0) return true; else return false;&#125;//一般做题是先快速排斥， 后跨立int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; pair&lt;double, double&gt; p[4]; cin &gt;&gt; p[0].first &gt;&gt; p[0].second &gt;&gt; p[1].first &gt;&gt; p[1].second &gt;&gt; p[2].first &gt;&gt; p[2].second &gt;&gt; p[3].first &gt;&gt; p[3].second; if (judge1(p[0], p[1], p[2], p[3])) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; return 0;&#125; 线段相交是否规范（只能过90%数据，先占个位） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//#include&lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;vector&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;climits&gt;#define IOS ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL);using namespace std;const int maxx = 1e4 + 5;const int maxn = 1e6 + 5;#define N 10000100#define ll long long#define endl &#x27; &#x27;const ll mod = 998244353;#define test printf(&quot;-------------------------- &quot;);#define re(a) memset((a), 0, sizeof((a)))#define remax(a) memset((a), 0x3f3f3f3f, sizeof((a)))#define PII pair&lt;int, int&gt;const double pi=acos(-1.0);inline int llog(int n)&#123; return 31 - __builtin_clz(n);&#125; //取对数// struct cmp&#123;// friend bool operator &gt; (const struct scoree &amp;a, const struct scoree &amp;b)&#123;// return a.score &gt; b.score;// &#125;// &#125;;template&lt;class T&gt; bool judge2(T a, T b, T c, T d)&#123; if(max(a.first , b.first) &gt;= min(c.first, d.first) &amp;&amp; max(c.first, d.first) &gt;= min(a.first, b.first) &amp;&amp; max(a.second, b.second) &gt;= min(c.second, d.second) &amp;&amp; max(c.second, d.second) &gt;= min(a.second, b.second)) return true; return false;&#125;template&lt;class T&gt; bool judge1(T a, T b, T c, T d)&#123; if(!judge2(a, b, c, d))&#123; return 0; &#125; double d1 = (a.first - c.first) * (d.second - c.second) - (d.first - c.first) * (a.second - c.second); double d2 = (d.first - c.first) * (b.second - c.second) - (b.first - c.first) * (d.second - c.second); double d3 = (c.first - a.first) * (b.second - a.second) - (b.first - a.first) * (c.second - a.second); double d4 = (b.first - a.first) * (d.second - a.second) - (d.first - a.first) * (b.second - a.second); if(d3 * d4 &gt;= 0 &amp;&amp; d1 * d2 &gt;= 0)&#123; return true; &#125; else return false;&#125;bool judge3(PII a, PII b, PII c, PII d) &#123; if((b.first - a.first) * (c.first - d.first) + (b.second - a.second) * (d.second - c.second) == 0) &#123; return true; &#125; return false;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; pair&lt;double, double&gt; p[4]; cin &gt;&gt; p[0].first &gt;&gt; p[0].second &gt;&gt; p[1].first &gt;&gt; p[1].second &gt;&gt; p[2].first &gt;&gt; p[2].second &gt;&gt; p[3].first &gt;&gt; p[3].second; if(judge1(p[0], p[1], p[2], p[3]))&#123; if(judge3(p[0], p[1], p[2], p[3])) cout &lt;&lt; 1 &lt;&lt; endl; else cout &lt;&lt; 2 &lt;&lt; endl; &#125; else cout &lt;&lt; 0 &lt;&lt; endl; &#125; return 0;&#125;"}]