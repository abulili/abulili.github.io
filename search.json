[{"title":"vue3源码解析（1）","path":"/undefined/vue3源码解析（1）/","content":"之前学习源码，包括设计模式都是囫囵吞枣，看是看了，也看完了，没理解也没记住，不想再白看了。 阅读源码的方法：异曲同工 https://zhuanlan.zhihu.com/p/492178169 https://blog.csdn.net/ma_nong33/article/details/128923602 (跟尤雨溪一起解读Vue3源码【中英字幕】- Vue Mastery)[https://www.bilibili.com/video/BV1rC4y187Vw/?spm_id_from=333.337.search-card.all.click&amp;vd_source=32c7f6ec6ba676c7527b509106db968a] vue.js技术揭秘：https://www.bookstack.cn/read/vue-analysis/readme.md vue3源码：https://vue3js.cn/start/ 文档：https://cn.vuejs.org/guide/introduction.html"},{"title":"1panel安装","path":"/undefined/1panel安装/","content":"安装好的1panel不能用了， 虚拟机上1panel在电脑息屏后再打开，出现连接失败，状态都对，确实找不到原因了，索性重开。记录一下，话说hexo new变成npx hexo new了，命令一直找不到😅 虚拟机安装：一直点回车 https://1panel.cn/docs/installation/online_installation/ 我知道为什么第二次一直打不开第一次的管理网址了，ifconfig查看现在的网络地址，再用这个新的虚拟地址去看，就能访问了，因为用的桥接网卡，可能每次分配的虚拟地址都不一样。"},{"title":"面试记录1","path":"/undefined/9-29面试记录/","content":"有几个没答上来&#x2F;完整，先记一下 minix原理，代替 event事件 nextTick hash原理 keep-alive原理 设计模式，并举例 $set 其它有点忘了，记性差，忘性大… try_files $uri $uri&#x2F; &#x2F;index.html; 这句话是Nginx服务器配置中的一条指令，用于设置处理请求的策略。 $uri：这是Nginx内置的一个变量，代表当前请求的URI，不包括参数部分。例如，如果请求的URL是http://example.com/user?id=1，那么$uri的值就是/user。 $uri/：尝试将请求作为目录处理，如果这个目录存在，Nginx会试图返回该目录下的默认文件（通常是index.html或index.htm）。 /index.html：如果前面的$uri和$uri/都无法找到对应的文件或目录，那么就返回/index.html文件。 因此，try_files $uri $uri&#x2F; &#x2F;index.html; 的含义是：首先尝试按照请求的URI去寻找对应的文件，如果找不到，再尝试将请求作为目录处理，如果还是找不到，最后就返回&#x2F;index.html文件。 这对于单页应用来说非常有用，因为无论用户请求的是什么URL，服务器都会返回同一个HTML文件（即index.html），然后由前端路由来决定显示哪个页面。"},{"title":"浏览器","path":"/undefined/浏览器/","content":"从输入URL到页面加载的全过程 首先在浏览器中输入URL DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。 查找缓存：浏览器先查看浏览器缓存是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。 （本地缓存→区域记录→转发域名服务器→根域名服务器） 浏览器缓存：浏览器会记录DNS一段时间 操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的DNS查询缓存)； 路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存； ISP缓存(Internet服务提供商)：若上述均失败，继续向ISP搜索。 建立TCP连接：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接 发起HTTP请求：浏览器发起读取文件的HTTP请求，，该请求报文作为TCP三次握手的第三次数据发送给服务器 服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器 关闭TCP连接：通过四次挥手释放TCP连接 浏览器渲染：客户端（浏览器）解析HTML内容并渲染出来，浏览器接收到数据包后的解析流程为： 构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象 构建CSS规则树：生成CSS规则树（CSS Rule Tree） 构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree） 布局（Layout）：计算出每个节点在屏幕中的位置 绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。 JS引擎解析过程：调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等） 创建window对象：window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于window的属性和方法，而DOM Tree也会映射在window的doucment对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。 加载文件：完成js引擎分析它的语法与词法是否合法，如果合法进入预编译 预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为window的属性加入到window对象中，并给变量赋值为’undefined’；寻找全局函数声明，把它作为window的方法加入到window对象中，并将函数体赋值给他（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方在ES6中已经解决了，函数提升还存在。 解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在ES5非严格模式下这个变量会成为window的一个属性，也就是成为全局变量。string、int这样的值就是直接把值放在变量的存储空间里，object对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。JS作用域其实就是这样的执行流机制实现的。 传送门 ☞ # DNS域名解析过程 ☞# 浏览器的工作原理 在浏览器中输入URL到显示页面经历哪些过程，涉及到哪些协议？浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。 得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议。http生成一个get请求报文，将该报文传给TCP层处理，所以还会用到TCP协议。如果采用https还会使用https协议先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要直到目的IP地址的物理地址，需要ARP协议。 其中： 1、DNS协议，http协议，https协议属于应用层 应用层是体系结构中的最高层。应用层确定进程之间通信的性质以满足用户的需要。这里的进程就是指正在运行的程序。应用层不仅要提供应用进程所需要的信息交换和远地操作，而且还要作为互相作用的应用进程的用户代理，来完成一些为进行语义上有意义的信息交换所必须的功能。应用层直接为用户的应用进程提供服务。 2、TCP/UDP属于传输层 传输层的任务就是负责主机中两个进程之间的通信。因特网的传输层可使用两种不同协议：即面向连接的传输控制协议TCP，和无连接的用户数据报协议UDP。面向连接的服务能够提供可靠的交付，但无连接服务则不保证提供可靠的交付，它只是“尽最大努力交付”。这两种服务方式都很有用，备有其优缺点。在分组交换网内的各个交换结点机都没有传输层。 3、IP协议，ARP协议属于网络层 网络层负责为分组交换网上的不同主机提供通信。在发送数据时，网络层将运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP&#x2F;IP体系中，分组也叫作IP数据报，或简称为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够交付到目的主机。 4、数据链路层 当发送数据时，数据链路层的任务是将在网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送以帧为单位的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制、以及流量控制信息等）。控制信息使接收端能够知道—个帧从哪个比特开始和到哪个比特结束。控制信息还使接收端能够检测到所收到的帧中有无差错。 5、物理层 物理层的任务就是透明地传送比特流。在物理层上所传数据的单位是比特。传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆等，并不在物理层之内而是在物理层的下面。因此也有人把物理媒体当做第0层。 浏览器的主要功能 发请求，展资源 浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示选择的网络资源。 这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。 浏览器的工作原理，它是怎样的过程？渲染引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。 然后进行如下所示的基本流程： 图：渲染引擎的基本流程。 渲染引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：渲染树。 渲染树包含多个带有视觉属性（如颜色和03尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。 渲染树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 渲染引擎会遍历渲染树，由用户界面后端层将每个节点绘制出来。 需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，渲染引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建、呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示出来。 浏览器的主要组成部分是什么？ 用户界面 - 包括地址栏、前进&#x2F;后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。 浏览器引擎 - 在用户界面和呈现引擎之间传送指令。 呈现引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。 网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。 用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。 JavaScript 解释器。用于解析和执行 JavaScript 代码。 数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。 图：浏览器的主要组件。 值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。 浏览器是如何渲染UI的？ html转成dom树 css转化style，计算dom样式 生成布局树 分层，生成分层树（将元素分成多个图层，这些图层可以单独绘制和合成，以提高渲染性能） 主线程给每个图层生成绘制列表，交给合成线程处理（绘制列表包含了需要绘制的元素和绘制的顺序。） 合成线程将图层分块（这些小块可以独立进行处理，以提高合成的效率） 合成线程在光栅化线程池中将图块转成位图（合成线程将图块转换为位图） 合成线程发送绘制图块的命令drawquad给浏览器进程 浏览器根据命令调用GPU绘制，遍历布局树的节点，并将元素显示在显示器上 光栅化是指将矢量图形（如矢量图、矢量字体等）转换成位图（像素图）的过程。 光栅化线程池的好处是能够并行处理多个图块的光栅化过程，充分利用多核处理器的优势，提高渲染效率。这样，浏览器可以更快地将页面渲染出来，从而提高用户体验。 drawquad命令告诉浏览器渲染引擎绘制一个四边形，并指定该四边形的位置、大小、纹理等属性。每个drawquad命令对应着一个页面元素或图块，通过这些命令，渲染引擎能够将页面上的所有元素逐个绘制到屏幕上，形成最终的用户界面。 说说浏览器渲染页面的过程首先输入一个网址，浏览器会向服务器发起DNS请求，得到对应的IP地址（会被缓存一段时间，后续访问就不用再去向服务器查询）。 之后会进行TCP三次握手与服务器建立连接，连接建立后，浏览器会代表用户发送一个初始的GET请求，通常是请求一个HTML文件。服务器收到对应请求后 ，会根据相关的响应头和HTML内容进行回复。 一旦浏览器拿到了数据，就会开始解析信息，这个过程中，浏览器会根据HTML文件去构建DOM树，当遇到一些阻塞资源时（如同步加载的script标签）会去加载阻塞资源而停止当前DOM树构建（所以能够异步的或延迟加载的就尽量异步或延迟，同时页面的脚本还是越少越好）。 在构建DOM树时，浏览器的主线程被占据着，不过浏览器的预加载扫描器会去请求高优先级的资源（如css、js、字体），预加载扫描器很好的优化了阻塞问题。 接下来浏览器会处理CSS生成CSS DOM树，将CSS规则转换为可以理解和使用的样式映射，这个过程非常快（通常小于一次DNS查询所需时间）。 有了DOM树和CSS DOM树，浏览器会将其组合生成一个Render树，计算样式或渲染树会从DOM的根节点开始构建，遍历每一个可见节点（将相关样式匹配到每一个可见节点，并根据CSS级联去的每个节点的计算样式）。 接下来开始布局，该过程（依旧是从根节点开始）会确定所有节点的宽高和位置，最后通过渲染器将其在页面上绘制。 绘制完成了，并不代表交互也都生效了，因为主线程可能还无法抽出时间去处理滚动、触摸等交互，要等到js加载完成，同时主线程空闲了整个页面才是正常可用的状态。 DOM Tree是如何构建的？ 转码: 浏览器将接收到的二进制数据按照指定编码格式转化为HTML字符串 生成Tokens: 之后开始parser（解析），浏览器会将HTML字符串解析成Tokens Token 是编译原理里的一个术语，它表示最小的有意义的单元。 http://blog.dzliving.com/pages/cdde14/ 构建Nodes: 对Node添加特定的属性，通过指针确定 Node 的父、子、兄弟关系和所属 treeScope Node又组合TreeScope，TreeScope标明当前Node结点是属于哪个document的（一个页面可能会嵌入iframe） html的继承关系 https://blog.csdn.net/u011001084/article/details/72637981 生成DOM Tree: 通过node包含的指针确定的关系构建出DOMTree 浏览器重绘与重排的区别？ p &gt; h 重绘(Repaint): 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变 重排/回流（Reflow）：当DOM的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。 当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分 重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，一般我们宁可选择代价更小的重绘。 『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。 如何触发重排和重绘？ dom、动画、样式、用户行为 任何改变用来构建渲染树的信息都会导致一次重排或重绘： 添加、删除、更新DOM节点 通过display: none隐藏一个DOM节点-触发重排和重绘（整消失了所以重新排列绘画） 通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化 移动或者给页面中的DOM节点添加动画（下7） 添加一个样式表，调整样式属性 用户行为，例如调整窗口大小，改变字号，或者滚动。 如何避免重绘或者重排？ 样式、DOM、布局、图层 集中改变样式 不要把 DOM 结点的属性值放在循环里当成循环里的变量，documentfragment 一次性创建。 HTML 使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的，因为脱离了文档流 不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。 避免设置多层内联样式，避免节点层级过多 避免使用css表达式 动画开始GPU加速，利用 css 属性 transform 、will-change 等,translate使用3D变化,不会触发重排或重绘，transform 使浏览器为元素创建⼀个 GPU 图层，这使得动画元素在一个独立的层中进行渲染。 提升为合成层 ​\t合成就是将页面的各个部分分成多个层、单独光栅化（浏览器根据文档的结构、每个元素的样式、页面的几何形状和绘制顺序转换为屏幕上的像素的过程）它们并在合成器线程中合成为一个页面的技术。https://zhuanlan.zhihu.com/p/451219118 将频繁重绘或回流的节点设置为图层，图层能够阻止该节点的渲染行为影响到别的节点（例：will-change \\ video \\ iframe等标签），浏览器会自动将该节点变为图层 将元素提升为合成层有以下优点： 合成层的位图，会交由 GPU 合成，比 CPU 处理要快 当需要重绘时，只需要 repaint 本身，不会影响到其他的层 对于 transform 和 opacity 效果，不会触发 layout 和 paint 提升合成层的最好方式是使用 CSS 的 will-change 属性： 123#target &#123; will-change: transform;&#125; 关于合成层的详解请移步无线性能优化：Composite 性能优化(用户打开页面很慢) 代码层面： 防抖和节流（resize，scroll，input）。 减少回流（重排）和重绘。 事件委托 css 放最上，js 脚本放最底部。 减少 DOM 操作。 按需加载，比如 React 中使用 React.lazy 和 React.Suspense ，通常需要与 webpack 中的 splitChunks 配合。 构建方面： 压缩代码文件，在 webpack 中使用 terser-webpack-plugin 压缩 Javascript 代码；使用 css-minimizer-webpack-plugin 压缩 CSS 代码；使用 html-webpack-plugin 压缩 html 代码。 开启 gzip 压缩，webpack 中使用 compression-webpack-plugin ，node 作为服务器也要开启，使用 compression。 常用的第三方库使用 CDN 服务，在 webpack 中我们要配置 externals，将比如 React， Vue 这种包不打倒最终生成的文件中。而是采用 CDN 服务。 (CDN是构建在数据网络上的一种分布式的内容分发网。CDN的作用是采用流媒体服务器集群技术，克服单机系统输出带宽及并发能力不足的缺点，可极大提升系统支持的并发流数目，减少或避免单点失效带来的不良影响。) 其它： 使用 http2。因为解析速度快，头部压缩，多路复用，服务器推送静态资源。 使用服务端渲染。 图片压缩。 使用 http 缓存，比如服务端的响应中添加 Cache-Control / Expires 。 下面列举常见的加载阶段性能优化方法，这些优化方法都是根据“尽可能少”、“尽可能早”的原则实现的优化手段。 1. 减少需要请求的资源尺寸：资源压缩、删除冗余代码和其他资源，或者使用尺寸更小的资源 代码压缩，包括js&#x2F;css&#x2F;html都应该压缩。 服务器开启gzip。 iconfont代替图片。 使用webp图片，在质量相同的情况下，WebP 格式图像的体积要比 JPEG 格式图像小 40%。 删除无用代码（摇树js和css、删除console.log）。 模块按需加载（antd、lodash、moment等常用的第三方库，不用的模块不打包进项目） 2. 减少请求数量 合并请求，由于每次请求时候，实际传输的内容只占整个请求过程的较少一部分时间，因此合并内容让多个请求变成一个可以节约请求中建立连接、排队等待等耗时。 雪碧图，图片合成，避免每个图片都要发一次请求。 内联较小的js css、图片（转成base64）等资源，避免再发一次请求获取资源。 3. 缓存 使用强缓存，文件名加hash后缀，这样只要文件内容不变，就会读缓存内容。 文件分包，更好地利用缓存，不常改变的资源分离出来。 使用cdn，注意要避免html被cdn缓存，可以在cdn服务配置不缓存html资源，也可以把html部署在自己的服务器。 4. 并行请求 域名打散（针对http1）。 使用http2。（当然http2还有二进制等好处）。 5. 按需加载 图片按需加载，只下载可视区附近的图片。 组件懒加载，路由懒加载，其实路由懒加载本质也是组件懒加载。 其他资源懒加载，避免由于模块引用关系不当，导致首屏页面加载了首屏用不到的CSS、字体图标、图片等资源。 6. 预加载可以通过或者提前加载资源或者连接 本页面资源预处理，用于加载资源之前做一些预处理，增加资源加载速度 浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图： 先对浏览器缓存发起第一次http请求，没有则告知浏览器；浏览器向服务器发起http请求，服务器返回请求结果和缓存规则；浏览器把这些存入浏览器缓存中。 由上图我们可以知道： 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中 以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。为了方便理解，这里根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强制缓存和协商缓存。 强制缓存（向浏览器） 强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 Expires 和 Cache-Control，其中Cache-Control优先级 &gt; Expires。 强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下： 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果 协商缓存（向服务器） 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since 和 Etag / If-None-Match，其中Etag &#x2F; If-None-Match的优先级 &gt; Last-Modified &#x2F; If-Modified-Since。协商缓存主要有以下两种情况： 协商缓存生效，返回304 协商缓存失效，返回200和请求结果结果 传送门 ☞ # 彻底理解浏览器的缓存机制 介绍下304过程（如果网页自上次请求后没有更新，则用304代码告诉搜索引擎，可节省带宽和开销。） a. 浏览器请求资源时首先命中资源的Expires 和 Cache-Control，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过Cache-control: max-age指定最大生命周期，状态仍然返回200，但不会请求数据，在浏览器中能明显看到from cache字样。 b. 强缓存失效，进入协商缓存阶段，首先验证ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据客户端上送的If-None-Match值来判断是否命中缓存。 c. 协商缓存Last-Modify&#x2F;If-Modify-Since阶段，客户端第一次请求资源时，服务服返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间。再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。 If-Modify-Since：标准的HTTP请求头标签,在发送HTTP请求时,把浏览器端缓存页面的最后修改时间一起发到服务器去,服务器会把这个时间与服务器上实际文件的最后修改时间进行比较 Cookie、sessionStorage、localStorage 的区别相同点： 存储在客户端 不同点： cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+ cookie设置的过期时间之前一直有效；sessionStorage数据在当前浏览器窗口关闭后自动删除；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据 cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地 浏览器的存储有哪些及它们间的区别 cookie session storage local storage indexedDB:用于客户端存储大量的结构化数据（文件&#x2F;二进制大型对象（blobs））。该API使用索引实现对数据的高性能搜索。 cache storage：用于对Cache对象的存储。 进程、线程和协程 协程 &lt; 线程 &lt; 进程 进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程没有统一的标准定义。进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。 线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。 协程，英文Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。 进程和线程的区别与联系 【区别】： 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位； 并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行； 拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。 系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。 【联系】： 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程； 资源分配给进程，同一进程的所有线程共享该进程的所有资源； 处理机分给线程，即真正在处理机上运行的是线程； 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。 传送门 ☞ # 一文搞懂进程、线程、协程及JS协程的发展☞了解更多 关于浏览器传送门 ☞# 深入了解现代 Web 浏览器 进程间的通信方式进程通信：每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。（中介） 进程间的通信方式：管道、有名管道、信号、信号量、消息队列、共享内存、socket 匿名管道( pipe )： 管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 **高级管道(popen)**：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。 有名管道 (named pipe) :有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。 消息队列( message queue ) ： 消息队列是由消息的链表存放在内核中，并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 **信号量( semophore )**： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 **信号 ( sinal )**： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两两配合使用，来实现进程间的同步和通信。 套接字( socket ) 通信： 套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。 浏览器样式兼容 统一私有或定制 一、CSS初始化每个浏览器的css默认样式不尽相同，所以最简单有效的方式就是对其进行初始化（覆盖默认样式） 常见 : *{ margin: 0; padding: 0;} 库：normalize.css 二、浏览器私有属性 常用的前缀有： firefox浏览器 ：-moz- chrome、safari ：-webkit- opera ：-o- &#x2F; -xv- IE浏览器 ：-ms-（目前只有 IE 8+支持） 三、CSS hack（条件hack、属性级hack、选择符级hack）JS垃圾回收机制项目中，如果存在大量不被释放的内存（堆&#x2F;栈&#x2F;上下文），页面性能会变得很慢。当某些代码操作不能被合理释放，就会造成内存泄漏。我们尽可能减少使用闭包，因为它会消耗内存。 浏览器垃圾回收机制&#x2F;内存回收机制: 浏览器的Javascript具有自动垃圾回收机制(GC:Garbage Collecation)，垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。 标记清除:在js中，最常用的垃圾回收机制是标记清除：当变量进入执行环境时，被标记为“进入环境”，当变量离开执行环境时，会被标记为“离开环境”。垃圾回收器会销毁那些带标记的值并回收它们所占用的内存空间。\\ 谷歌浏览器：“查找引用”，浏览器不定时去查找当前内存的引用，如果没有被占用了，浏览器会回收它；如果被占用，就不能回收。\\ IE浏览器：“引用计数法”，当前内存被占用一次，计数累加1次，移除占用就减1，减到0时，浏览器就回收它。 优化手段：内存优化 ; 手动释放：取消内存的占用即可。 （1）堆内存：fn &#x3D; null 【null：空指针对象】 （2）栈内存：把上下文中，被外部占用的堆的占用取消即可。 内存泄漏 程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果 在 JS 中，常见的内存泄露主要有 4 种,全局变量、闭包、DOM 元素的引用、定时器"},{"title":"计网","path":"/undefined/计网/","content":"HTTP 的基本概念网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。 HTTP工作原理HTTP协议定义 Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。 客户端向服务器发送一个请求报文，服务器以一个状态行来响应。 HTTP请求&#x2F;响应的步骤 连接请求加响应，释放解析整过程。 1.客户端连接到Web服务器 2.发送HTTP请求 3.服务器接受请求并返回HTTP响应 4.释放TCP连接 5.客户端（浏览器）解析HTML内容（超文本） HTTP 的 5 种方法 增删改查（资源） + 头部获取 GET—获取资源 查 POST—传输资源 增（删改） PUT—更新资源 ·改 DELETE—删除资源 删 HEAD—获取报文首部 GET与POST的区别1.浏览器回退表现不同 GET在浏览器回退时是无害的，而POST会再次提交请求2.浏览器对请求地址的处理不同 GET请求地址会被浏览器主动缓存，而POST不会，除非手动设置3.浏览器对响应的处理不同GET请求参数会被完整的保留在浏览器历史记录里，而POST中的参数不会被保留（所以回退不同）4.参数大小不同. GET请求在URL中传送的参数是有长度的限制，而POST没有限制5.安全性不同. GET参数通过URL传递，会暴露，不安全；POST放在Request Body中，相对更安全6.针对数据操作的类型不同.GET对数据进行查询，POST主要对数据进行增删改！简单说，GET是只读，POST是写。 HTTP报文的组成成分 请求报文{ 请求行、请求头、空行、请求体 } 响应报文{ 状态行、响应头、空行、响应体 } 请求行{请求方式、请求资源路径、http协议版本} （post比get多了个form data（请求体），也可以没有这个请求体） GET &#x2F;sample.com HTTP&#x2F;1.1 &#x2F;&#x2F;请求行 **Request Header:**请求头 Host: www.uuid.online/ &#x2F;&#x2F;请求的目标域名和端口号 Origin: http://localhost:8081/ &#x2F;&#x2F;请求的来源域名和端口号 （跨域请求时，浏览器会自动带上这个头信息） Referer: https://localhost:8081/link?query=xxxxx &#x2F;&#x2F;请求资源的完整URI User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;67.0.3396.99 Safari&#x2F;537.36 &#x2F;&#x2F;浏览器信息 Cookie: BAIDUID&#x3D;FA89F036:FG&#x3D;1; BD_HOME&#x3D;1; sugstore&#x3D;0 &#x2F;&#x2F;当前域名下的Cookie Accept: text&#x2F;html,image&#x2F;apng &#x2F;&#x2F;代表客户端希望接受的数据类型是html或者是png图片类型 Accept-Encoding: gzip, deflate &#x2F;&#x2F;代表客户端能支持gzip和deflate格式的压缩 Accept-Language: zh-CN,zh;q&#x3D;0.9 &#x2F;&#x2F;代表客户端可以支持语言zh-CN或者zh(值得一提的是q(0~1)是优先级权重的意思，不写默认为1，这里zh-CN是1，zh是0.9) Connection: keep-alive &#x2F;&#x2F;告诉服务器，客户端需要的tcp连接是一个长连接 **Response Header:**响应头 HTTP&#x2F;1.1 200 OK &#x2F;&#x2F; 响应状态行 Date: Mon, 30 Jul 2018 02:50:55 GMT &#x2F;&#x2F;服务端发送资源时的服务器时间 Expires: Wed, 31 Dec 1969 23:59:59 GMT &#x2F;&#x2F;比较过时的一种验证缓存的方式，与浏览器（客户端）的时间比较，超过这个时间就不用缓存（不和服务器进行验证），适合版本比较稳定的网页 Cache-Control: no-cache &#x2F;&#x2F; 现在最多使用的控制缓存的方式，会和服务器进行缓存验证，具体见博文”Cache-Control“ etag: “fb8ba2f80b1d324bb997cbe188f28187-ssl-df” &#x2F;&#x2F; 一般是Nginx静态服务器发来的静态文件签名，浏览在没有“Disabled cache”情况下，接收到etag后，同一个url第二次请求就会自动带上“If-None-Match” （条件式请求首部） Last-Modified: Fri, 27 Jul 2018 11:04:55 GMT &#x2F;&#x2F;是服务器发来的当前资源最后一次修改的时间，下次请求时，如果服务器上当前资源的修改时间比这个旧时间大，就返回新的资源内容 Content-Type: text&#x2F;html; charset&#x3D;utf-8 &#x2F;&#x2F;如果返回是流式的数据，我们就必须告诉浏览器这个头，不然浏览器会下载这个页面，同时告诉浏览器是utf8编码，否则可能出现乱码 Content-Encoding: gzip &#x2F;&#x2F;告诉客户端，应该采用gzip对资源进行解码 Connection: keep-alive &#x2F;&#x2F;告诉客户端服务器的tcp连接也是一个长连接 https 的基本概念 是、组成、作用 https:加密传输协议，是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。 http+ssl层&#x3D;https。 ​\ttls协议和ssl协议主要是如何建立安全连接 作用：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。 http 和 https 的区别？ 明文传输超文本，安全等级各不同。CA证书费用高，无状连接端难同。工作层与匿名也不同。 http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议，密文。 Https 协议需要 ca 证书，费用较高。 使用不同的链接方式，端口也不同，一般，http 协议的端口为 80，https 的端口为 443。 http 的连接很简单，是无状态的（无状态是指协议对于事务处理没有记忆能力,服务器不知道客户端是什么状态）。 ​ （应用层） （应用层与传输层之间） HTTPS工作在传输层和应用层之间。在传输层，它使用TLS协议提供安全传输，而在应用层，它仍然使用HTTP协议来传递数据。 https 协议的工作原理 客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤： 客户端使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。 web 服务器接收到客户端的请求之后，会将网站的证书（CA证书中包含了公钥），传输给客户端。 客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。 客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。 web 服务器通过自己的私钥解密出会话密钥。 web 服务器通过会话密钥加密与客户端之间的通信。 记忆口诀：一连二传三协商，四建五得六使用。 https 协议的优缺点 HTTPS 协议要比 http 协议安全，可防止数据在传输过程中被窃取、改变，确保数据的完整性。 https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。 https 缓存不如 http 高效，会增加数据开销。 SSL 证书也需要钱，功能越强大的证书费用越高。 SSL 证书需要绑定 IP，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。 TCP&#x2F;IP网络模型TCP&#x2F;IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。 链路层：负责封装和解封装IP报文，发送和接受ARP&#x2F;RARP报文等。 网络层：负责路由以及把分组报文发送给目标网络或主机。 传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。 应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。 先二进制传数据，再传输有地址的帧并检查看错没，根据地址来选择路由传输到指定地址，直到找到之后再借助端口与其它点建立联系，决定是否进行加密，联系好之后转换数据格式，将结果表现出来传输给用户。（其中刚好可以带入之前的知识） TCP三次握手 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次握手：服务器收到syn包并确认客户的SYN（ack&#x3D;j+1），同时也发送一个自己的SYN包（syn&#x3D;k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 1握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。 TCP协议是怎么保证有效传输的？ 1、确认和重传 2、数据校验 3、流量控制 4、拥塞控制 可靠传输就是通过TCP连接传送的数据是没有差错、不会丢失、不重复并且按序到达的。（set） TCP是通过序列号、检验和、确认应答信号、重发机制、连接管理、窗口控制、流量控制、拥塞控制一起保证TCP传输的可靠性的。 首先通过三次握手建立连接 建立连接的时候交换序列号 发送方每次发送包的时候会带上序列号 接收方收到包后检验数据是否正确，确认后发送确认的序列号给发送方 发送方没有收到确认的序列号的包，就会重写发送 可靠传输的具体实现是： 应用层的数据会被分割成TCP认为最适合发送的数据块。 序列号：TCP给发送的每一个包都进行编号，接收方对数据包进行排序，把有序数据传送给应用层，TCP的接收端会丢弃重复的数据。 检验和：TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。 确认应答：如果收到的数据报报文段的检验和没有差错，就确认收到，如果有差错，TCP就丢弃这个报文段和不确认收到此报文段。 流量控制：TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 拥塞控制：当网络拥塞时，减少数据的发送。 停止等待协议：它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 TCP（传输控制协议）是什么？ 标准回答 TCP是传输控制协议，是TCP&#x2F;IP体系中非常复杂的一个协议，属于运输层协议。与UDP协议一样用于处理应用层的数据。它和UDP一样具有复用和分用的功能。TCP的主要特点是：面向连接、单播、可靠交付、全双工通讯、面向字节流、头部开销大。 加分回答 TCP是传输控制协议，是TCP&#x2F;IP体系中非常复杂的一个协议，属于运输层协议。与UDP协议一样用于处理应用层的数据。它和UDP一样具有复用和分用的功能以及差错检测的功能。TCP的主要特点是： 面向连接。应用程序在使用TCP之前必须两端之间先建立TCP连接。当确认数据传输完成之后，必须要释放TCP连接。 单播。TCP只能有两个端点，进行点对点的传输，不支持多播和广播传输。 可靠交付。通过TCP连接传送的数据是没有差错、不会丢失、不重复并且按序到达的。 全双工通信。TCP允许连接的双方可以在任何时候发送数据，双方都有发送缓存和接收缓存。应用程序把数据给发送缓存之后就可以做其他的事情了，TCP发送缓存会在合适的时候自己把缓存中的数据发送出去。在接受的时候TCP会把数据存进接收缓存，上层应用程序会在合适的时候读取数据。也正因为是全双工通信方式，建立连接时最少需要三次信息确认，也就是三次握手，断开连接时最少需要四次信息确认，也就是所谓的四次挥手。 面向字节流。TC不像UDP每一个数据报独立传输，而是在不保留报文边界的情况下以字节流的方式进行传输，这也是长连接的由来。TCP中的“流”就是指流入到进程或从进程流出的字节序列。 头部开销大。最小20字节，最大60字节。加上TCP的可靠传输机制功能的影响，数据传输效率比UDP慢很多。 TCP 四次挥手因为tcp的半关闭（后面有个链接） 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN&#x3D;1，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。 2）服务器收到连接释放报文，发出确认报文，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号seq&#x3D;v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。 3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。 4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN&#x3D;1，ack&#x3D;u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq&#x3D;w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 5）客户端收到服务器的连接释放报文后，必须发出确认，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是seq&#x3D;u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。 6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 为什么要三次握手、四次挥手？https://www.cnblogs.com/zhengpan/p/12160597.html 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误 三次握手才可以阻止重复历史连接初始化（主要原因） 三次握手才可以同步双方的初始序列号 三次握手才可以避免资源浪费 为了建立可靠的数据传输通道 四次挥手： 保证等数据完成的被接收完再关闭连接。既然提到需要保证数据完整的传输完，那就需要保证双方都达到关闭连接的条件才能断开。 TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，从而比三次握手导致多了一次 TCP和UDP的区别 首先UDP协议和TCP协议都是运输层协议，都是为应用层程序服务，都具有复用（不同的应用层协议可以共用UDP协议和TCP协议）和分用（将数据报解析之后分发给不同的应用层程序）的功能 TCP是面向连接的，而UDP是面向无连接的。 TCP仅支持单播传输，UDP 提供了单播，多播，广播的功能。 TCP的三次握手保证了连接的可靠性; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。 UDP的头部开销比TCP的更小，数据传输速率更高，实时性更好。 1.TCP面向连接，UDP无连接 2.TCP可靠传输，UDP尽力交付 3.TCP采用全双工模式传输，UDP单工、半双工、全双工模式均可 4.TCP最小报文20字节，UDP最小报文8字节 5.TCP面向字节流，UDP面向报文 6.头部开销 具体的区别详细描述可以是： ​ UDP协议：面向无连接（不需要三次握手和四次挥手）、尽最大努力交付、面向报文（每次收发都是一整个报文段）、没有拥塞控制不可靠（只管发不管过程和结果）、支持一对一、一对多、多对一和多对多的通信方式、首部开销很小（8字节）。优点是快，没有TCP各种机制，少了很多首部信息和重复确认的过程，节省了大量的网络资源。缺点是不可靠不稳定，只管数据的发送不管过程和结果，网络不好的时候很容易造成数据丢失。又因为网络不好的时候不会影响到主机数据报的发送速率，这对很多实时的应用程序很重要，因为像语音通话、视频会议等要求源主机要以恒定的速率发送数据报，允许网络不好的时候丢失一些数据，但不允许太大的延迟，UDP很适合这种要求。 ​ TCP协议：是TCP&#x2F;IP体系中非常复杂的一个协议，面向连接（需要三次握手四次挥手）、单播（只能端对端的连接）、可靠交付（有大量的机制保护TCP连接数据的可靠性）、全双工通讯（允许双方同时发送信息，也是四次挥手的原由）、面向字节流（不保留数据报边界的情况下以字节流的方式进行传输，这也是长连接的由来。）、头部开销大（最少20字节）。优点是可靠、稳定，有确认、窗口、重传、拥塞控制机制，在数据传完之后，还会断开连接用来节约系统资源。缺点是慢，效率低，占用系统资源高，在传递数据之前要先建立连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接。在要求数据准确、对速度没有硬性要求的场景有很好的表现，比如在FTP（文件传输）、HTTP&#x2F;HTTPS（超文本传输），TCP很适合这种要求。 跨域 跨域的原理 阻止、不能、防 阻止一个域与另一个域的内容进行交互，能有效防止XSS、CSRF攻击，是指浏览器不能执行其他网站的脚本 跨域，它是由浏览器的同源策略造成的。同源策略,是浏览器对 JavaScript 实施的安全限制，只要协议、域名、端口有任何一个不同，都被当作是不同的域(所有的XMLHttpRequest 和 Fetch API 请求都需要在同一个域下进行)。同一个服务器是同一个域跨域原理，即是通过各种方式，避开浏览器的安全限制。 解决方案 最初做项目的时候，使用的是jsonp，但存在一些问题，使用get请求不安全，携带数据较小，后来也用过iframe，但只有主域相同才行，也是存在些问题，后来通过了解和学习发现使用代理和proxy代理配合起来使用比较方便，就引导后台按这种方式做下服务器配置，在开发中使用proxy，在服务器上使用nginx代理，这样开发过程中彼此都方便，效率也高；现在h5新特性还有 windows.postMessage() JSONP：ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是 返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。 步骤： 去创建一个script标签 script的src属性设置接口地址 接口参数，必须要带一个自定义函数名，要不然后台无法返回数据 通过定义函数名去接受返回的数据 12345678function doSearch() &#123; var input = document.getElementById(&#x27;input&#x27;); var inputVal = input.value; var url = &quot;https://suggest.taobao.com/sug?code=utf-8&amp;q=&quot; + inputVal + &quot;&amp;callback=getJsonp&quot;; var script = document.createElement(&#x27;script&#x27;); script.setAttribute(&#x27;src&#x27;, url); document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(script); &#125; function getJsonp(data) &#123; console.log(data); &#125; JSONP 的缺点:JSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。 document.domain设置或返回当前文档的域名 基础域名相同 子域名不同 12345你的网站是 www.example.com，你可以将 document.domain 设置为 example.com 或者 www.example.com。这使得你可以在一个子域名（比如 subdomain.example.com）下进行跨域请求，即使这个子域名实际上是不同的二级域名。需要注意的是，你只能将 document.domain 设置为你自己拥有控制权的域。如果你试图设置一个你无法控制的域，或者将 document.domain 设置为一个更短的子域名（比如 .com），那么浏览器将会抛出一个错误。var d = document.domain; // 获取当前域名 document.domain = d; // 重新设置当前域名 window.name 利用在一个浏览器窗口内，载入所有的域名都是共享一个 window.name 12345678let windowName = &quot;myWindow&quot;; let myWindow = window.open(&quot;&quot;, windowName); // 使用 myWindow 打开一个新的窗口 myWindow.document.write(&quot;&lt;p&gt;Hello World!&lt;/p&gt;&quot;);此外，window.name 也可以被用来存储一些数据。例如：window.name = &quot;myData&quot;;我们可以在其他地方通过 window.name 来获取这个数据 CORS CORS(Cross-origin resource sharing)跨域资源共享 服务器设置对CORS的支持原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求 123在CORS中，浏览器会在发起跨域请求时添加一个名为&quot;Origin&quot;的请求头，以标识原始的请求来源。服务器在接收到请求后，会检查&quot;Origin&quot;头，并根据其值来判断是否允许该请求访问资源。如果服务器允许该请求，它会返回一个包含&quot;Access-Control-Allow-Origin&quot;头的响应，并设置该头的值为原始请求的&quot;Origin&quot;头。这样，浏览器在接收到响应后就会知道该请求已经被允许访问资源。CORS只适用于简单的跨域请求，例如GET、POST、PUT和DELETE等请求方法。对于一些不安全的请求方法（如PUT和DELETE），浏览器会默认禁止跨域访问。此外，CORS也只适用于同源策略下的跨域请求，如果请求违反了同源策略，即使服务器返回了正确的CORS响应头，浏览器也会拒绝访问资源。 proxy代理 目前常用方式 window.postMessage() h5新特性 123456789101112131415允许在一个窗口（或标签页）中向另一个窗口传递信息。这种通信方式是跨源的，也就是说，两个窗口可以来自不同的域、协议或端口window.postMessage() 方法接受两个参数： data：需要传递的数据，可以是一个对象、字符串或者一个序列化的 JSON 对象。 targetOrigin：一个字符串，表示接收消息的目标窗口的源（URI）。这个字符串可以包含一个简单的通配符（*），表示接受来自所有源的消息。// 源窗口 window.postMessage(&#123; message: &#x27;Hello World!&#x27;, someData: &#x27;This is some data&#x27; &#125;, &#x27;*&#x27;); // 目标窗口 window.addEventListener(&#x27;message&#x27;, function(event) &#123; if (event.origin !== &#x27;http://example.org:8080&#x27;) return; console.log(event.data); &#125;, false); Websocket 全双工通信协议，由HTML5定义，可以在单个TCP连接上进行全双工通信。这种通信方式使得服务器和客户端之间可以实现实时交流。WebSocket在完成一次握手后，浏览器和服务器就可以创建持久性的连接，并进行双向数据传输。在WebSocket中，可以使用ws或wss的统一资源标志，其中wss表示在TLS之上的WebSocket。 提交表单有跨域问题吗 不会。默认使用form表单提交是不会跨域的,因为使用form表单提交后原来的页面无法得到响应的内容,所以浏览器认为是安全的,但是使用ajax提交是可以得到响应内容的,所以浏览器不允许它跨域 预检 但是还有复杂一点的请求，我们需要先发OPTIONS请求，a.com想请求b.com它需要发一个自定义的Headers：X-ABC和content-type，这个时候就不是简单请求了， a.com要给b.com 发一个options请求，它其实在问b.com我用post行不行，还想在Headers中带X-ABC和content-type；并不是所有的headers都发这个OPTIONS请求，因为X-ABC是自定义的，所以需要发；b.com看到OPTIONS请求，先不会返回数据，先检查自己的策略，看看能不能支持这次请求，如果支持就返回200。 OPTIONS请求返回以下报文 HTTP&#x2F;2.0 20 OKAccess-Control-Allow-Origin:https://a.comAccess-Control-Allow-Methods:POST,GET,OPTIONSAccess-Control-Allow-Headers:X-ABC,Content-Type Access-Control-Max-Age:86400 &#x2F;&#x2F; 告诉浏览器这个策略生效时间为一个小时，在一个小时之内发送类似的请求，不用在问服务端了，相当于缓存了浏览器收到了OPTIONS的返回，会在发一次，这一次才是真正的请求数据，这次headers会带上X-ABC、contentType。 整体的过程cors将请求分为2种，简单请求和复杂请求，需不需要发送OPTIONS浏览器说的算，浏览器判断是简单请求还是复杂请求，cors是非常广泛的跨域手段 这里的缺点是OPTIONS请求也是一次请求，消耗带宽，真正的请求也会延迟。 12345678- 最方便的跨域方案 **proxy代理+ Nginx** nginx是一款极其强大的web服务器，其优点就是轻量级、启动快、高并发。 跨域问题的产生是因为浏览器的同源政策造成的，但是服务器与服务器之间的数据交换是没有这个限制。 反向代理就是采用这种方式，建立一个虚拟的代理服务器来接收 internet 上的链接请求，然后转发给内部网络上的服务器，并将从服务器上得到的结果，返回给 internet 上请求链接的客户端。现在的新项目中nginx几乎是首选，我们用node或者java开发的服务通常都需要经过nginx的反向代理。- **window.postMessage()** 利用h5新特性window.postMessage() 跨域传送门 ☞ # 跨域，不可不知的基础概念 Cookie、sessionStorage、localStorage 的区别相同点： 存储在客户端 不同点： cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+ cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除 cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地 HTTP状态码及常见状态码HTTP状态码 1xx：指示信息类，表示请求已接受，继续处理 2xx：指示成功类，表示请求已成功接受 3xx：指示重定向，表示要完成请求必须进行更近一步的操作 4xx：指示客户端错误，请求有语法错误或请求无法实现 5xx：指示服务器错误，服务器未能实现合法的请求 常见状态码 200 OK：客户端请求成功 301 Moved Permanently：所请求的页面已经永久重定向至新的URL 302 Found：所请求的页面已经临时重定向至新的URL 304 Not Modified 未修改。 403 Forbidden：对请求页面的访问被禁止 404 Not Found：请求资源不存在 500 Internal Server Error：服务器发生不可预期的错误原来缓冲的文档还可以继续使用 503 Server Unavailable：请求未完成，服务器临时过载或宕机，一段时间后可恢复正常 1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码 100 - 继续 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分 101 - 切换协议 请求者已要求服务器切换协议，服务器已确认并准备切换 2xx（成功）表示成功处理了请求的状态码 200 - 成功 服务器已经成功处理了请求。通常，这表示服务器提供了请求的网页 201 - 已创建 请求成功并且服务器创建了新的资源 202 - 已接受 服务器已接受请求，但尚未处理 203 - 非授权信息 服务器已经成功处理了请求，但返回的信息可能来自另一来源 204 - 无内容 服务器成功处理了请求，但没有返回任何内容 205 - 重置内容 服务器成功处理了请求，但没有返回任何内容 3xx（重定向）表示要完成请求，需要进一步操作；通常，这些状态代码用来重定向 300 - 多种选择 针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择 301 - 永久移动 请求的网页已永久移动到新位置。服务器返回此响应（对GET或HEAD请求的响应）时，会自动将请求者转到新位置 302 - 临时移动 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求 303 - 查看其它位置 请求者应当对不同的位置使用单独的GET请求来检索响应时，服务器返回此代码 304 - 未修改 自上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页的内容 305 - 使用代理 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理 307 - 临时性重定向 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有的位置来进行以后的请求 4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理 400 - 错误请求 服务器不理解请求的语法 401 - 未授权 请求要求身份验证。对于需要登录的网页，服务器可能返回此响应 403 - 禁止 服务器拒绝请求 404 - 未找到 服务器找不到请求的网页 405 - 方法禁用 禁用请求中指定的方法 406 - 不接受 无法使用请求的内容特性响应请求的网页 407 - 需要代理授权 此状态码与401（未授权）类似，但指定请求者应当授权使用代理 408 - 请求超时 服务器等候请求时发生超时 410 - 已删除 如果请求的资源已永久删除，服务器就会返回此响应 413 - 请求实体过大 服务器无法处理请求，因为请求实体过大，超出了服务器的处理能力 414 - 请求的URI过长 请求的URI（通常为网址）过长，服务器无法处理 5xx（服务器错误）这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错 500 - 服务器内部错误 服务器遇到错误，无法完成请求 501 - 尚未实施 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码 502 - 错误网关 服务器作为网关或代理，从上游服务器无法收到无效响应 503 - 服务器不可用 服务器目前无法使用（由于超载或者停机维护）。通常，这只是暂时状态 504 - 网关超时 服务器作为网关代理，但是没有及时从上游服务器收到请求 505 - HTTP版本不受支持 服务器不支持请求中所用的HTTP协议版本 粘包问题分析与对策TCP粘包是指：发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。 粘包出现原因 简单说，在流传输中出现，UDP不会出现粘包，因为它有消息边界 消息边界（message boundary）是一个特定的分隔符，用于标识消息的结束和下一次消息的开始。这个分隔符可以是任意的字符串，通常是一对反斜杠带着换行符和回车符（ \\r）。消息边界主要用于标识由多个部分组成的连续消息。 粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包。 为了避免粘包现象，可采取以下几种措施： （1）对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令push，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满； （2）对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象； （3）由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。分包多发。 以上提到的三种措施，都有其不足之处。 （1）第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。 （2）第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。 （3）第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。 一种比较周全的对策是：接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开。实验证明这种方法是高效可行的。 客户端与服务端长连接方式 ajax 轮询实现原理：ajax 轮询指客户端每间隔一段时间向服务端发起请求，保持数据的同步。 优点：可实现基础（指间隔时间较短）的数据更新。 缺点：这种方法也只是尽量的模拟即时传输，但并非真正意义上的即时通讯，很有可能出现客户端请求时，服务端数据并未更新。或者服务端数据已更新，但客户端未发起请求。导致多次请求资源浪费，效率低下。【数据更新不及时，效率低下】 long poll 长轮询 实现原理：long poll 指的是客户端发送请求之后，如果没有数据返回，服务端会将请求挂起放入队列（不断开连接）处理其他请求，直到有数据返回给客户端。然后客户端再次发起请求，以此轮询。在 HTTP1.0 中客户端可以设置请求头 Connection:keep-alive，服务端收到该请求头之后知道这是一个长连接，在响应报文头中也添加 Connection:keep-alive。客户端收到之后表示长连接建立完成，可以继续发送其他的请求。在 HTTP1.1 中默认使用了 Connection:keep-alive 长连接。 优点：减少客户端的请求，降低无效的网络传输，保证每次请求都有数据返回，不会一直占用线程。 缺点：无法处理高并发，当客户端请求量大，请求频繁时对服务器的处理能力要求较高。服务器一直保持连接会消耗资源，需要同时维护多个线程，服务器所能承载的 TCP 连接数是有上限的，这种轮询很容易把连接数顶满。每次通讯都需要客户端发起，服务端不能主动推送。【无法处理高并发，消耗服务器资源严重，服务端不能主动推送】 iframe 长连接 实现原理：在网页上嵌入一个 iframe 标签，该标签的 src 属性指向一个长连接请求。这样服务端就可以源源不断地给客户端传输信息。保障信息实时更新。 优点：消息及时传输。 缺点：消耗服务器资源。 WebSocket 实现原理：Websocket 实现了客户端与服务端的双向通信，只需要连接一次，就可以相互传输数据，很适合实时通讯、数据实时更新等场景。 Websocket 协议与 HTTP 协议没有关系，它是一个建立在 TCP 协议上的全新协议，为了兼容 HTTP 握手规范，在握手阶段依然使用 HTTP 协议，握手完成之后，数据通过 TCP 通道进行传输。 Websoket 数据传输是通过 frame 形式，一个消息可以分成几个片段传输。这样大数据可以分成一些小片段进行传输，不用考虑由于数据量大导致标志位不够的情况。也可以边生成数据边传递消息，提高传输效率。 优点：双向通信。客户端和服务端双方都可以主动发起通讯。没有同源限制。客户端可以与任意服务端通信，不存在跨域问题。数据量轻。第一次连接时需要携带请求头，后面数据通信都不需要带请求头，减少了请求头的负荷。传输效率高。因为只需要一次连接，所以数据传输效率高。 缺点：长连接需要后端处理业务的代码更稳定，推送消息相对复杂；长连接受网络限制比较大，需要处理好重连。兼容性，WebSocket 只支持 IE10 及其以上版本。服务器长期维护长连接需要一定的成本，各个浏览器支持程度不一；成熟的 HTTP 生态下有大量的组件可以复用，WebSocket 则没有，遇到异常问题难以快速定位快速解决。【需要后端代码稳定，受网络限制大，兼容性差，维护成本高，生态圈小】 非对称加密RSA 对称加密算法又称现代加密算法。 非对称加密是计算机通信安全的基石，保证了加密数据不会被破解。 非对称加密算法需要两个密钥：公开密钥(publickey) 和私有密(privatekey) 公开密钥和私有密钥是一对 如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密。 如果用私有密钥对数据进行加密，只有用对应的公开密钥才能解密。 特点： 安全性: 算法强度复杂，安全性依赖于算法与密钥。 效率: 加密解密速度慢。 非对称性：公钥和私钥是一对，使用公钥加密的数据只能使用私钥解密，使用私钥加密的数据只能使用公钥解密。 与对称加密算法的对比： 对称加密只有一种密钥，并且是非公开的，如果要解密就得让对方知道密钥。 非对称加密有两种密钥，其中一个是公开的。 RSA应用场景： 由于RSA算法的加密解密速度要比对称算法速度慢很多，在实际应用中，数据本身的加密和解密使用对称加密算法(AES)。 用RSA算法加密并传输对称算法所需的密钥。 HTTP1、HTTP2、HTTP3HTTP&#x2F;2 相比于 HTTP&#x2F;1.1，可以说是大幅度提高了网页的性能，只需要升级到该协议就可以减少很多之前需要做的性能优化工作，虽如此但HTTP&#x2F;2并非完美的，HTTP&#x2F;3 就是为了解决 HTTP&#x2F;2 所存在的一些问题而被推出来的。 HTTP1.1 的缺陷 记忆口诀：队头阻塞高延迟，无状态阻交互，明文传输不安全，服务推送不支持。 高延迟 — 队头阻塞(Head-Of-Line Blocking) 队头阻塞是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。 针对队头阻塞的解决办法: 将同一页面的资源分散到不同域名下，提升连接上限。 合并小文件减少资源数，使用精灵图。 内联(Inlining)资源是另外一种防止发送很多小图请求的技巧，将图片的原始数据嵌入在CSS文件里面的URL里，减少网络请求次数。 减少请求数量，合并文件。 无状态特性 — 阻碍交互 无状态是指协议对于连接状态没有记忆能力。纯净的 HTTP 是没有 cookie 等机制的，每一个连接都是一个新的连接。 Header里携带的内容过大，在一定程度上增加了传输的成本。且请求响应报文里有大量字段值都是重复的。 明文传输 — 不安全性 HTTP&#x2F;1.1在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性。 不支持服务端推送 HTTP 1.1 排队问题 HTTP 1.1多个文件共用一个TCP，这样可以减少tcp握手，这样3个文件就不用握手9次了，不过这样请求文件需要排队，请求和返回都需要排队， 如果第一个文件响应慢，会阻塞后面的文件，这样就产生了对头的等待问题。 有的网站可能会有很多文件，浏览器处于对机器性能的考虑，它不可能让你无限制的发请求建连接，因为建立连接需要占用资源，浏览器不想把用户的网络资源都占用了，所以浏览器最多会建立6个tcp连接；如果有上百个文件 可能都需要排队，http2.0正在解决这个问题。 SPDY 协议与 HTTP&#x2F;2 简介1、HTTP&#x2F;2 简介HTTP&#x2F;2是现行HTTP协议（HTTP&#x2F;1.x）的替代，但它不是重写。HTTP&#x2F;2基于SPDY(提高网页加载速度和可靠性的网络协议)，专注于性能，最大的一个目标是在用户和网站间只用一个连接（connection） 。 2、HTTP&#x2F;2 新特性1、二进制传输HTTP/2传输数据量的大幅减少,主要有两个原因:以二进制方式传输和Header 压缩。我们先来介绍二进制传输,HTTP&#x2F;2 采用二进制格式传输数据，而非HTTP&#x2F;1.x 里纯文本形式的报文 ，二进制协议解析起来更高效。HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。 2、Header 压缩HTTP&#x2F;2并没有使用传统的压缩算法，而是开发了专门的”HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。 3、多路复用在 HTTP&#x2F;2 中引入了多路复用(允许多个数据流共享一个单一的物理通道)的技术。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也更容易实现全速传输。 多路复用技术被用于在一个TCP连接中同时处理多个请求和响应，从而减少了建立和关闭TCP连接的开销，并提高了网络利用率。 在SPDY中，每个流（Stream）都是一个双向的数据通道，可以在任何时候发送数据。这些流共享同一个TCP连接，但每个流都有自己的标识符和优先级。通过这种方式，SPDY可以在一个TCP连接中同时处理多个请求和响应，从而减少了延迟并提高了带宽利用率。 4、Server PushHTTP2还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。减少等待的延迟，这被称为”服务器推送“（ Server Push，也叫 Cache push） 5、提高安全性出于兼容的考虑，HTTP&#x2F;2延续了HTTP&#x2F;1的“明文”特点，可以像以前一样使用明文传输数据，不强制使用加密通信，不过格式还是二进制，只是不需要解密。 但由于HTTPS已经是大势所趋，而且主流的浏览器Chrome、Firefox等都公开宣布只支持加密的HTTP&#x2F;2，所以“事实上”的HTTP&#x2F;2是加密的。也就是说，互联网上通常所能见到的HTTP&#x2F;2都是使用”https”协议名，跑在TLS上面。HTTP&#x2F;2协议定义了两个字符串标识符：“h2”表示加密的HTTP&#x2F;2，“h2c”表示明文的HTTP&#x2F;2。 6、防止对头阻塞http1.1如果第一个文件阻塞，第二个文件也就阻塞了。 http2.0的解决，把3个请求打包成一个小块发送过去，即使第一个阻塞了，后面2个也可以回来；相当于3个文件同时请求，就看谁先回来谁后回来，阻塞的可能就后回来，对带宽的利用是最高的；但没有解决TCP的对头阻塞，如果TCP发过去的一个分包发丢了，他会重新发一次；http2.0的解决了大文件的阻塞。 一个分包请求3个文件，即使第一个阻塞了，第二个也能返回 HTTP&#x2F;2 的缺点虽然 HTTP&#x2F;2 解决了很多之前旧版本的问题，但它还是存在一个巨大的问题，主要是底层支撑的 TCP 协议造成的。HTTP&#x2F;2的缺点主要有以下几点： TCP 以及 TCP+TLS 建立连接时延时(发送端发送连接请求到接收端回复连接确认的时间间隔。这个时间间隔被称为RTT（Round Trip Time，往返时间），反映了网络连接的性能,(三次握手建立连接)) TCP 的队头阻塞并没有彻底解决 多路复用导致服务器压力上升也容易 Timeout HTTP&#x2F;3 新特性1、HTTP&#x2F;3简介Google 在推SPDY的时候就搞了个基于 UDP 协议的“QUIC”协议，让HTTP跑在QUIC上而不是TCP上。而“HTTP over QUIC”就是HTTP&#x2F;3，真正“完美”地解决了“队头阻塞”问题。 QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，接下来我们重点介绍几个QUIC新功能。 2、QUIC新功能QUIC基于UDP，而UDP是“无连接”的，根本就不需要“握手”和“挥手”，所以就比TCP来得快。此外QUIC也实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似HTTP&#x2F;2的“流”和“多路复用”，单个“流”是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。具体来说QUIC协议有以下特点： 实现了类似TCP的流量控制、传输可靠性的功能 虽然UDP不提供可靠性的传输，但QUIC在UDP的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性。 实现了快速握手功能 由于QUIC是基于UDP的，所以QUIC可以实现使用0-RTT或者1-RTT来建立连接，这意味着QUIC可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势。 集成了TLS加密功能 多路复用，彻底解决TCP中队头阻塞的问题 和TCP不同，QUIC实现了在同一物理连接上可以有多个独立的逻辑数据流。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题。 连接迁移 TCP 是按照 4 要素（客户端 IP、端口, 服务器 IP、端口）确定一个连接的。而 QUIC 则是让客户端生成一个 Connection ID （64 位）来区别不同连接。只要 Connection ID 不变，连接就不需要重新建立，即便是客户端的网络发生变化。由于迁移客户端继续使用相同的会话密钥来加密和解密数据包，QUIC 还提供了迁移客户端的自动加密验证。 http总结 HTTP&#x2F;1.1有两个主要的缺点：安全不足和性能不高。 HTTP&#x2F;2完全兼容HTTP&#x2F;1，是“更安全的HTTP、更快的HTTPS”，二进制传输、头部压缩、多路复用、服务器推送等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验； QUIC 基于 UDP 实现，是 HTTP&#x2F;3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议。 利用Socket建立网络连接的步骤建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。 套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。 1、服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。 2、客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。 为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。 3、连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。 而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。 理解xss，csrf，ddos攻击原理以及避免方式XSS(Cross-Site Scripting，跨站脚本攻击)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 cookie，session tokens，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。 钓鱼欺诈是一种网络欺诈行为，通过伪造合法的Web站点来诱骗用户提供私人信息，如登录名、密码、信用卡号等。这些欺诈行为通常通过电子邮件或即时通讯工具发送具有欺诈性质的链接，诱骗用户点击并输入敏感信息。 蠕虫攻击是一种利用漏洞或弱点进行自我复制和传播的恶意软件，类似于生物学中的蠕虫。蠕虫攻击通常利用电子邮件或网络漏洞进行传播，它们可以自我复制并发送到其他计算机，从而占用网络资源和计算机资源，导致系统崩溃或数据损失。 XSS避免方式： url参数使用encodeURIComponent方法转义 尽量不使用InnerHtml插入HTML内容 使用特殊符号、标签转义符。 CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。 CSRF避免方式： 添加验证码 使用token 服务端给用户生成一个token，加密后传递给用户 用户在提交请求时，需要携带这个token 服务端验证token是否正确 DDoS又叫分布式拒绝服务，全称 Distributed Denial of Service，其原理就是利用大量请求造成资源过载，导致服务不可用。 DDos避免方式： 限制单IP请求频率。 防火墙等防护设置禁止ICMP包等 检查特权端口的开放 ICMP包:（Internet控制消息协议）,用于在IP主机、路由器之间传递控制消息 360技术：嗨，送你一张Web性能优化地图 websocket和http1、含义不同 websocket：WebSocket是一种在单个TCP连接上进行全双工通信的协议。(全双工: 允许设备同时在两个方向上发送和接收数据，即同时进行上传和下载) http：超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上，是单向的通信协议。 2、连接方式不同 websocket：WebSocket是需要浏览器和服务器握手进行建立连接的。 http：http是浏览器发起向服务器的连接，服务器预先并不知道这个连接。 3、连接长度不同 websocket：websocket是持久连接。 http：http 是短连接(http可以通过Ajax一直发送请求和长轮询保持一段时间内的连接，但本质上还是短连接)。 4、连接状态不同 websocket：websocket是有状态的双向连接。 http：http 是无状态的单向连接。 5、协议开头不同 websocket：websocket的协议是以 ws&#x2F;wss 开头。 http：http 对应的是 http&#x2F;https。 websocket和http的联系 都是基于TCP协议； websocket是基于http的(但要握一次手),他们的兼容性都很好； 在连接的建立过程中对错误的处理方式相同； 都使用 Request&#x2F;Response（请求-应答）模型进行连接的建立； 都可以在网络中传输数据。 CDN-内容分发网络在用户访问相对集中的地区和网络设置一些缓存服务器。当用户访问网站时，利用全局的负载均衡技术将用户的访问指向距离最近的缓存服务器，由缓存服务器代替源站响应用户的访问请求。 实现步骤: 1、用户向浏览器提供要访问网站的域名，域名解析的请求被发往本地用户使用的DNS服务器，本地DNS服务器将解析请求转发至网站的DNS服务器(NS)； 2、由于网站的DNS服务器(NS)对此域名的解析设置了CNAME，请求最终被指向到CDN网络中的GLB系统; 3、GLB系统对域名进行智能解析，将响应速度最快的节点IP返回给用户; 4、浏览器在得到实际的IP地址以后，向CDN节点发出访问请求; 5、由于是第一次访问，CDN节点将回到源站获得用户请求的数据并发给用户，同时CDN节点根据缓存策略对该数据进行缓存; 6、当有其他用户再次访问同样内容时，CDN节点直接将数据返回给客户，完成请求&#x2F;服务过程。"},{"title":"vue","path":"/undefined/vue/","content":"简述MVVM什么是MVVM？ 是Model-View-ViewModel的缩写，也就是把MVC(模型（Model）、视图（View）和控制（Controller）)中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。以前是操作DOM结构更新视图，现在是数据驱动视图。 视图，用于封装UI和UI逻辑； 视图模型，用于封装表示逻辑和状态；以及模型，用于封装应用的业务逻辑和数据 Model是数据存放,ViewModel是各种后端代码 MVVM的优点： 1.低耦合。视图（View）可以独立于Model变化和修改，一个Model可以绑定到不同的View上，当View变化的时候Model可以不变化，当Model变化的时候View也可以不变；2.可重用性。你可以把一些视图逻辑放在一个Model里面，让很多View重用这段视图逻辑。3.独立开发。开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员可以专注于页面设计。4.可测试。 Vue底层实现原理视图模型双向绑定/vue响应式： vue2是采用数据劫持(响应式基础) +发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，触发相应的监听回调 发布者-订阅者模式是一种常用的设计模式，它允许发布者和订阅者之间实现一对多的通信。这种模式在许多系统设计中都有应用，特别是在需要解耦操作和响应之间关系的场景中。 在发布者-订阅者模式中，发布者是发布消息的实体，而订阅者则是订阅特定主题的实体。当发布者发布消息时，所有订阅了该主题的订阅者都会接收到更新的消息。 这种模式的优点在于，发布者和订阅者之间没有直接耦合，这使得它们可以独立地改变其行为，而不会影响彼此。例如，发布者可以随时发布消息，而订阅者可以根据需要随时订阅或取消订阅。 Object.defineProperty() 是一个 JavaScript 内置函数，用于在对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。 Object.defineProperty(obj, prop, descriptor) 其中： obj 是要定义属性的对象。 prop 是要定义或修改的属性名。 descriptor 是一个描述符对象，用于定义属性的属性和方法。 描述符对象可以具有以下属性： value：定义了属性的值。可以是任何数据类型。 writable：是一个布尔值，表示该属性的值是否可以被改变。默认值为 false。 configurable：是一个布尔值，表示该属性是否可以被删除或者再次修改其特性。默认值为 false。 enumerable：是一个布尔值，表示该属性是否可以在 for…in 循环和 Object.keys() 中被枚举。默认值为 false。 get：是一个函数，作为该属性的 getter。当访问该属性时，会自动调用此函数，返回该属性的值。默认值为 undefined。 set：是一个函数，作为该属性的 setter。当该属性的值被修改时，会自动调用此函数，接收新值作为参数。默认值为 undefined。 下面是一个使用 Object.defineProperty() 的例子： var obj &#x3D; {}; Object.defineProperty(obj, ‘prop’, {value: ‘Hello’,writable: false,configurable: true,enumerable: true,get: function() { return ‘Hello’;},set: function(value) { console.log(‘Cannot change value’);}}); console.log(obj.prop); &#x2F;&#x2F; 输出 “Hello”obj.prop &#x3D; ‘Hi’; &#x2F;&#x2F; 抛出错误，因为 writable 被设为 false 12345678910111213141516var vm = new Vue(&#123; el: &#x27;#example&#x27;, data: &#123; message: &#x27;Hello Vue!&#x27; &#125;, mounted: function() &#123; Object.defineProperty(this, &#x27;message&#x27;, &#123; get: function() &#123; return &#x27;Hello from Vue 2!&#x27;; &#125;, set: function(value) &#123; console.log(&#x27;Cannot change value&#x27;); &#125; &#125;); &#125; &#125;); 通过Object.defineProperty()方法定义了一个名为”message”的属性，并在mounted钩子函数中修改了该属性的get和set函数。当访问vm.message时，会返回”Hello from Vue 2!”，当尝试修改vm.message的值时，会输出”Cannot change value”。 vue3实现双向绑定的核心是Proxy（代理的使用），它会对需要响应式处理的对象进行一层代理，对象的所有操作（get、set等）都会被Prxoy代理到。在vue中，所有响应式对象相关的副作用函数会使用weakMap来存储。当执行对应的操作时，会去执行操作中所收集到的副作用函数。 副作用函数是指一个函数除了完成其主要任务外，还产生了其他影响。这种影响可能包括副作用，例如修改全局变量或外部资源，或者对其他函数的调用 代理： 对一个对象基本语义的代理，拦截并重新定义对一个对象的基本操作。 1234567891011121314import &#123; reactive &#125; from &#x27;vue&#x27; const state = reactive(&#123; count: 0, message: &#x27;Hello Vue!&#x27; &#125;) // 访问代理后的属性 console.log(state.count) // 输出 0 console.log(state.message) // 输出 &quot;Hello Vue!&quot; // 修改代理后的属性 state.count++ state.message = &#x27;Hello Vue 3!&#x27; https://juejin.cn/post/7204707115062411320#heading-15 拓展:https://blog.csdn.net/web2022050901/article/details/128715841 Vue是一个典型的MVVM框架，模型（Model）只是普通的javascript对象，修改它则视图（View）会自动更新。这种设计让状态管理变得非常简单而直观 Observer（数据监听器） : Observer的核心是通过Object.defineProprtty()来监听数据的变动，这个函数内部可以定义setter和getter，每当数据发生变化，就会触发setter。这时候Observer就要通知订阅者，订阅者就是Watcher.(vue2.0) Watcher（订阅者） : Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是： 在自身实例化时往属性订阅器(dep)里面添加自己 Vue.js的响应式系统需要确保所有的订阅者都能够接收到数据变化时的通知 在Vue.js中，当一个组件被渲染时，它的数据属性会被转换成getter和setter函数，以便于追踪数据的变化。当数据发生变化时，setter函数会被调用，并且会触发相应的订阅者。订阅者是通过观察数据属性的方式来监听数据的变化，当数据发生变化时，订阅者会自动更新视图。但是，如果一个组件被销毁或者重新创建，之前订阅的属性可能已经不存在了。因此，当订阅者被实例化时，需要将自己添加到属性订阅器(dep)中，这样当属性发生变化时，属性订阅器就能够通知所有的订阅者，包括新添加的订阅者。这样就能够确保所有的订阅者都能够接收到数据变化时的通知，并且更新视图。 自身必须有一个update()方法 待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调 Compile（指令解析器） : Compile主要做的事情是解析模板指令，将模板中变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加鉴定数据的订阅者，一旦数据有变动，收到通知，更新视图 Diff算法传送门：☞ 20分钟吃透Diff算法核心原理 只有一个li标签修改了文本，其他都是不变的，所以没必要所有的节点都要更新，只更新这个li标签就行，Diff算法就是查出这个li标签的算法,所以是对比算法 新旧虚拟DOM对比的时候，Diff算法比较只会在同层级进行, 不会跨层级比较。 所以Diff算法是:深度优先算法。 时间复杂度:O(n) 讲讲Vue的虚拟DOM，原理，好处是什么？相对于手动操作DOM，性能更好吗？虚拟DOM就是用Js来模拟出DOM结构，通过diff算法来计算出最小的变更，通过对应的渲染器，来渲染到页面上。让开发者系的代码在性能上得到保障，甚至无限接近命令式代码的性能 虚拟DOM算法操作真实DOM，性能高于直接操作真实DOM，虚拟DOM和虚拟DOM算法是两种概念。虚拟DOM算法 &#x3D; 虚拟DOM + Diff算法 Diff算法是一种对比算法。对比两者是旧虚拟DOM和新虚拟DOM，对比出是哪个虚拟节点更改了，找出这个虚拟节点，并只更新这个虚拟节点所对应的真实节点，而不用更新其他数据没发生改变的节点，实现精准地更新真实DOM，进而提高效率 使用虚拟DOM算法的损耗计算： 总损耗 &#x3D; 虚拟DOM增删改+（与Diff算法效率有关）真实DOM差异增删改+（较少的节点）排版与重绘 直接操作真实DOM的损耗计算： 总损耗 &#x3D; 真实DOM完全增删改+（可能较多的节点）排版与重绘 新旧虚拟DOM对比的时候，Diff算法比较只会在同层级进行, 不会跨层级比较。 所以Diff算法是:深度优先算法。 时间复杂度:O(n) 当数据改变时，会触发setter，并且通过Dep.notify去通知所有订阅者Watcher，订阅者们就会调用patch方法，给真实DOM打补丁，更新相应的视图。 vue3中的ref、toRef、toRefs ref:接收一个内部值，生成对应的响应式数据，该内部值挂载在ref对象的value属性上；该对象可以用于模版和reactive。使用ref是为了解决值类型在setup、computed、合成函数等情况下的响应式丢失问题。 123456ref函数用于创建一个响应式的值。这个值在初始化时必须是原始类型（例如字符串、数字、布尔值等）。它返回一个包含value属性的响应式对象，可以通过这个属性来访问或修改原始值。import &#123; ref &#125; from &#x27;vue&#x27; const count = ref(10) console.log(count.value) // 输出 10 count.value++ // 修改原始值 console.log(count.value) // 输出 11 toRef:为响应式对象（reactive）的一个属性创建对应的ref，且该方式创建的ref与源属性保持同步。 12345678将一个对象转换成一个响应式的对象。这个对象应该有一个名为value的属性，并且该属性的值将被转换为一个响应式的值。toRef返回一个新的响应式对象，可以通过它来访问或修改原始对象的value属性import &#123; toRef &#125; from &#x27;vue&#x27; const state = &#123; count: 10 &#125; const count = toRef(state, &#x27;count&#x27;) console.log(count.value) // 输出 10 count.value++ // 修改原始对象的值 console.log(count.value) // 输出 11 console.log(state.count) // 输出 11 toRefs：响应式对象，对象的每个属性都是对应的ref，两者间保持同步。使用toRefs进行对象解构。 123456789101112将一个对象转换成一个响应式的对象。与toRef不同的是，toRefs会递归地将对象的所有属性都转换为一个响应式的对象，包括嵌套的属性import &#123; toRefs &#125; from &#x27;vue&#x27; const state = &#123; count: 10, message: &#x27;Hello&#x27; &#125; const stateProxy = toRefs(state) console.log(stateProxy.count.value) // 输出 10 console.log(stateProxy.message.value) // 输出 &#x27;Hello&#x27; stateProxy.count.value++ // 修改原始对象的值 stateProxy.message = &#x27;World&#x27; // 修改原始对象的属性 console.log(stateProxy.count.value) // 输出 11 console.log(stateProxy.message.value) // 输出 &#x27;World&#x27; console.log(state.count) // 输出 11 console.log(state.message) // 输出 &#x27;World&#x27; 谈谈对vue生命周期的理解？vue的生命周期钩子(是单独成的一个方法)，就是说在达到某一阶段或条件时去触发的函数，目的就是为了完成一些动作或者事件 概念：从创建、初始化数据、编译模板、挂载DOM、渲染-更新-渲染、卸载等一系列过程，称为为Vue 实例的生命周期。 vue2.0 beforeCreate &#x3D;&gt; created &#x3D;&gt; beforeMount &#x3D;&gt; mounted &#x3D;&gt; beforeUpdate &#x3D;&gt; updated &#x3D;&gt; beforeDestroy &#x3D;&gt; destroyed vue3.0 setup &#x3D;&gt; onBeforeMount &#x3D;&gt; onMounted &#x3D;&gt; onBeforeUpdate &#x3D;&gt; onUpdated &#x3D;&gt; onBeforeUnmount &#x3D;&gt; onUnmounted beforeCreate：创建前。此时，组件实例刚刚创建，还未进行数据观测和事件配置，拿不到任何数据。 created：创建完成。vue 实例已经完成了数据观测，属性和方法的计算(比如props、methods、data、computed和watch此时已经拿得到)，未挂载到DOM，不能访问到el属性，el属性，ref属性内容为空数组常用于简单的ajax请求，页面的初始化。 beforeMount：挂载前。挂在开始之前被调用，相关的render函数首次被调用（虚拟DOM）。编译模板，把data里面的数据和模板生成html，完成了el和data 初始化，注意此时还没有挂在html到页面上。 mounted：挂载完成。也就是模板中的HTML渲染到HTML页面中，此时可以通过DOM API获取到DOM节点，$ref属性可以访问常用于获取VNode信息和操作，ajax请求，mounted只会执行一次。 beforeUpdate：在数据更新之前被调用，发生在虚拟DOM重新渲染和打补丁之前，不会触发附加地重渲染过程。 updated：更新后。在由于数据更改导致地虚拟DOM重新渲染和打补丁之后调用， beforeDestroy;销毁前。在实例销毁之前调用，实例仍然完全可用。（一般在这一步做一些重置的操作，比如清除掉组件中的定时器 和 监听的dom事件） destroyed：销毁后。在实例销毁之后调用，调用后，vue实列指示的所有东西都会解绑，所有的事件监听器会被移除。 其他：activated：在keep-alive组件激活时调用deactivated：在keep-alive组件停用时调用详情可看vue2.0官网生命周期钩子 vue2.0生命周期分为四个阶段：初始化、创建、挂载和更新。每个阶段都有对应的钩子函数 create阶段：vue实例被创建beforeCreate: 最初调用触发，创建前，此时data和methods中的数据都还没有初始化，data和events都不能用created： 创建完毕，data中有值，未挂载，data和events已经初始化好，data已经具有响应式；在这里可以发送请求 mount阶段： vue实例被挂载到真实DOM节点beforeMount：在模版编译之后，渲染之前触发，可以发起服务端请求，去数据，ssr中不可用，基本用不上这个hookmounted: 在渲染之后触发，此时可以操作DOM，并能访问组件中的DOM以及$ref,SSR中不可用 update阶段：当vue实例里面的data数据变化时，触发组件的重新渲染beforeUpdate :更新前，在数据变化后，模版改变前触发，切勿使用它监听数据变化updated：更新后，在数据改变后，模版改变后触发，常用于重渲染案后的打点，性能检测或触发vue组件中非vue组件的更新 destroy阶段：vue实例被销毁beforeDestroy：实例被销毁前，组件卸载前触发，此时可以手动销毁一些方法，可以在此时清理事件、计时器或者取消订阅操作destroyed:卸载完毕后触发，销毁后，可以做最后的打点或事件触发操作 vue3.0Vue 3 引入了 Composition API，因此其生命周期钩子有所变化。以下是基于 Vue 3 的钩子执行顺序： onBeforeMount: 在挂载开始之前被调用。 onMounted: el被新创建的vm.el替换，并挂载到实例上去之后调用该钩子。如果实例被挂载到一个文档内元素上，当onMounted被调用时vm.el也在文档内。 onBeforeUpdate: 数据更新时调用，发生在虚拟DOM打补丁之前。 onUpdated: 由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。 onBeforeUnmount: 组件卸载前立即调用。 onUnmounted: 组件卸载后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。 注意：Vue 3 中的这些生命周期钩子函数的执行顺序与 Vue 2 中的顺序相似，但名称有所不同，同时 Vue 3 中新增了 onBeforeUnmount 和 onUnmounted 这两个钩子函数。另外，Vue 3 中还引入了 setup 函数作为 Composition API 的一部分，该函数在 onBeforeMount 之前执行。 最终顺序：Vue3生命周期：setup Vue2生命周期：beforeCreate Vue2生命周期：created Vue3生命周期：onBeforeMount Vue2生命周期：beForeMount Vue3生命周期：onMounted Vue2生命周期：mounted Vue3生命周期：onBeforeUpdate Vue2生命周期：beforeUpdate Vue3生命周期：onUpdated Vue2生命周期：updated Vue3生命周期：onBeforeUnmount Vue2生命周期：beforeUnmount Vue3生命周期：onUnmounted Vue2生命周期：unmounted 生命周期（父子组件）组件生命周期vue2.0 加载渲染过程 父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted 挂载阶段 父created-&gt;子created-&gt;子mounted-&gt;父mounted 父组件更新阶段 父beforeUpdate-&gt;父updated 子组件更新阶段 父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated 销毁阶段 父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed (父组件先开始执行，然后等到子组件执行完，父组件收尾。不管vue2还是vue3) 在 Vue 2 中，父组件的生命周期依赖于子组件的生命周期，子组件必须先完成自身的生命周期才能触发父组件的生命周期。 相比之下，Vue 3 的父子组件生命周期有所改进，引入了 Composition API 的 setup 函数，使得父子组件的生命周期更加灵活。 在 Vue 3 中，父子组件的生命周期可以按照以下方式执行： 父组件先进行 setup 函数和生命周期函数的执行，再执行子组件的 setup 函数和生命周期函数。 子组件的 setup 函数与生命周期函数的执行顺序与父组件相同，即先执行子组件的 setup 函数，再执行生命周期函数。 子组件的 beforeMount 和 mounted 生命周期函数的执行顺序早于父组件的同名函数，且子组件所有的生命周期函数都会在父组件的生命周期函数执行完后再执行。 当父组件重新渲染时，子组件的生命周期函数会根据需要进行更新，而不是重新挂载。 当子组件被卸载时，会先执行子组件的 beforeUnmount 和 unmounted 生命周期函数，再执行父组件的 same-name 函数。 因此，Vue 3 中父子组件的生命周期不再是严格的依赖关系，而是更加独立和灵活 computed与watch通俗来讲，既能用 computed 实现又可以用 watch 监听来实现的功能，推荐用 computed， 重点在于 computed 的缓存功能 computed 计算属性是用来声明式的描述一个值依赖了其它的值，当所依赖的值或者变量 改变时，计算属性也会跟着改变； watch 监听的是已经在 data 中定义的变量，当该变量变化时，会触发 watch 中的方法。 computed值有缓存、触发条件是依赖值发生更改； watch无缓存支持异步、（触发条件）监听数据变化 computed是一个计算属性，它只能用作动词。这意味着当你访问计算属性时，Vue.js会缓存其结果，并且只有当依赖的数据发生改变时，才会重新计算。它是不支持异步的，如果计算属性中有异步操作，那么你需要使用其他的方法来处理异步操作。 而watch除了可以作为动词，还可以作为名词。作为动词时，它的作用是观察某个数据或组件的改变，当观察的目标发生改变时，执行相应的函数。作为名词时，watch是一个组件选项，用于在异步依赖项上设置延迟响应(就不是立即执行了)。 watch 属性监听 是一个对象，键是需要观察的属性，值是对应回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作,监听属性的变化，需要在数据变化时执行异步或开销较大的操作时使用 computed 计算属性 属性的结果会被缓存，当computed中的函数所依赖的属性没有发生改变的时候，那么调用当前函数的时候结果会从缓存中读取。除非依赖的响应式属性变化时才会重新计算，主要当做属性来使用 computed中的函数必须用return返回最终的结果 computed更高效，优先使用。data 不改变，computed 不更新。 computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；watch： 更多的是观察的作用，支持异步，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作； computed应用场景：需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；watch应用场景：需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 使用场景 computed：当一个属性受多个属性影响的时候使用，例：购物车商品结算功能 ​ watch：当一条数据影响多条数据的时候使用，例：搜索数据 12345678910111213141516171819202122232425262728computed: &lt;template&gt; &lt;div&gt; &lt;p&gt;原始价格：&#123;&#123; product.price &#125;&#125;&lt;/p&gt; &lt;p&gt;折扣：&#123;&#123; product.discount &#125;&#125;&lt;/p&gt; &lt;p&gt;结算价格：&#123;&#123; product.computedPrice &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; product: &#123; price: 100, discount: 20, &#125; &#125;; &#125;, computed: &#123; product: &#123; computedPrice() &#123; return this.price * (1 - this.discount / 100); &#125; &#125; &#125; &#125;; &lt;/script&gt; 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;input v-model=&quot;message&quot; /&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; 监视器名必须与数据属性的名称完全匹配，并且监视器的函数应该接受两个参数：新值和旧值。&lt;script&gt; export default &#123; data() &#123; return &#123; message: &#x27;&#x27; &#125;; &#125;, watch: &#123; message(newVal, oldVal) &#123; console.log(`message changed from $&#123;oldVal&#125; to $&#123;newVal&#125;`); &#125; &#125; &#125;; &lt;/script&gt; 组件中的data为什么是一个函数？1.一个组件被复用多次的话，不同项目也就会创建多个实例(同一个项目中只会存在一份实例)。本质上，这些实例用的都是同一个构造函数。 2.如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。 为什么v-for和v-if不建议用在一起1.当 v-for 和 v-if 处于同一个节点时，v-for 的优先级比 v-if 更高(vue2.x)，这意味着 v-if 将分别重复运行于每个 v-for 循环中。如果要遍历的数组很大，而真正要展示的数据很少时，这将造成很大的性能浪费2.这种场景建议使用 computed，先对数据进行过滤(就是看符不符合之前设定的条件) 注意：3.x 版本中 v-if 总是优先于 v-for 生效。由于语法上存在歧义，建议避免在同一元素上同时使用两者。比起在模板层面管理相关逻辑，更好的办法是通过创建计算属性筛选出列表，并以此创建可见元素。 解惑传送门 ☞ # v-if 与 v-for 的优先级对比非兼容 React&#x2F;Vue 项目中 key 的作用为了性能优化， 因为vue是虚拟DOM，更新DOM时用diff算法对节点进行一一比对，比如有很多li元素，要在某个位置插入一个li元素，但没有给li上加key，那么在进行运算的时候，就会将所有li元素重新渲染一遍，但是如果有key，那么它就会按照key一一比对li元素，只需要创建新的li元素，插入即可，不需要对其他元素进行修改和重新渲染。key也不能是li元素的index，因为假设我们给数组前插入一个新元素，它的下标是0，那么和原来的第一个元素重复了，整个数组的key都发生了改变，这样就跟没有key的情况一样了。 key的作用是为了在diff算法执行时更快的找到对应的节点，提高diff速度，更高效的更新虚拟DOM; vue和react都是采用diff算法来对比新旧虚拟节点，从而更新节点。在vue的diff函数中，会根据新节点的key去对比旧节点数组中的key，从而找到相应旧节点。如果没找到就认为是一个新增节点。而如果没有key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找。相比而言。map映射的速度更快。 为了在数据变化时强制更新组件，以避免“就地复用”带来的副作用。 当 Vue.js 用 v-for 更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。重复的key会造成渲染错误。 数组扁平化转换在说到模版编译的时候，有可能会提到数组的转换，一般就用递归处理将 [1,2,3,[4,5]] 转换成 1234567891011121314151617181920212223&#123; children:[ &#123; value:1 &#125;, &#123; value:2 &#125;, &#123; value:3 &#125;, &#123; children:[ &#123; value:4 &#125;, &#123; value:5 &#125; ] &#125;, ]&#125; 12345678910111213141516171819202122232425// 测试数组var arr =[1,2，3，[4,5]];// 转换函数function convert(arr)&#123; //准备一个接收结果数组 var result = []; // 遍历传入的 arr 的每一项 for(let i=0;i&lt;arr.length;i++)&#123; //如果遍历到的数字是number，直接放进入 if(typeof arr[i] == &#x27;number&#x27;)&#123; result.push(&#123; value:arr[i] &#125;); &#125; else if(Array.isArray(arr[i]))&#123; //如果遍历到这个项目是数组，那么就递归 result.push(&#123; children: convert(arr[i]) &#125;); &#125; &#125; return result;&#125;var o = convert(arr);console.log(o); 组件之间如何传值⭐⭐⭐一、Vue父子 组件之间传值 子组件通过props来接受数据和通过$emit来触发父组件的自定义事件；二、兄弟组件之间的传值 建一个公共组件bus.js.。传递方通过事件触发bus.$emit。接收方通过在mounted（）{}生命周期里触发bus.$on。三、可以通过VUEX 来跨组件传参。 四、父孙传值 $attrs（向下）$listeners（向上）(bind绑定) 五、 祖先和子孙传值provide&#x2F;inject 六、获取父组件实例this.$parent详情可看vue之组件的传参方式 vue组件的通信方式 props&#x2F;$emit 父子组件通信 父-&gt;子props，子-&gt;父 $on(监听事件)、$emit(触发事件)(on&#x2F;emit也可以单页面使用) 获取父子组件实例 $parent、$children Ref 获取实例的方式调用组件的属性或者方法 父-&gt;子孙 Provide、inject 官方不推荐使用，但是写组件库时很常用 $emit&#x2F;$on 自定义事件 兄弟组件通信 Event Bus 实现跨组件通信 Vue.prototype.$bus = new Vue() 自定义事件 vuex 跨级组件通信 Vuex、$attrs、$listeners Provide、inject 子组件可以使用 $emit 触发父组件的自定义事件。 this.emit(‘increment1’,”参数”)；其实它的作用就是触发自定义函数。此外,可以子组件传参数给父组件. 12345678910111213141516171819202122232425262728293031323334353637383940emit 子组件&lt;template&gt; &lt;button @click=&quot;emitEvent&quot;&gt;点击我&lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; msg: &quot;我是子组件中的数据&quot; &#125; &#125;, methods: &#123; emitEvent()&#123; this.$emit(&#x27;my-event&#x27;, this.msg) //通过按钮的点击事件触发方法，然后用$emit触发一个my-event的自定义方法，传递this.msg数据。 &#125; &#125; &#125;&lt;/script&gt;父组件&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;child-a @my-event=&quot;getMyEvent&quot;&gt;&lt;/child-a&gt; &lt;!--父组件中通过监测my-event事件执行一个方法，然后取到子组件中传递过来的值--&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import ChildA from &#x27;./components/child.vue&#x27; export default &#123; components: &#123; ChildA &#125;, methods: &#123; getMyEvent(msg)&#123; // msg是个形参value,实质是接收的子组件传来数据的参数 console.log(&#x27;接收的数据---------&gt;&#x27;+msg)//接收的数据---------&gt;我是子组件中的数据 &#125; &#125; &#125;&lt;/script&gt; 12345678910111213141516171819202122232425262728293031父组件可以使用 props 把数据传给子组件。子组件通过props拿到父组件传来的数据。父传子 prop是单向数据流,不允许在子组件中改变prop是一种自定义标签属性，用于实现组件之间的数据传递解决方法在data中定义一个第三方的变量接收数据(即克隆数据),这个第三方变量即可更改,同时,在mounted阶段赋值给这个变量父组件&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;transac-del&quot;&gt; &lt;div&gt; &lt;span class=&quot;sub_title&quot;&gt;交易详情&lt;/span&gt; &lt;/div&gt; &lt;p&gt; // v-if的原因是调接口回来数据是个异步操作,因此给个条件判断,数据不为null的时候才传数据给子组件,以免数据一开始拿到的是空对象 &lt;transacDet v-if=&quot;deiMap&quot; :DeiMap = &#x27;deiMap&#x27; /&gt; // 子组件,并且在数据模型中定义deiMap:null &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;子组件props: &#123; DeiMap:&#123; type:Object, required: true &#125; &#125;, mounted () &#123; // 子组件通过props拿到父组件传来的数据,是个对象,直接this.DeiMap可以使用数据 console.log(&#x27;obj==&#x27;,this.DeiMap) &#125;, 12345&lt;p ref=&quot;p&quot;&gt;Hello&lt;/p&gt;&lt;children ref=&quot;children&quot;&gt;&lt;/children&gt;this.$refs.pthis.$refs.children ref特性就是为元素或子组件赋予一个ID引用,通过this.$refs.refName来访问元素或子组件的实例 $refs是一个对象，持有当前组件中注册过 ref特性的所有 DOM 元素和子组件实例注意： $refs只有在组件渲染完成后才填充，在初始渲染(created)的时候不能访问它们，并且它是非响应式的，因此不能用它在模板中做数据绑定,仅是一个直接操作子组件的应急方案注意：当ref和v-for一起使用时，获取到的引用将会是一个数组，包含循环数组源 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--用ref给子组件起个名字--&gt; &lt;child-a ref=&quot;childdd&quot;&gt;&lt;/child-a&gt; &lt;button @click=&quot;getMyEvent&quot;&gt;点击父组件&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import ChildA from &#x27;./components/child.vue&#x27; export default &#123; components: &#123; ChildA &#125;, data() &#123; return &#123; msg: &quot;我是父组件中的数据&quot; &#125; &#125;, methods: &#123; getMyEvent()&#123; this.$refs.childdd.emitEvent(this.msg); //调用子组件的方法，child是上边ref起的名字，emitEvent是子组件的方法。 &#125; &#125; &#125;&lt;/script&gt; parent在子组件中调用父组件的方法或获得其数据this.$parent 可以访问到父组件上所有的 data(){ 里的数据信息和生命周期方法，methods里的方法 } 如 this.$parent.List &#x3D; []; 表示访问到父组件中data的数据list数组 区分1、ref为子组件指定一个索引名称，通过索引来操作子组件；2、this.$parent 可以直接访问该组件的父实例或组件；3、父组件也可以通过this.$children 访问它所有的子组件，$parent和$children 可以递归向上或向下无线访问， 直到根实例或最内层的组件。 $children:他返回的是一个组件集合，如果你能清楚的知道子组件的顺序，你也可以使用下标来操作 1234567891011121314151617181920212223242526272829303132父组件&lt;template&gt;&lt;div&gt; &lt;testVue ref=&quot;childVue&quot;&gt;&lt;/testVue&gt; &lt;br/&gt;&lt;br/&gt; &lt;testVue2&gt;&lt;/testVue2&gt; &lt;br/&gt;&lt;br/&gt; &lt;button @click=&quot;clickChild1&quot;&gt;点击访问子组件&lt;/button&gt; &lt;br/&gt;&lt;br/&gt; &lt;button @click=&quot;clickChild2&quot;&gt;点击访问子组件2&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import testVue from &#x27;./testVue&#x27;import testVue2 from &#x27;./testVue2&#x27;export default &#123; data()&#123; return &#123; total: 0 &#125; &#125;, methods: &#123; clickChild1()&#123; console.log(this.$refs.childVue.counter); &#125;, clickChild2()&#123; console.log(this.$children[1].testval); &#125; &#125;, components: &#123; testVue, testVue2 &#125;&#125;&lt;/script&gt; $emit 后面的两个参数是什么1、父组件可以使用 props 把数据传给子组件。2、子组件可以使用 $emit,让父组件监听到自定义事件 。 vm.$emit( event, arg );&#x2F;&#x2F;触发当前实例上的事件，要传递的参数vm.$on( event, fn );&#x2F;&#x2F;监听event事件后运行 fn； 子组件 1234567891011121314151617181920&lt;template&gt; &lt;div class=&quot;train-city&quot;&gt; &lt;h3&gt;父组件传给子组件的toCity:&#123;&#123;sendData&#125;&#125;&lt;/h3&gt; &lt;br/&gt;&lt;button @click=&#x27;select(`大连`)&#x27;&gt;点击此处将‘大连’发射给父组件&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&#x27;trainCity&#x27;, props:[&#x27;sendData&#x27;], // 用来接收父组件传给子组件的数据 methods:&#123; select(val) &#123; let data = &#123; cityName: val &#125;; this.$emit(&#x27;showCityName&#x27;,data);//select事件触发后，自动触发showCityName事件 &#125; &#125; &#125;&lt;/script&gt; 父组件 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;div&gt;父组件的toCity&#123;&#123;toCity&#125;&#125;&lt;/div&gt; &lt;train-city @showCityName=&quot;updateCity&quot; :sendData=&quot;toCity&quot;&gt;&lt;/train-city&gt; &lt;/div&gt;&lt;template&gt;&lt;script&gt; export default &#123; name:&#x27;index&#x27;, components: &#123;&#125;, data () &#123; return &#123; toCity:&quot;北京&quot; &#125; &#125;, methods:&#123; updateCity(data)&#123;//触发子组件城市选择-选择城市的事件 this.toCity = data.cityName;//改变了父组件的值 console.log(&#x27;toCity:&#x27;+this.toCity) &#125; &#125; &#125;&lt;/script&gt; Vue 中 $nextTick 作用与原理？⭐⭐⭐异步渲染、获取DOM、Promise等。 Vue 在更新 DOM 时是异步执行的，在修改数据后，视图不会立刻更新，而是等同一事件循环(event loop)中的所有数据变化完成之后，再统一进行视图更新。所以修改完数据，立即在方法中获取DOM，获取的仍然是未修改的DOM。(每次数据更新时，Vue.js会安排一个任务将DOM异步地进行更新。这意味着在数据更新后，立即查询DOM可能还没有得到更新) $nextTick的作用是：该方法中的代码会在当前渲染完成后执行，就解决了异步渲染获取不到更新后DOM的问题了。 123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;input v-model=&quot;message&quot; /&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; message: &#x27;&#x27; &#125;; &#125;, watch: &#123; message(newVal, oldVal) &#123; this.nextTick(() =&gt; &#123; // 在这里执行需要等待DOM更新完成的操作 console.log(&#x27;DOM已更新&#x27;); &#125;); &#125; &#125; &#125;; &lt;/script&gt; 应用场景： 在created()里面想要获取操作Dom，把操作DOM的方法放在$nextTick中。在data()中的修改后，页面中无法获取data修改后的数据，使用nextTick时，当data中的数据修改后，可以实时的渲染页面官网中是这么说的 nextTick的实现 nextTick是Vue提供的一个全局API,是在下次DOM更新循环结束之后执行延迟回调，在修改数据之后使用$nextTick，则可以在回调中获取更新后的DOM； Vue在更新DOM时是异步执行的。只要侦听到数据变化，Vue将开启1个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作是非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用； 比如，我在干什么的时候就会使用nextTick，传一个回调函数进去，在里面执行dom操作即可； 我也有简单了解nextTick实现，它会在callbacks里面加入我们传入的函数，然后用timerFunc异步方式调用它们，首选的异步方式会是Promise。这让我明白了为什么可以在nextTick中看到dom操作结果。 nextTick的实现原理是什么？$nextTick本质是返回一个Promise 。 在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。 nextTick主要使用了宏任务和微任务。 根据执行环境分别尝试采用Promise、MutationObserver、setImmediate，如果以上都不行则采用setTimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。 使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽vue中的插槽是一个非常好用的东西slot说白了就是一个占位的 在vue当中插槽包含三种一种是默认插槽（匿名）一种是具名插槽还有一种就是作用域插槽,匿名插槽就是没有名字的只要默认的都填到这里,具名插槽指的是具有名字的 微信小程序有类似的操作 小程序的生命周期说白了就是指程序从创建、到开始、暂停、唤起、停止、卸载的过程 Vue的基本插槽, 两者的使用思路相同. 子组件开一个&lt;slot&gt;标签表示插槽, 父组件直接在子组件标签之间写入要插入的内容, 这些内容就会自动插入到子组件的第一个基本插槽 和Vue的具名插槽很像(怎么又像…), 至少使用上很像. 使用name属性在子组件里给插槽起名, 父组件进行内容插入时使用slot属性指定这部分内容要插入哪个插槽: 具名插槽 12345678910111213141516171819202122232425262728子组件&lt;template&gt; &lt;div&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;slot&gt;&lt;/slot&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt;父组件&lt;template&gt; &lt;div&gt; &lt;child-component&gt; &lt;template v-slot:header&gt;这是标题&lt;/template&gt; &lt;template v-slot:default&gt;这是内容&lt;/template&gt; &lt;template v-slot:footer&gt;这是页脚&lt;/template&gt; &lt;/child-component&gt; &lt;/div&gt; &lt;/template&gt;显示效果：标题这是标题内容这是内容页脚这是页脚&lt;FancyButton&gt; Click me! &lt;!-- 插槽内容 --&gt;&lt;/FancyButton&gt;//---&lt;button class=&quot;fancy-btn&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;!-- 插槽出口 --&gt;&lt;/button&gt;最终:&lt;button class=&quot;fancy-btn&quot;&gt;Click me!&lt;/button&gt; 匿名插槽 12345678910111213141516子组件&lt;template&gt; &lt;div&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt;父组件&lt;template&gt; &lt;div&gt; &lt;child-component&gt; &lt;h1&gt;这是标题&lt;/h1&gt; &lt;p&gt;这是内容&lt;/p&gt; &lt;/child-component&gt; &lt;/div&gt; &lt;/template&gt;显示效果：这是标题这是内容 作用域插槽 1234567891011121314151617181920&lt;!-- 子组件 --&gt; &lt;template&gt; &lt;div&gt; &lt;slot v-for=&quot;item in items&quot; :item=&quot;item&quot; name=&quot;item&quot;&gt;&#123;&#123;item.text&#125;&#125;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; &lt;!-- 父组件 --&gt; &lt;template&gt; &lt;div&gt; &lt;child-component&gt; &lt;template v-for=&quot;item in items&quot; v-slot:item.default=&quot;&#123; item &#125;&quot;&gt; &#123;&#123; item.text &#125;&#125; &lt;!-- 显示子组件传递过来的数据 --&gt; &lt;/template&gt; &lt;/child-component&gt; &lt;/div&gt; &lt;/template&gt;\t// 父组件中使用 &lt;template&gt; 标签并指定 slot 属性来指定要插入的位置。 // 作用域插槽可以通过 v-slot 指令来命名，以便在同一组件中区分不同的插槽。使用作用域插槽时，可以在 &lt;template&gt; 标签中使用 v-slot 指令后跟命名的方式，将数据传递给子组件。 // 父组件中，通过 &lt;template&gt; 标签并指定 v-slot 属性来指定要插入的位置和要传递的数据。 keep-alive的实现keep-alive是Vue.js的一个内置组件。它能够不活动的组件实例保存在内存中，而不是直接将其销毁，它是一个抽象组件，不会被渲染到真实DOM中，也不会出现在父组件链中。 作用：实现组件缓存，保持这些组件的状态，以避免反复渲染导致的性能问题。 需要缓存组件，频繁切换，不需要重复渲染 场景：tabs标签页 后台导航，vue性能优化 原理：Vue.js内部将DOM节点抽象成了一个个的VNode节点，keep-alive组件的缓存也是基于VNode节点的而不是直接存储DOM结构。它将满足条件（pruneCache）的组件在cache对象中缓存起来，在需要重新渲染的时候再将vnode节点从cache对象中取出并渲染。 keep-alive实现原理就是将对应的状态放入一个cache对象中，对应的dom节点放入缓存dom中，当下次再次需要渲染时，从对象中获取状态，从缓存dom中移出至挂载dom节点中。 pruneCache函数的作用是清除不再需要的组件或节点 要实现keep-alive的功能，需要在cache对象中缓存满足特定条件的组件，并通过正确地使用pruneCache函数来管理缓存。 keep-alive 的属性它提供了include与exclude两个属性，允许组件有条件地进行缓存。 include定义缓存白名单，keep-alive会缓存命中的组件；exclude定义缓存黑名单，被命中的组件将不会被缓存；max定义缓存组件上限，超出上限使用LRU的策略置换缓存数据。 在动态组件中的应用 123&lt;keep-alive :include=&quot;whiteList&quot; :exclude=&quot;blackList&quot; :max=&quot;amount&quot;&gt; &lt;component :is=&quot;currentComponent&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt; 在vue-router中的应用 123&lt;keep-alive :include=&quot;whiteList&quot; :exclude=&quot;blackList&quot; :max=&quot;amount&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; vue 中完整示例 123456789101112131415161718&lt;keep-alive&gt; &lt;coma v-if=&quot;test&quot;&gt;&lt;/coma&gt; &lt;comb v-else=&quot;test&quot;&gt;&lt;/comb&gt;&lt;/keep-alive&gt;&lt;button @click=&quot;test=handleClick&quot;&gt;请点击&lt;/button&gt;export default &#123; data () &#123; return &#123; test: true &#125; &#125;, methods: &#123; handleClick () &#123; this.test = !this.test; &#125; &#125;&#125; 参考:keep-alive 官网 keep-alive实现原理 Vue keep-alive的实现原理 vue 如何实现模拟 v-model 指令可以使用 vue 自定义指令 Vue.directive() 模拟 具体参考：[vue自定义指令模拟v-model指令 (vue2和vue3是不同的) 分全局和局部，用directives可以使用钩子函数bind、update、inserted，并用她们的参数进行操作，使用v-命名得到绑定 12345678910111213141516171819Vue.directive(&#x27;my-directive&#x27;, &#123; bind: function () &#123; // 准备工作 // 例如，添加事件处理器或只需要运行一次的高耗任务 &#125;, update: function (newValue, oldValue) &#123; // 值更新时的工作 // 也会以初始值为参数调用一次 &#125;, unbind: function () &#123; // 清理工作 // 例如，删除 bind() 添加的事件监听器 &#125;&#125;)&lt;div v-my-directive=&quot;someValue&quot;&gt;&lt;/div&gt;当只需要 update 函数时，可以传入一个函数替代定义对象：Vue.directive(&#x27;my-directive&#x27;, function (value) &#123; // 这个函数用作 update()&#125;) 通过bindings对象中的expression获取参数值的变量名。有了自定义的参数值的变量名，我们就可以在vnode中获取到变量的数据。 Vue Router 相关前端路由是一种根据url来渲染前端组件的技术 在多页面的场景下，相对于后端路由，前端路由由于可以实现无刷新的效果，用户体验更好。 使用前端路由，每个访问路径会对应一个组件，这个组件我们页称为页面。 vue-router的路由守卫全局前置守卫 12345678router.beforeEach((to, from, next) =&gt; &#123; // to: 即将进入的目标 // from:当前导航正要离开的路由 return false // 返回false用于取消导航 return &#123;name: &#x27;Login&#x27;&#125; // 返回到对应name的页面 next(&#123;name: &#x27;Login&#x27;&#125;) // 进入到对应的页面 next() // 放行&#125;) 全局解析守卫:类似beforeEach 12345router.beforeResolve(to =&gt; &#123; if(to.meta.canCopy) &#123; return false // 也可取消导航 &#125;&#125;) 全局后置钩子 123router.afterEach((to, from) =&gt; &#123; logInfo(to.fullPath)&#125;) 全局后置钩子 123router.afterEach((to, from) =&gt; &#123; logInfo(to.fullPath)&#125;) 导航错误钩子，导航发生错误调用 123router.onError(error =&gt; &#123; logError(error)&#125;) 路由独享守卫,beforeEnter可以传入单个函数，也可传入多个函数。 1234567891011121314151617function dealParams(to) &#123; // ...&#125;function dealPermission(to) &#123; // ...&#125;const routes = [ &#123; path: &#x27;/home&#x27;, component: Home, beforeEnter: (to, from) =&gt; &#123; return false // 取消导航 &#125;, // beforeEnter: [dealParams, dealPermission] &#125;] 组件内的守卫 123456789101112const Home = &#123; template: `...`, beforeRouteEnter(to, from) &#123; // 此时组件实例还未被创建，不能获取this &#125;, beforeRouteUpdate(to, from) &#123; // 当前路由改变，但是组件被复用的时候调用，此时组件已挂载好 &#125;, beforeRouteLeave(to, from) &#123; // 导航离开渲染组件的对应路由时调用 &#125;&#125; composition Api对比 option Api的优势 更好的代码组织 更好的逻辑复用 更好的类型推导 讲讲前端路由原理路由是根据不同的 url 地址展示不同的内容或页面。在 Web 前端单页应用中，路由描述的是 URL 与 UI 之间的映射关系，这种映射是单向的，即 URL 变化引起 UI 更新（无需刷新页面）。 https://zhuanlan.zhihu.com/p/412530109 路由之间如何传参⭐⭐通过router-link路由导航跳转传递&lt;router-link to&#x3D;/a/$&#123;id&#125;&gt;routerlink传参跳转时使用push方法拼接携带参数。 this.$router.push({ path: /getlist/$&#123;id&#125;, })通过路由属性中的name来确定匹配的路由，通过params来传递参数。this.$router.push({ name: ‘Getlist’, params: { id: id } })使用path来匹配路由，然后通过query来传递参数。this.$router.push({ path: ‘&#x2F;getlist’, query: { id: id } })注意：query有点像ajax中的get请求，而params像post请求。 params在地址栏中不显示参数，刷新页面，参数丢失,其余方法在地址栏中显示传递的参数，刷新页面，参数不丢失。 详情请看Vue-router之简单的路由传参三种方法 Route和router的区别⭐route:是路由信息对象，包括“path,parms,hash,name“等路由信息参数。Router:是路由实例对象，包括了路由跳转方法，钩子函数等。 Vue 路由跳转方式⭐⭐ router-link 标签跳转 this.$router.push() this.$router.replace() this.$router.go(n)：（0：当前页，-1上一页，+1下一页，n代表整数） 21.vue路由中的history和hash的区别⭐⭐https://blog.csdn.net/weixin_51670675/article/details/124239269 地址栏带不带”#”号hash：http://localhost:8080/#/history:http://localhost:8080/ 都是利用浏览器的两种特性实现前端路由history是利用浏览历史记录栈的API实现hash是监听location对象hash值变化事件来实现 history会触发添加到浏览器历史记录栈中，hash不会触发 history需要后端配合，如果后端不配合刷新页面会出现404，hash不需要 hashRouter原理：通过window.onhashchange获取url中hash值historyRouter原理：通过history.pushState,使用它做页面跳转不会触发页面刷新，使用window.onpopstate监听浏览器的前进和后退 Vuex的理解及使用场景https://blog.csdn.net/weixin_45215308/article/details/121338505 Vuex其实就是一个状态管理工具，所谓的状态，就是数据，通过这个工具进行管理某些数据。当多个组件都需要同一个数据时，可以将这个数据交给Vuex进行统一的管理，组件可以直接引用这个数据，避免了组件间繁琐的层层传递的情况。 vuex 作为数据存储中心 1、组件之间全局共享的数据 2、通过后端异步请求的数据 Vuex 的状态存储是响应式的；当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation， 这样使得我们可以方便地跟踪每一个状态的变化 Vuex主要包括以下5个核心模块： State：定义了应用的状态数据 储存数据类似data Getter：在 store 中定义“getter”（可以认为是 store 的计算属性）， 对数据进行一些运算，但不能改变state的值，类似computed。 就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来， 且只有当它的依赖值发生了改变才会被重新计算 Mutation：是唯一更改 store 中状态的方法，且必须是同步函数 唯一更新方法，响应式的, 当state中的数据发生改变时, Vue组件会自动更新.同步方法 Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作 用户的各种操作，代替Mutation进行异步操作 Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中 构成: state:vuex的基本数据，用来存储变量，存放的数据是响应式的。 mutations:提交更改数据，同步更新状态。 actions:提交mutations，可异步操作。 getters：是store的计算属性。 modules:模块，每个模块里面有四个属性。 ？关于VUEX如何使用可以看VUE的传值问题 讲讲Vuex的使用方法https://www.jianshu.com/p/dcbaceb4464e 1234567891011121314const store = new Vuex.Store(&#123; state: &#123;num: 2&#125;, // 存放数据 getters: &#123;&#125;, // 计算属性 mutations: &#123;&#125;, // 修改state中数据的一些方法 actions: &#123;&#125;, // 异步方法 modules: &#123;&#125; // store模块&#125;)export default store---------------------&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; $store.state.num &#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt; 如何解决vuex页面刷新数据丢失问题？⭐⭐原因：因为vuex里的数据是保存在运行内存中的，当页面刷新时，页面会重新加载vue实例，vuex里面的数据就会被清空。解决方法：将vuex中的数据直接保存到浏览器缓存中。（一般是用sessionStorage） mixin (Vue2) es6: 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口 Vuex的store注入 vue的实例组件的方式，是通过vue的 mixin机制，借助vue组件的生命周期钩子beforeCreate 完成的。这样Vue组件就能通过this.$store获取到store了。 项目变得复杂的时候，多个组件间有重复的逻辑就会用到mixin多个组件有相同的逻辑，抽离出来mixin并不是完美的解决方案，会有一些问题vue3提出的Composition API旨在解决这些问题【追求完美是要消耗一定的成本的，如开发成本】场景：PC端新闻列表和详情页一样的右侧栏目，可以使用mixin进行混合劣势：1.变量来源不明确，不利于阅读 2.多mixin可能会造成命名冲突 3.mixin和组件可能出现多对多的关系，使得项目复杂度变高 v-show和v-if的区别⭐v-if:组件的销毁和重建，更适合带有权限的操作，切换开大。如果开始条件为false则什么都不做，只有为true才会编译。v-show:css切换，隐藏显示更适合频繁切换。在任何情况下都会被编译，然后被缓存，而且dom元素会被保留。 vue2中数据变了但是视图不更新怎么解决？⭐原因： 数组数据变动：使用某些方法操作数组，变动数据时，有些方法无法被vue监测。 Vue 不能检测到对象属性的添加或删除。只有在data里初始化的数据才是响应的 异步更新队列：数据第一次的获取到了，也渲染了，但是第二次之后数据只有在再一次渲染页面的时候更新，并不能实时更新。 解决属性：使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上 Vue.set(vm.someObject, ‘b’, 2) 或者 this.$set(this.someObject,’b’,2) （这也是全局 Vue.set 方法的别名） Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。 在v-for里面数据层次太多，render函数没有自动更新，需手动强制刷新 1vm.$forceUpdate() 解决办法： 可在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数在 DOM 更新完成后就会调用 object.assign方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，并返回目标对象。 动态改变数据后渲染的很慢或者不渲染 ​ 可在动态改变数据的方法，第一行加上 1this``.$forceUpdate(); vue中data为什么是函数而不是对象？⭐⭐官网中有这么一段介绍，详情可以看组件的复用 意思就是，在Vue中组件是可以被复用的，而当data是一个函数的时候，每一个实例的data都是独立的，不会相互影响了。 vue中父子组件传值，父组件异步请求，子组件不能实时更新怎么解决？（vue中数据不能实时更新怎么解决？）⭐⭐⭐首先了解父子组件生命周期执行顺序 &#x3D;&#x3D;&gt;加载渲染数据过程父组件 beforeCreate –&gt;父组件 created –&gt;父组件 beforeMount –&gt;子组件 beforeCreate –&gt;子组件 created –&gt;子组件 beforeMount –&gt;子组件 mounted –&gt;父组件 mounted原因：因为生命周期只会执行一次，数据是要等到异步请求以后才能拿到，那么子组件的mounted钩子执行的时候，还没有拿到父组件传递过来的数据，但是又必须要打印出来结果，那这样的话，就只能去打印props中的默认值空字符串了，所以打印的结果是一个空字符串。解决办法： 使用v-if控制组件渲染的时机初始还没拿到后端接口的异步数据的时候，不让组件渲染，等拿到的时候再去渲染组件。使用v-if&#x3D;”变量”去控制，初始让这个变量为false，这样的话，子组件就不会去渲染，等拿到数据的时候，再让这个变量变成true，举例： 123456789101112data() &#123; return &#123; isTrue:false // 初始为false &#125;; &#125;, monted()&#123; this.$post.a.b.c.getData(res=&gt;&#123; if(res.result)&#123; this.isTrue = true &#125; &#125;) &#125; 使用watch监听数据的变化 1234567891011props: &#123; tableData: &#123; type: Array, default: [], &#125;, &#125;, watch: &#123; tableData(val)&#123; console.log(val) &#125; &#125;, 使用VueX -? 父子组件传参emit如何传多个参数？⭐子组件： 123submit()&#123; this.$emit(&#x27;g&#x27;,1,2,3,4,5)&#125; 父组件 123g(val1,val2,val3,val4,val5) &#123; console.log(val1,val2,val3,val4,val5)&#125; Vue 2和vue3的区别？⭐⭐⭐双向数据绑定原理不同Vue2 的双向数据绑定是利用Object.definePropert() 对数据进行劫持，结合发布订阅模式的方式来实现的。Vue3 中使用Proxy API对数据代理。 API 类型不同Vue2 使用选项类型api。Vue3 使用合成型api。 定义数据变量和方法不同Vue2是把数据放到了data 中。Vue3 就需要使用一个新的setup()方法。 生命周期不同父子传参不同指令与插槽不同是否支持碎片Vue2 不支持碎片。Vue3 支持碎片，可以拥有多个根节点 Props 的传递方式： Vue 2：在 Vue 2 中，父组件通过 props 将数据传递给子组件。子组件需要声明接收这些数据的属性，并使用这些属性来接收数据。 Vue 3：在 Vue 3 中，父组件仍然使用 props 将数据传递给子组件，但子组件不再需要声明接收属性的具体形式。子组件可以直接访问传递给它的属性的值。 动态数据的处理： Vue 2：在 Vue 2 中，如果父组件向子组件传递动态更新的数据，子组件需要使用 this.$set 方法来更新子组件内部的数据。 Vue 3：在 Vue 3 中，父组件传递给子组件的数据会自动响应式更新。子组件不需要手动调用 this.$set 方法来更新数据。 TypeScript 支持： Vue 2：Vue 2 本身不支持 TypeScript，但可以通过额外的库进行类型检查。 Vue 3：Vue 3 本身支持 TypeScript，并且提供了更好的类型推断和类型检查功能。 vue3的变化（改进）响应式方面 vue3的响应式是基于Proxy来实现的，利用代理来拦截对象的基本操作，配合Refelect.*方法来完成响应式的操作。 书写方面 提供了setup的方式，配合组合式API，可以建立组合逻辑、创建响应式数据、创建通用函数、注册生命周期钩子等。 diff算法方面： 在vue2中使用的是双端diff算法：是一种同时比较新旧两组节点的两个端点的算法（比头、比尾、头尾比、尾头比）。一般情况下，先找出变更后的头部，再对剩下的进行双端diff。 在vue3中使用的是快速diff算法：它借鉴了文本diff算法的预处理思路，先处理新旧两组节点中相同的前置节点和后置节点。当前置节点和后置节点全部处理完毕后，如果无法通过简单的挂载新节点或者卸载已经不存在的节点来更新，则需要根据节点间的索引关系，构造出一个最长递增子序列。最长递增子序列所指向的节点即为不需要移动的节点。 编译上的优化 vue3新增了PatchFlags来标记节点类型（动态节点收集与补丁标志），会在一个Block维度下的vnode下收集到对应的dynamicChildren（动态节点），在执行更新时，忽略vnode的children，去直接找到动态节点数组进行更新，这是一种高效率的靶向更新。 vue3提供了静态提升方式来优化重复渲染静态节点的问题，结合静态提升，还对静态节点进行预字符串化，减少了虚拟节点的性能开销，降低了内存占用。 vue3会将内联事件进行缓存，每次渲染函数重新执行时会优先取缓存里的事件 为什么vue3不继续用$set？⭐$set的作用： 在vue2.0中：使用对象和数组来定义数据，当需要向对象或数组中新增一个属性或元素，并希望它在更新 View 时响应式地更新，就需要使用 $set方法来完成。原理无法深层监听vue2是用object.definedProperty来实现数据响应的，无法监听深层数据的变化。 Vue3 中使用Proxy对数据代理通过ref和reactive将值和对象类型变为响应式对象，这样对它的修改和添加就能被vue捕获到，从而实现页面的自动刷新。 参考官网响应式基础 组件封装注意事项 尽可能低耦合，组件之间的依赖越小越好比如不要直接修改父组件状态。 最好从父级传入所需信息，不要在公共组件中请求数据 传入数据添加校验 处理事件的方法写在父组件中 易用性 拓展性 可维护性 可重用性 一个封装组件提供 props 控制其行为而不是暴露其内部结构。"},{"title":"css","path":"/undefined/css/","content":"HTML5 新特性、语义化 概念： HTML5的语义化指的是合理正确的使用语义化的标签来创建页面结构。【正确的标签做正确的事】 语义化标签： header nav main article section aside footer 语义化的优点: 在没CSS样式的情况下，页面整体也会呈现很好的结构效果 代码结构清晰，易于阅读， 利于开发和维护 方便其他设备解析（如屏幕阅读器）根据语义渲染网页。 有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重 HTML5新特性有哪些 语义化标签 音视频处理API(audio,video) canvas &#x2F; webGL 拖拽释放(Drag and drop) API history API requestAnimationFrame 地理位置(Geolocation)API webSocket web存储 localStorage、SessionStorage 表单控件，calendar、date、time、email、url、search CSS 选择器及优先级选择器 id选择器(#myid) 类选择器(.myclass) 属性选择器(a[rel&#x3D;”external”]) 伪类选择器(a:hover, li:nth-child) 标签选择器(div, h1,p) 相邻选择器（h1 + p） 子选择器(ul &gt; li) 后代选择器(li a) 通配符选择器(*) 优先级： !important 内联样式（1000） ID选择器（0100） 类选择器&#x2F;属性选择器&#x2F;伪类选择器（0010） 元素选择器&#x2F;伪元素选择器（0001） 关系选择器&#x2F;通配符选择器（0000） 带!important 标记的样式属性优先级最高； 样式表的来源相同时：!important &gt; 行内样式 &gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性 权重叠加计算之间不存在进位 先比较第一级数字，如果比较出来了，之后的统统不看 如果第一级数字相同，此时再去比较第二级数字，如果比较出来了，之后的统统不看 … 如果最终所有数字都相同，表示优先级相同，则比较层叠性(谁写在下面，谁说了算! 渐进增强与优雅降级的理解及区别渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。 优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。两者区别1、广义：其实要定义一个基准线，在此之上的增强叫做渐进增强，在此之下的兼容叫优雅降级2、狭义：渐进增强一般说的是使用CSS3技术，在不影响老浏览器的正常显示与使用情形下来增强体验，而优雅降级则是体现html标签的语义，以便在js&#x2F;css的加载失败&#x2F;被禁用时，也不影响用户的相应功能。 1234567891011121314/* 例子 */.transition &#123; /*渐进增强写法*/ -webkit-transition: all .5s; -moz-transition: all .5s; -o-transition: all .5s; transition: all .5s;&#125;.transition &#123; /*优雅降级写法*/ transition: all .5s; -o-transition: all .5s; -moz-transition: all .5s; -webkit-transition: all .5s;&#125; 常见的兼容性问题 不同浏览器的标签默认的margin和padding不一样。*{margin:0;padding:0;} IE6双边距bug：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大。hack：display:inline;将其转化为行内属性。 设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度。hack：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。 Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。 超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了。解决方法是改变CSS属性的排列顺序:L-V-H-A ( love hate ): a:link {} a:visited {} a:hover {} a:active {} CSS3新特性 过渡 12/*所有属性从原始值到制定值的一个过渡，运动曲线ease,运动时间0.5秒*/ transition：all,.5s 动画 123//animation：动画名称，一个周期花费时间，运动曲线（默认ease），动画延迟（默认0），播放次数（默认1），是否反向播放动画（默认normal），是否暂停动画（默认running）/*执行一次logo2-line动画，运动时间2秒，运动曲线为 linear*/animation: logo2-line 2s linear; 形状转换 12345//transform:适用于2D或3D转换的元素//transform-origin：转换元素的位置（围绕那个点进行转换）。默认(x,y,z)：(50%,50%,0) 必须配合transform使用transform:translate(30px,30px);transform:rotate(30deg);transform:scale(.8); //放大 选择器:nth-of-type() 阴影文字阴影: text-shadow: 2px 2px 2px #000;(水平阴影，垂直阴影，模糊距离，阴影颜色) 盒子阴影: box-shadow: 10px 10px 5px #999 边框 border-image: url(border.png); 背景 文字 渐变 Filter（滤镜） 弹性布局、栅格布局、多列布局 媒体查询 position 属性的值有哪些及其区别固定定位 fixed： 元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed 定 位使元素的位置与文档流无关，因此不占据空间。 Fixed 定位的元素和其他元素重叠。 相对定位 relative： 如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直 或水平位置，让这个元素“相对于”它的起点进行移动。 在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 绝对定位 absolute： 绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠。 粘性定位 sticky： 元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。 默认定位 Static： 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声 明）。 inherit: 规定应该从父元素继承 position 属性的值。 可以说，fixed是相对于整个视口&#x2F;浏览器窗口的定位，而sticky是相对于其父元素或视口的定位。https://zhuanlan.zhihu.com/p/492456125?utm_id=0 box-sizing属性box-sizing 规定两个并排的带边框的框，语法为 box-sizing：content-box&#x2F;border-box&#x2F;inherit content-box：宽度和高度分别应用到元素的内容框，在宽度和高度之外绘制元素的内边距和边框。【标准盒子模型】 border-box：为元素设定的宽度和高度决定了元素的边框盒。【IE 盒子模型】 inherit：继承父元素的 box-sizing 值。 CSS 盒子模型CSS 盒模型本质上是一个盒子，它包括：边距，边框，填充和实际内容。CSS 中的盒子模型包括 IE 盒子模型和标准的 W3C 盒子模型。在标准的盒子模型中，width 指 content 部分的宽度。在 IE 盒子模型中，width 表示 content+padding+border 这三个部分的宽度。 故在计算盒子的宽度时存在差异： 标准盒模型： 一个块的总宽度 &#x3D; width+margin(左右)+padding(左右)+border(左右) 怪异盒模型： 一个块的总宽度 &#x3D; width+margin（左右）（既 width 已经包含了 padding 和 border 值） BFC（块级格式上下文）BFC的概念 BFC 是 Block Formatting Context 的缩写，即块级格式化上下文。BFC是CSS布局的一个概念，是一个独立的渲染区域，规定了内部box如何布局， 并且这个区域的子元素不会影响到外面的元素，其中比较重要的布局规则有内部 box 垂直放置，计算 BFC 的高度的时候，浮动元素也参与计算。 BFC的原理布局规则 内部的Box会在垂直方向，一个接一个地放置 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠（塌陷） 每个元素的margin box的左边， 与包含块border box的左边相接触(□■这么放)(对于从左往右的格式化，否则相反 BFC的区域不会与float box重叠(原因在下一条) BFC是一个独立容器，容器里面的子元素不会影响到外面的元素 计算BFC的高度时，浮动元素也参与计算高度 元素的类型和display属性，决定了这个Box的类型。不同类型的Box会参与不同的Formatting Context。 如何创建BFC？(在某些情况下，特定的CSS属性值会使元素自动创建BFC) 根元素，即HTML元素 (每当浏览器遇到一个HTML文档时，它会自动创建一个BFC，这个BFC包含了整个HTML文档的内容) float的值不为none position为absolute或fixed display的值为inline-block (指定对象为内联块元素)、table-cell (指定对象作为表格单元个,类似td)、table-caption (指定对象作为表格标题。类同于html标签caption) overflow的值不为visible 常用方式：display:flow-root或overflow: hidden display：inline-block与overflow: hidden都可以开启BFC，但原理不同，inline-block会形成一行外框把元素包裹起来，所以能形成一个独立区域，解决外边距塌陷问题。但overflow: hidden主要作用于子元素，所以给外边距塌陷的元素加这个属性，不会解决外边距塌陷问题。 BFC的使用场景 去除边距重叠现象 清除浮动（让父元素的高度包含子浮动元素） 避免某元素被浮动元素覆盖 避免多列布局由于宽度计算四舍五入而自动换行 https://zhuanlan.zhihu.com/p/608145142 让一个元素水平垂直居中（7+5） 水平居中 对于 行内元素 : text-align: center; 对于确定宽度的块级元素： （1）width和margin实现。margin: 0 auto; 绝对定位 （2）绝对定位和margin-left: margin-left: (父width - 子width）&#x2F;2, 前提是父元素position: relative 对于宽度未知的块级元素 （1）table标签配合margin左右auto实现水平居中。使用table标签（或直接将块级元素设值为 display:table），再通过给该标签添加左右margin为auto。 （2）inline-block实现水平居中方法。display：inline-block和text-align:center实现水平居中。 （3）绝对定位+transform，translateX可以移动本身元素的50%。 （4）flex布局使用justify-content:center 垂直居中（要么line要么父子） 利用 line-height 实现居中，这种方法适合纯文字类 子级设置 绝对定位+calc(50%-100px)计算 弹性布局 flex :父级设置display: flex; 子级设置margin为auto实现自适应居中 父级设置相对定位，子级设置绝对定位，并且通过位移 transform 实现 table 布局，父级通过转换成表格形式，然后子级设置 vertical-align 实现。（需要注意的是：vertical-align: middle使用的前提条件是内联元素以及display值为table-cell的元素）。 传送门 ☞ # 图解CSS水平垂直居中常见面试方法（一定要点开） 隐藏页面中某个元素的方法1.opacity：0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定 一些事件，如click 事件，那么点击该区域，也能触发点击事件的 2.visibility：hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已 经绑定的事件 ，隐藏对应元素，在文档布局中仍保留原来的空间（重绘） 3.display：none，不占据空间 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素。 不显示对应的元素，在文档布局中不再分配空间（回流+重绘） 该问题会引出 回流（改变元素的位置、显示隐藏元素）和重绘 4.也可以用left: -9999px或者transform: translateX(-9999px);将元素移出视口外部。 用CSS实现三角符号盒子宽高均为零，三面边框皆透明 1234567891011div&#123; width: 0px; height: 0px; (border: 10px（以这个决定大小） solid; border-color: white white red white;) border-right: 100px solid transparent; border-top: 100px solid #ff0; border-left: 100px solid transparent; border-bottom: 100px solid transparent;&#125; 页面布局1.Flex 布局布局的传统解决方案，基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 Flex 是 Flexible Box 的缩写，意为”弹性布局”,用来为盒状模型提供最大的灵活性。指定容器 display: flex 即可。 简单的分为容器属性和元素属性。 容器的属性： flex-direction：决定主轴的方向（即子 item 的排列方法）flex-direction: row | row-reverse | column | column-reverse; flex-wrap：决定换行规则 flex-wrap: nowrap | wrap | wrap-reverse; flex-flow： .box { flex-flow: || ; } justify-content：对其方式，水平主轴对齐方式 align-items：对齐方式，竖直轴线方向 align-content flex: 1 ，它具体包含了以下的意思： flex-grow: 1 ：该属性默认为 0 ，如果存在剩余空间，元素也不放大。设置为 1 代表会放大。 flex-shrink: 1 ：该属性默认为 1 ，如果空间不足，元素缩小。 flex-basis: 0% ：该属性定义在分配多余空间之前，元素占据的主轴空间。浏览器就是根据这个属性来计算是否有多余空间的。默认值为 auto ，即项目本身大小。设置为 0% 之后，因为有 flex-grow 和 flex-shrink 的设置会自动放大或缩小。在做两栏布局时，如果右边的自适应元素 flex-basis 设为 auto 的话，其本身大小将会是 0 。 项目的属性（元素的属性）： order 属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为 0 flex-grow 属性：定义项目的放大比例，即使存在空间，也不会放大 flex-shrink 属性：定义了项目的缩小比例，当空间不足的情况下会等比例的缩小，如果 定义个 item 的 flow-shrink 为 0，则为不缩小 flex-basis 属性：定义了在分配多余的空间，项目占据的空间。 flex：是 flex-grow 和 flex-shrink、flex-basis 的简写，默认值为 0 1 auto。 align-self：允许单个项目与其他项目不一样的对齐方式，可以覆盖 align-items，默认属 性为 auto，表示继承父元素的 align-items 比如说，用 flex 实现圣杯布局 2.Rem 布局首先 Rem 相对于根(html)的 font-size 大小来计算。简单的说它就是一个相对单例 如:font-size:10px;,那么（1rem &#x3D; 10px）了解计算原理后首先解决怎么在不同设备上设置 html 的 font-size 大小。其实 rem 布局的本质是等比缩放，一般是基于宽度。 优点：可以快速适用移动端布局，字体，图片高度 缺点： ①目前 ie 不支持，对 pc 页面来讲使用次数不多；②数据量大：所有的图片，盒子都需要我们去给一个准确的值；才能保证不同机型的适配；③在响应式布局中，必须通过 js 来动态控制根元素 font-size 的大小。也就是说 css 样式和 js 代码有一定的耦合性。且必须将改变 font-size 的代码放在 css 样式之前。 3.百分比布局通过百分比单位 “ % “ 来实现响应式的效果。通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。 直观的理解，我们可能会认为子元素的百分比完全相对于直接父元素，height 百分比相 对于 height，width 百分比相对于 width。 padding、border、margin 等等不论是垂直方向还是水平方向，都相对于直接父元素的 width。 除了 border-radius 外，还有比如 translate、background-size 等都是相对于自身的。 缺点： （1）计算困难（2）各个属性中如果使用百分比，相对父元素的属性并不是唯一的。造成我们使用百分比单位容易使布局问题变得复杂。 4.浮动布局浮动布局:当元素浮动以后可以向左或向右移动，直到它的外边缘碰到包含它的框或者另外一个浮动元素的边框为止。元素浮动以后会脱离正常的文档流，所以文档的普通流中的框就变的好像浮动元素不存在一样。 优点 这样做的优点就是在图文混排的时候可以很好的使文字环绕在图片周围。另外当元素浮动了起来之后，它有着块级元素的一些性质例如可以设置宽高等，但它与inline-block还是有一些区别的，第一个就是关于横向排序的时候，float可以设置方向而inline-block方向是固定的；还有一个就是inline-block在使用时有时会有空白间隙的问题 缺点 高度塌陷最明显的缺点就是浮动元素一旦脱离了文档流，就无法撑起父元素，会造成父级元素高度塌陷。 两栏布局（左侧固定 + 右侧自适应布局） 现在有以下 DOM 结构： 1&lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;left&quot;&gt;左侧&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右侧&lt;/div&gt; &lt;/div&gt; 利用浮动，左边元素宽度固定 ，设置向左浮动。将右边元素的 margin-left 设为固定宽度 。注意，因为右边元素的 width 默认为 auto ，所以会自动撑满父元素。 1234567891011121314 .outer &#123; height: 100px;&#125; .left &#123; float: left; width: 200px; height: 100%; background: lightcoral; &#125; .right &#123; margin-left: 200px; height: 100%; background: lightseagreen; &#125; 同样利用浮动，左边元素宽度固定 ，设置向左浮动。右侧元素设置 overflow: hidden; 这样右边就触发了 BFC ，BFC 的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。 123.outer &#123; height: 100px; &#125; .left &#123; float: left; width: 200px; height: 100%; background: lightcoral; &#125; .right &#123; overflow: auto; height: 100%; background: lightseagreen; &#125; 利用 flex 布局，左边元素固定宽度，右边的元素设置 flex: 1 。 123.outer &#123; display: flex; height: 100px; &#125; .left &#123; width: 200px; height: 100%; background: lightcoral; &#125; .right &#123; flex: 1; height: 100%; background: lightseagreen; &#125; 利用绝对定位，父级元素设为相对定位。左边元素 absolute 定位，宽度固定。右边元素的 margin-left 的值设为左边元素的宽度值。 123.outer &#123; position: relative; height: 100px; &#125; .left &#123; position: absolute; width: 200px; height: 100%; background: lightcoral; &#125; .right &#123; margin-left: 200px; height: 100%; background: lightseagreen; &#125; 利用绝对定位，父级元素设为相对定位。左边元素宽度固定，右边元素 absolute 定位， left 为宽度大小，其余方向定位为 0 。 123.outer &#123; position: relative; height: 100px; &#125; .left &#123; width: 200px; height: 100%; background: lightcoral; &#125; .right &#123; position: absolute; left: 200px; top: 0; right: 0; bottom: 0; height: 100%; background: lightseagreen; &#125; 圣杯布局和双飞翼布局（经典三分栏布局） 圣杯布局和双飞翼布局的目的： 三栏布局，中间一栏最先加载和渲染（内容最重要，这就是为什么还需要了解这种布局的原因）。 两侧内容固定，中间内容随着宽度自适应。 一般用于 PC 网页。 圣杯布局和双飞翼布局的技术总结： 使用 float 布局。 两侧使用 margin 负值，以便和中间内容横向重叠。 防止中间内容被两侧覆盖，圣杯布局用 padding ，双飞翼布局用 margin 。 圣杯布局：12345 &lt;div id=&quot;container&quot; class=&quot;clearfix&quot;&gt; &lt;p class=&quot;center&quot;&gt;我是中间&lt;/p&gt; &lt;p class=&quot;left&quot;&gt;我是左边&lt;/p&gt; &lt;p class=&quot;right&quot;&gt;我是右边&lt;/p&gt; &lt;/div&gt; 1234567891011121314151617181920212223242526272829#container &#123; padding-left: 200px; padding-right: 150px; overflow: auto; &#125; #container p &#123; float: left; &#125; .center &#123; width: 100%; background-color: lightcoral; &#125; .left &#123; width: 200px; position: relative; left: -200px; margin-left: -100%; background-color: lightcyan; &#125; .right &#123; width: 150px; margin-right: -150px; background-color: lightgreen;&#125; .clearfix:after &#123; content: &quot;&quot;; display: table; clear: both; &#125; 其它方式： 1、margin+浮动 css代码： html： 效果图： 2、flex布局 css： ​ html： 3、定位 html： 总结：圣杯布局主要是固定左右两列，中间自适应，flex最容易实现 双飞翼布局：12345 &lt;div id=&quot;main&quot; class=&quot;float&quot;&gt; &lt;div id=&quot;main-wrap&quot;&gt;main&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;left&quot; class=&quot;float&quot;&gt;left&lt;/div&gt; &lt;div id=&quot;right&quot; class=&quot;float&quot;&gt;right&lt;/div&gt; 123456789101112131415161718192021222324.float &#123; float: left; &#125; #main &#123; width: 100%; height: 200px; background-color: lightpink; &#125; #main-wrap &#123; margin: 0 190px 0 190px; &#125; #left &#123; width: 190px; height: 200px; background-color: lightsalmon; margin-left: -100%;&#125; #right &#123; width: 190px; height: 200px; background-color: lightskyblue; margin-left: -190px; //或者maigin-right:-100%&#125; tips：上述代码中 margin-left: -100% 相对的是父元素的 content 宽度，即不包含 paddig 、 border 的宽度。 其实以上问题需要掌握 margin 负值问题 即可很好理解。 设置左右margin负值会增加元素的宽度 （该元素没有设定width属性或width:auto） margin-top设置负值不会增加元素高度，只会产生向上的位移 -margin-bottom设置负值不会产生位移，只会减小元素供CSS读取的高度 负边距对由普通文档流控制的元素的作用是，会使它们在文档流中的位置发生偏移，这种偏移不同于相对定位（通过相对定位偏移后的元素仍然会坚守着它原来占据的空间，不会让文档流的其它元素乘虚而入），通过负边距进行偏移的元素，它会放弃偏移前占据的空间，这样它后面文档流中的其它元素就会“流”过来填充这部分空间。文档流只能是后面的流向前面的，即文档流只能向左或向上流动，不能向下或向右移动 如何使用rem或viewport进行移动端适配rem适配原理： 改变了一个元素在不同设备上占据的css像素的个数 rem适配的优缺点 优点：没有破坏完美视口 缺点：px值转换rem太过于复杂(下面我们使用less来解决这个问题) viewport适配的原理 viewport适配方案中，每一个元素在不同设备上占据的css像素的个数是一样的。但是css像素和物理像素的比例是不一样的，等比的 viewport适配的优缺点 在我们设计图上所量取的大小即为我们可以设置的像素大小，即所量即所设 缺点破坏完美视口 浮动脱离标准流，不占位置，在标准流排版分为水平（行内+行内块级）和垂直（块级），而浮动流排版只有水平排版方式，只能设置某个元素左对齐或者右对齐，没有居中对齐，所以不可以使用margin：0 auto了 水平排版，可设置宽高 浮动元素具有贴靠现象，如果父元素的宽度足以显示所有的浮动元素，那么浮动的元素会并排显示，若宽度不足，会从最后一个元素开始往前贴靠，如果都空间不足，就会换行贴靠在父元素的左边或者右边 具有字围现象，浮动元素不会挡住没有浮动元素中的文字, 没有浮动的文字会自动给浮动的元素让位置,实现文字环绕图片的效果 清除浮动的方式 添加额外标签 12345&lt;div class=&quot;parent&quot;&gt; //添加额外标签并且添加clear属性 &lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt; //也可以加一个br标签&lt;/div&gt; 父级添加overflow属性，或者设置高度 建立伪类选择器清除浮动 12345678910111213//在css中添加:after伪元素.parent:after&#123; /* 设置添加子元素的内容是空 */ content: &#x27;&#x27;; /* 设置添加子元素为块级元素 */ display: block; /* 设置添加的子元素的高度0 */ height: 0; /* 设置添加子元素看不见 */ visibility: hidden; /* 设置clear：both */ clear: both;&#125; overflow：hidden的三个作用：1.超出部分隐藏2.清除浮动3.解决外边距塌陷问题，给父元素设置o：h，子元素设置margin-top之后，父元素不会被顶下来 CSS预处理器Sass、Less、Stylus的区别什么事CSS预处理器? CSS预处理器是一种语言用来为CSS增加一些变成的特性，无需考虑浏览器兼容问题，例如你可以在CSS中使用变量，简单的程序逻辑、函数等在编程语言中的一些基本技巧，可以让CSS更加简洁，适应性更强，代码更直观等诸多好处基本语法区别 Sass是以.sass为扩展名，Less是以.less为扩展名，Stylus是以.styl为扩展名变量的区别 Sass 变量必须是以$开头的，然后变量和值之间使用冒号（：）隔开，和css属性是一样的。Less 变量是以@开头的，其余sass都是一样的。Stylus 对变量是没有任何设定的，可以是以$开头或者任意字符，而且变量之间可以冒号，空格隔开，但是在stylus中不能用@开头三种预处理器都有：嵌套、运算符、颜色函数、导入、继承、混入。Stylus还有一些高级特性。例如循环、判断等 高度重叠https://blog.csdn.net/Celester_best/article/details/127455732 调整父子的padding clearfix 123456.clearfix::before,.clearfix::after&#123; content:&quot;&quot;; display:table; clear:both;&#125; 高度塌陷(h&#x3D;0)BFC after伪元素结合clear 1234567891011121314151617 &lt;div class=&quot;div1&quot;&gt; &lt;div class=&quot;div2&quot;&gt;&lt;/div&gt; &lt;/div&gt; .div1&#123; border:10px solid red; &#125; .div2&#123; width:100px; height:100px; background-color:green; float:left; &#125; .div1::after&#123; content:&quot;&quot;;/*在浮动元素的父元素内容区最后加上内容*/ display:block;/*默认情况下after所添加的内容为行内元素*/ clear:both;/*清除浮动元素影响*/ &#125; clearfix 123456.clearfix::before,.clearfix::after&#123; content:&quot;&quot;; display:table; clear:both;&#125;"},{"title":"js","path":"/undefined/js/","content":"JS中的数据类型及区别包括值类型(基本对象类型)和引用类型(复杂对象类型) 基本类型(值类型)： Number(数字),String(字符串),Boolean(布尔),null(空),undefined(未定义),Symbol(符号),BigInt在内存中占据固定大小，保存在栈内存中 引用类型(复杂数据类型)： Object(对象)、Function(函数)。其他还有Array(数组)、Date(日期)、RegExp(正则表达式)、特殊的基本包装类型(String、Number、Boolean) 以及单体内置对象(Global、Math)等 引用类型的值是对象 保存在堆内存中，栈内存存储的是对象的变量标识符以及对象在堆内存中的存储地址。 使用场景： **Symbol(es6)**：使用Symbol来作为对象属性名(key) 利用该特性，把一些不需要对外操作和访问的属性使用Symbol来定义。 使用Symbol来作为对象属性名(key) 使用Symbol来替代常量 使用Symbol定义类的私有属性&#x2F;方法 **BigInt(es10)**：是一种数字类型的数据，它可以表示任意精度格式的整数。由于在 Number 与 BigInt 之间进行转换会损失精度，因而建议仅在值可能大于253 时使用 BigInt 类型，并且不在两种类型之间进行相互转换。为了与 Number 类型进行区分，BigInt 类型的数据必须添加后缀n。12n + 1n -&gt; 13n 传送门 ☞# JavaScript 数据类型之 Symbol、BigInt 123456789101112131415let a = Symbol()console.log(a.constructor)//function Symbol()console.log(a.constructor.prototype)//Object [Symbol] &#123;&#125;console.log(a.prototype) //undefined 因为a是对象console.log(a)//Symbol()let b = Symbol()console.log(a === b / a == b)// false console.log(a.constructor === b.constructor);//true//创建两个可以相等的变量let a = Symbol.for(&#x27;q&#x27;);let b = Symbol.for(&#x27;q&#x27;);console.log(a);//Symbol(&#x27;q&#x27;)console.log(a === b);//true/*Symbol.for(key) 方法会根据给定的键 key(字符串)，来从运行时的 symbol 注册表中找到对应的 symbol，如果找到了，则返回它，否则，新建一个与该键关联的 symbol，并放入全局 symbol 注册表中。*/ 123456789let a = BigInt(Math.pow(2,53))+1n;console.log(a === Math.pow(2,53));//falselet a = Math.pow(2,53)+1;console.log(a === Math.pow(2,53));//true 精度问题console.log(12n === 12);//false BigInt 与普通整数是两种值，并且不会进行隐式转换console.log(12n.constructor)//function BigInt()console.log(12 .constructor) //function Number() JS中的数据类型检测方案null判断&#x3D;&#x3D;&#x3D; 1.typeof12345678910console.log(typeof 1); // numberconsole.log(typeof true); // booleanconsole.log(typeof &#x27;mc&#x27;); // stringconsole.log(typeof Symbol) // functionconsole.log(typeof function()&#123;&#125;); // functionconsole.log(typeof console.log()); // functionconsole.log(typeof []); // object console.log(typeof &#123;&#125;); // objectconsole.log(typeof null); // objectconsole.log(typeof undefined); // undefined 优点：能够快速区分基本数据类型 缺点：不能将Object、Array和Null区分，都返回object 2.instanceof123456console.log(1 instanceof Number); // falseconsole.log(true instanceof Boolean); // false console.log(&#x27;str&#x27; instanceof String); // false console.log([] instanceof Array); // trueconsole.log(function()&#123;&#125; instanceof Function); // trueconsole.log(&#123;&#125; instanceof Object); // true 优点：能够区分Array、Object和Function，适合用于判断自定义的类实例对象 缺点：Number，Boolean，String基本数据类型不能判断 3.Object.prototype.toString.call()123456789var toString = Object.prototype.toString;console.log(toString.call(1)); //[object Number]console.log(toString.call(true)); //[object Boolean]console.log(toString.call(&#x27;mc&#x27;)); //[object String]console.log(toString.call([])); //[object Array]console.log(toString.call(&#123;&#125;)); //[object Object]console.log(toString.call(function()&#123;&#125;)); //[object Function]console.log(toString.call(undefined)); //[object Undefined]console.log(toString.call(null)); //[object Null] 优点：精准判断数据类型 缺点：写法繁琐不容易记，推荐进行封装后使用 instanceof 的作用用于判断一个引用类型是否属于某构造函数； 还可以在继承关系中用来判断一个实例是否属于它的父类型。 instanceof 和 typeof 的区别：typeof在对值类型number、string、boolean 、null 、 undefined、 以及引用类型的function的反应是精准的；但是，对于对象{ } 、数组[ ] 、null 都会返回object 为了弥补这一点，instanceof 从原型的角度，来判断某引用属于哪个构造函数，从而判定它的数据类型。 如何判断一个数是否数组：Array.isArray()、instanceof、Object.prototype.toString.call() null与undefined区别总的来说 null 和 undefined 都代表空，主要区别在于 undefined 表示尚未初始化的变量的值，而 null 表示该变量有意缺少对象指向（栈中的变量没有指向堆中的内存对象）。 本质、全局 12console.log(typeof null); // objectconsole.log(typeof undefined); // undefined undefined 这个变量从根本上就没有定义 undefined 是 全局对象 的一个属性。也就是说，它是全局作用域的一个变量。undefined 的最初值就是原始数据类型 undefined 。 null 这个值虽然定义了，但它并未指向任何内存中的对象 值 null 是一个字面量（源代码中一个固定值的表示法），不像 undefined ，它不是全局对象的一个属性。null 是表示缺少的标识，指示变量未指向任何对象。把 null 作为尚未创建的对象，也许更好理解。 在 API 中，null 常在返回类型应是一个对象，但没有关联的值的地方使用。 当使用完一个比较大的对象时，需要对其进行释放内存时，设置为null var &amp;&amp; let &amp;&amp; constES6之前创建变量用的是var,之后创建变量用的是let&#x2F;const 三者区别： 作用域、使用-6 var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，且不能修改。 var可以先使用，后声明，因为存在变量提升；let必须先声明后使用。 var是允许在相同作用域内重复声明同一个变量的，而let与const不允许这一现象。 在全局上下文中，基于let声明的全局变量和全局对象GO（window）没有任何关系 ;var声明的变量会和GO有映射关系； 123456var x = 10;console.log(x);//10console.log(window.x);//10 通过window访问全局变量let a = 10;console.log(window.a); //undefined 会产生暂时性死区（TDZ）： 暂时性死区：在代码块内，使用let和const命令声明变量之前，该变量都是不可用的 ES6新增的let、const关键字声明的变量会产生块级作用域，如果变量在当前作用域中被创建之前被创建出来，由于此时还未完成语法绑定(≈关联)，如果我们访问或使用该变量，就会产生暂时性死区(从变量的创建到语法绑定之间这一段空间) 1234567console.log(a); // Uncaught ReferenceError: a is not defined 未定义Uncaught ReferenceError: aconsole.log(a); //Uncaught ReferenceError: can&#x27;t access lexical declaration &#x27;a&#x27; before initialization 未捕获的ReferenceError:在初始化之前无法访问词法声明&#x27;a&#x27;let a = 10;console.log(a);//undefinedvar a = 10; let &#x2F;const&#x2F;function会把当前所在的大括号(除函数之外)作为一个全新的块级上下文，应用这个机制，在开发项目的时候，遇到循环事件绑定等类似的需求，无需再自己构建闭包来存储，只要基于let的块作用特征即可解决 12345let a = 10;console.log(a);//10&#123;let a = 10;&#125;console.log(a);//Uncaught ReferenceError: a is not defined JS实现异步的方法 1，回调函数 2，事件监听 3，promise 4，生成器Generators 5，async&#x2F;await 数组的forEach和map方法有哪些区别？常用哪些方法去对数组进行增、删、改forEach是对数组的每个元素执行一次给定的函数。 map是创建一个新数组,该新数组由原数组的每个元素都调用一次提供的函数返回的值。 123456789let a = new Array(1,2,3,4,5);a.forEach(function(e) &#123; console.log(e);&#125;);// 1 2 3 4 5let mp1 = a.map(x=&gt;&#123; if(x == 1) return 0;&#125;)console.log(mp1);//Array(5) [0,undefined,undefined,undefined,undefined] pop():删除数组后面的最后一个元素,返回值为被删除的那个元素。 push():将一个元素或多个元素添加到数组末尾，并返回新的长度。 shift():删除数组中的第一个元素，并返回被删除元素的值。 unshift():将一个或多个元素添加到数组的开头，并返回该数组的新长度。 splice():通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。 reverse(): 反转数组。 数组合并(中小数据) 普通解构、es6解构、遍历、数组方法、改变指向 es6解构 &gt; concat &gt; push&#x2F;unshift &gt; splice &gt; apply&#x2F;call es6解构，需要接收 1arr = [...arr1, ...arr2] 遍历添加 (map &#x2F; filter &#x2F; every &#x2F; for &#x2F; for in &#x2F; for of) 123arr1.forEach(item=&gt;&#123;\tarr2.push(item)&#125;) concat,生成新数组 1arr1.concat(arr2) join+split 1(arr1.join(&#x27;,&#x27;) + &#x27;,&#x27; + arr2.join(&#x27;,&#x27;)).split(&#x27;,&#x27;) 解构添加 12arr1.push(...arr2)arr1.unshift(...arr2) splice解构 1arr1.splice(arr1.length,&#x27;&#x27;,...arr2) apply &#x2F; call 12345arr1.push.apply(arr1,arr2)arr1.unshift.apply(arr1,arr2)arr1.push.call(arr1,...arr2)arr1.unshift.call(arr1,...arr2) https://blog.csdn.net/tengxi_5290/article/details/124825523 new一个对象的步骤&#x2F;new运算符的使用 空原继承执构造，指这新空显对象 首先创建了一个新的空对象 设置原型，新-空对象的原型指向构造函数的prototype属性（将对象的原型设置为函数的prototype对象），继承构造函数原型上定义的属性和方法 执行构造函数，并将构造函数中的this指向新创建的空对象，以便构造函数内部代码可以操作新对象）（为这个新对象添加属性） 判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。如果构造函数没有显式返回一个对象，则返回这个新对象 使用new关键字创建对象实例时，构造函数内部的属性和方法会在每次创建新实例时都重新创建一次，这可能会导致资源浪费。为了避免这种情况，通常会将共享的方法放在构造函数的prototype上，这样所有实例都可以共享同一份方法（变为永存）。 1234567891011121314function Person(name, age) &#123; this.name = name; this.age = age; this.sayHello = function() &#123; console.log(&#x27;Hello, my name is &#x27; + this.name + &#x27; and I am &#x27; + this.age + &#x27; years old.&#x27;); &#125;;&#125;// 创建一个新的Person对象实例var john = new Person(&#x27;John&#x27;, 30);john.sayHello(); // 输出：Hello, my name is John and I am 30 years old.通过new Person(&#x27;John&#x27;, 30)创建了一个新的Person对象实例。按照上述过程，new关键字创建了一个新的空对象，并将这个空对象的原型指向Person.prototype，然后执行了Person构造函数，并将this指向这个新对象。最后，如果构造函数没有显式返回其他对象，那么就会返回这个新对象。 作用域和作用域链创建函数的时候，已经声明了当前函数的作用域&#x3D;&#x3D;&gt;当前创建函数所处的上下文。如果是在全局下创建的函数就是[[scope]]:EC(G)，函数执行的时候，形成一个全新的私有上下文EC(FN)，供字符串代码执行(进栈执行) 定义：简单来说作用域就是变量与函数的可访问范围，由当前环境与上层环境的一系列变量对象组成1.全局作用域：代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。2.函数作用域：在固定的代码片段才能被访问 作用：作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。 作用域链一般情况下，变量到创建该变量的函数的作用域中取值。但是如果在当前作用域中没有查到，就会向上级作用域去查，直到查到全局作用域，这么一个向上查找过程形成的链条就叫做作用域链。 闭包的两大作用：保存&#x2F;保护 闭包的概念 函数执行会形成的私有上下文EC(FN)，正常情况下，代码执行完会出栈后释放;但是特殊情况下，如果当前私有上下文中的某个东西被上下文以外的事物占用了，则上下文不会出栈释放，从而形成不销毁的上下文。 函数执行函数执行过程中，会形成一个全新的私有上下文，可能会被释放，可能不会被释放，不论释放与否，他的作用是： （1）保护：划分一个独立的代码执行区域，在这个区域中有自己私有变量存储的空间，保护自己的私有变量不受外界干扰（除了主动操作自己的私有变量和外界没有关系）； （2）保存：如果当前上下文不被释放【只要上下文中的某个东西被外部占用即可】，则存储的这些私有变量也不会被释放，可以供其下级上下文中调取使用，相当于把一些值保存起来了； 我们把函数执行形成私有上下文，来保护和保存私有变量机制称为闭包。 闭包是指有权访问另一个函数作用域中的变量的函数–《JavaScript高级程序设计》 稍全面的回答： 在js中变量的作用域属于函数作用域, 在函数执行完后,作用域就会被清理,内存也会随之被回收,但是由于闭包函数是建立在函数内部的子函数, 由于其可访问上级作用域,即使上级函数执行完, 作用域也不会随之销毁, 这时的子函数(也就是闭包),便拥有了访问上级作用域中变量的权限,所以上级函数执行完后作用域内的值不会被销毁。 闭包的特性： 1、内部函数可以访问定义他们外部函数的参数和变量。*(作用域链的向上查找，把外围的作用域中的变量值存储在内存中而不是在函数调用完毕后销毁)*设计私有的方法和变量，避免全局变量的污染。 1.1.闭包是密闭的容器，，类似于set、map容器，存储数据的 1.2.闭包是一个对象，存放数据的格式为 key-value 形式 2、函数嵌套函数 3、本质是将函数内部和外部连接起来。优点是可以读取函数内部的变量，让这些变量的值始终保存在内存中，不会在函数被调用之后自动清除 闭包形成的条件： 函数的嵌套 内部函数引用外部函数的局部变量，延长外部函数的变量生命周期 闭包的用途： 模仿块级作用域 保护外部函数的变量能够访问函数定义时所在的词法作用域(阻止其被回收) 封装私有化变量 创建模块 词法作用域：在编写代码时，代码块（如函数、块级作用域中的变量的可访问范围是由它们在代码中的位置所决定的 包含所有的种类 闭包应用场景 闭包的两个场景，闭包的两大作用：保存/保护。 大部分前端JavaScript 代码都是“事件驱动”的,即一个事件绑定的回调方法; 发送ajax请求成功|失败的回调;setTimeout的延时回调;或者一个函数内部返回另一个匿名函数,这些都是闭包的应用。 闭包的优点：延长局部变量的生命周期 闭包缺点：会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏 解决： 1.能不用闭包就不用 2.及时释放 https://blog.csdn.net/guoao20000915/article/details/125713323 JS 中 this 的情况 window2、函数4、数组1 普通函数调用：通过函数名()直接调用：this指向全局对象window（注意let定义的变量不是window属性，只有window.xxx定义的才是。即let a &#x3D;’aaa’; this.a是undefined） 函数作为window内置函数的回调函数调用：this指向window（如setInterval setTimeout 等） 构造函数调用：函数作为构造函数，用new关键字调用时：this指向新new出的对象 对象函数调用：通过对象.函数名()调用的：this指向这个对象 箭头函数调用：箭头函数里面没有 this ，所以永远是上层作用域this apply和call调用：函数体内 this 的指向的是 call&#x2F;apply 方法第一个参数，若为空默认是指向全局对象window。 函数作为数组的一个元素，通过数组下标调用的：this指向这个数组 call&#x2F;apply&#x2F;bind 的区别相同： 都是用来改变函数的this对象的指向的。 第一个参数都是this要指向的对象。 都可以利用后续参数传参。 不同： apply和call传入的参数列表形式不同。apply 接收 arguments，call接收一串参数列表 12fn.call(obj, 1, 2);fn.apply(obj, [1, 2]); bind：语法和call一模一样，区别在于立即执行还是等待执行 12fn.call(obj, 1, 2); // 改变fn中的this，并且把fn立即执行fn.bind(obj, 1, 2); // 改变fn中的this，指向obj,fn并不执行 bind不兼容IE6~8 bind 主要就是将函数绑定到某个对象，bind()会创建一个函数，返回对应函数便于稍后调用；而apply、call则是立即调用。 总结：基于Function.prototype上的 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。apply接收参数的是数组，call接受参数列表， bind方法通过传入一个对象，返回一个this 绑定了传入对象的新函数。这个函数的 this指向除了使用new 时会被改变，其他情况下都不会改变。若为空默认是指向全局对象window。 参考：☞ call、apply、bind三者的用法和区别 箭头函数的特性 this、参数、属性、继承 书写更简洁 箭头函数没有自己的this，只会从上一级继承this，箭头函数的this指向固定 箭头函数不绑定Arguments 对象。取而代之用rest参数…解决。由于 箭头函数没有自己的this指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数（不能绑定this），他们的第一个参数会被忽略。（这种现象对于bind方法同样成立） 箭头函数通过 call() 或 apply()、bind() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响。（因为他没有自己的this） 箭头函数没有constructor，是匿名函数，不能作为构造函数，不能通过new 调用； 箭头函数不能当做Generator函数,不能使用yield关键字 没有new.target 属性。在通过new运算符被初始化的函数或构造方法中，new.target返回一个指向构造方法或函数的引用。在普通的函数调用中，new.target 的值是undefined 箭头函数没有原型属性 Fn.prototype 值为 undefined 没有super() 参考：箭头函数与普通函数的区别 迭代器(iterator)接口和生成器(generator)函数的关系 ？12345678910111213在JavaScript中，生成器函数是一种特殊的函数，使用 function* 语法定义。生成器函数可以暂停执行并在需要时恢复执行，并使用 yield 语句返回一个值function* simpleGenerator() &#123; yield 1; yield 2; yield 3;&#125;// 使用生成器函数const generator = simpleGenerator();console.log(generator.next().value); // 输出: 1console.log(generator.next().value); // 输出: 2console.log(generator.next().value); // 输出: 3simpleGenerator() 是一个生成器函数，使用 yield 语句生成一系列值。通过调用生成器对象的 next() 方法，可以逐个获取生成器的值。注意，每次调用 next() 方法时，生成器将恢复执行，直到遇到下一个 yield 语句为止。 任意一个对象实现了遵守迭代器协议的[Symbol.iterator]方法，那么该对象就可以调用[Symbol.iterator]返回一个遍历器对象。 生成器函数就是遍历器生成函数，故可以把generator赋值给对象的[Symbol.iterator]属性，从而使该对象具有迭代器接口。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class ClassRoom &#123; constructor(address, name, students) &#123; this.address = address; this.name = name; this.students = students; &#125; entry(student) &#123; this.students.push(student); &#125; *[Symbol.iterator]() &#123; yield* this.students; &#125; // [Symbol.iterator]() &#123; // let index = 0; // return &#123; // next: () =&gt; &#123; // if (index &lt; this.students.length) &#123; // return &#123; done: false, value: this.students[index++] &#125;; // &#125; else &#123; // return &#123; done: true, value: undefined &#125;; // &#125; // &#125;, // return: () =&gt; &#123; // console.log(&quot;iterator has early termination&quot;); // return &#123; done: true, value: undefined &#125;; // &#125;, // &#125;; // &#125;&#125;const classOne = new ClassRoom(&quot;7-101&quot;, &quot;teach-one-room&quot;, [&quot;rose&quot;, &quot;jack&quot;, &quot;lily&quot;, &quot;james&quot;]);for (const stu of classOne) &#123; console.log(&quot;stu :&gt;&gt; &quot;, stu); // stu :&gt;&gt; rose // stu :&gt;&gt; jack // stu :&gt;&gt; lily // stu :&gt;&gt; james // if (stu === &quot;lily&quot;) return;&#125; 原型 &amp;&amp; 原型链p162 原型链：利用原型让一个引用类型继承另一个引用类型的属性和方法 可instanceof判断 原型关系： 每个 class都有显示原型 prototype 每个实例都有隐式原型 __proto__ 实例的 __proto__ 指向对应 class 的 prototype __proto__指向的是当前对象的原型对象，而prototype指向的，是以当前函数作为构造函数构造出来的对象的原型对象。 一、原型prototype是function对象下的属性，是一个父子级的关系，也就是说子对象会继承父对象的方法和属性，其中prototype是函数下的属性，而constructor是指向构造函数的。 二、原型链proto，是每个实例对象下都有的属性，通过属性__proto__指向构造函数的原型对象。 需要注意的是：prototype是函数特有的，__proto__是对象有的。 123456789101112131415161718192021//在JavaScript的世界中，所有的函数都能作为构造函数，构造出一个对象 //下面我给自己构造一个女朋友 function GirlFriend () &#123; this.name = &quot;Alice&quot;; &#125; //现在我设置GirlFriend()这个函数的prototype属性 //一般来说直接用匿名的对象就行，我这里是为了方便理解， //先定义一个hand对象再把hand赋值给GirlFriend()的prototype var hand = &#123; whichOne: &quot;right hand&quot;, someFunction: function()&#123; console.log(&quot;not safe for work.&quot;); &#125; &#125;; GirlFriend.prototype = hand; //这个时候，我们可以用GirlFriend()作为构造函数，构造出myObject对象 var myObject = new GirlFriend(); console.log(myObject.__proto__ === GirlFriend.prototype) //true/* 我们构建了一个女神对象myObject，而 myObject 的原型是 hand 对象，而刚好 myObject 的构造函数GirlFriend()的 prototype 属性也指向 hand 对象。现在我们知道，prototype 与__proto__ 的关系就是：你的__proto__来自你构造函数的prototype */ ‌原型: 在 JS 中，每当定义一个对象（函数也是对象）时，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype 属性，这个属性指向函数的原型对象。 class 和 function： 相同点：都可以作为构造函数 不同点： class构造函数必须使用new操作符 class声明不可以提升 class不可以用call、apply、bind改变执行上下文 原型链：函数的原型链对象constructor默认指向函数本身。原型对象除了有原型属性外，为了实现继承，还有一个原型链指针__proto__,该指针是指向上一层的原型对象，而上一层的原型对象的结构依然类似。因此可以利用__proto__一直指向Object的原型对象上，而Object原型对象用Object.prototype.__ proto__ &#x3D; null表示原型链顶端。如此形成了js的原型链继承。同时所有的js对象都有Object的基本防范 Object.prototype是所有对象原型链的顶层，它包含一些常用的方法和属性，可以被所有对象继承。 Object.__proto__是Object构造函数的原型，它包含Object构造函数的方法和属性，可以被所有通过Object构造函数创建的对象继承。 Object.prototype.__proto__是一个非标准方法，用于访问对象原型链上一级的原型对象，不建议在生产代码中使用。 constructor方法是类的默认方法,通过new命令生成对象实例,自动调用该方法。 一个类必须有constructor方法 **原型链:**是一种机制，指的是JavaScript每个对象包括原型对象都有一个内置的__proto__属性指向创建它的函数对象的原型对象，即prototype属性。 原型链是原型对象创建过程的历史记录，当访问一个对象的某个属性时，会先在这个对象本身属性上查找。 第一句话：prototype是函数的原型对象，即prototype是一个对象，它会被对应的__proto__引用。 第二句话：要知道自己的__proto__引用了哪个prototype，只需要看看是哪个构造函数构造了你，那你的__proto__就是那个构造函数的prototype。 第三句话：所有的构造函数的原型链最后都会引用Object构造函数的原型，即可以理解Object构造函数的原型是所有原型链的最底层，即Object.prototype.__proto__===null 特点: JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。 js如何实现继承 ‌原型链继承‌：通过Child.prototype = new Parent();实现。 所有子类共享同一个父类实例 123456789101112131415161718function Parent() &#123; this.property = &quot;parentProperty&quot;;&#125;Parent.prototype.say = function () &#123; console.log(&quot;Parent say&quot;);&#125;;function Child() &#123; this.childProperty = &quot;childProperty&quot;;&#125;Child.prototype = new Parent();const childInstance = new Child();console.log(childInstance.property); // parentPropertyconsole.log(childInstance.childProperty); // childPropertychildInstance.say(); // Parent say//需要再修改 Child.prototype 的指向之后（即代码 Child.prototype = new Parent(); ），需要同时修改 Child.prototype.constructor 的指向:Child.prototype = new Parent();+Child.prototype.constructor = Child; 绕过父类实例，共享同一个父类的原型（通过call 构造函数） 123456789101112131415161718function Parent() &#123; this.property = &quot;parentProperty&quot;;&#125;Parent.prototype.say = function () &#123; console.log(&quot;Parent say&quot;);&#125;;function Child() &#123; Parent.call(this); this.childProperty = &quot;childProperty&quot;;&#125;// 方式一：直接指向// Child.prototype.__proto__ = Parent.prototype;// 方式二：使用 Object.create()，这是 es5 的方法Child.prototype = Object.create(Parent.prototype);Child.prototype.constructor = Child;let childInstance = new Child();console.log(childInstance.property);childInstance.say(); ‌借用构造函数‌：通过Parent.call(this);在子类构造函数中调用父类构造函数。子类有独立副本，无法继承父类原型上的方法 12345678910111213function Parent() &#123; this.property = &quot;parentProperty&quot;;&#125;Parent.prototype.say = function () &#123; console.log(&quot;Parent say&quot;);&#125;;function Child() &#123; Parent.call(this); this.childProperty = &quot;childProperty&quot;;&#125;const childInstance = new Child();console.log(childInstance.property); // 输出 &#x27;parentProperty&#x27;// childInstance.say() // 报错：childInstance.say is not a function ‌组合继承‌：通过先借用构造函数继承属性，再用原型链继承方法。之前方法的结合 12345678910111213141516function Parent() &#123; this.property = &quot;parentProperty&quot;;&#125;Parent.prototype.say = function () &#123; console.log(&quot;Parent say&quot;);&#125;;function Child() &#123; Parent.call(this); this.childProperty = &quot;childProperty&quot;;&#125;Child.prototype = new Parent();// 注意：修改其原型对象之后，同时必须得修改 constructor 的指向Child.prototype.constructor = Child;const childInstance = new Child();console.log(childInstance.property); // 输出 &#x27;parentProperty&#x27;childInstance.say(); ‌寄生式继承‌：通过Object.create()获得父对象的浅拷贝，并添加新方法。 原型式继承：创造临时构造函数，将这个临时的原型指向父构造函数的原型，再将子构造函数的原型指向临时 1234567891011121314151617181920212223242526function mockExtend(Parent, Child) &#123; function Temp() &#123;&#125; /** * 1. 修改了 Fn.prototype 的指向后，那么原来的 Fn.prototype 没有被引用，则会被回收 * 2. 那么Fn的实例对象的 __proto__ 就指向其构造函数的 prototype */ Temp.prototype = Parent.prototype; Child.prototype = new Temp(); // 注意：修改了原型对象之后，同时必须得修改 constructor 的指向 Child.prototype.constructor = Child;&#125;// =============================== 使用 ==================================function Parent() &#123; this.property = &quot;parentProperty&quot;;&#125;Parent.prototype.say = function () &#123; console.log(&quot;Parent say&quot;);&#125;;function Child() &#123; Parent.call(this); this.childProperty = &quot;childProperty&quot;;&#125;mockExtend(Parent, Child);const childInstance = new Child();console.log(childInstance.property);childInstance.say(); ‌寄生组合式继承‌：结合寄生式和组合式的优点，先借用构造函数，再用寄生式添加方法。 ES6类继承：extend 1234567891011121314151617class Parent &#123; constructor() &#123; this.property = &quot;parentProperty&quot;; &#125; say() &#123; console.log(&quot;Parent say&quot;); &#125;&#125;class Child extends Parent &#123; constructor() &#123; super(); this.childProperty = &quot;childProperty&quot;; &#125;&#125;const childInstance = new Child();console.log(childInstance.property); // 输出 &#x27;parentProperty&#x27;childInstance.say(); EventLoop 事件循环JavaScript是单线程的（指的是js引擎在执行代码的时候只有一个主线程，每次只能干一件事），同时还是非阻塞运行的（执行异步任务的时候，会先挂起相应任务，待异步返回结果再执行回调） JS是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列，异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列。(同&gt;异（微&gt;宏）) 浏览器中的任务源(task): 宏任务(macrotask)：宿主环境提供的，比如浏览器ajax、setTimeout、setInterval、setTmmediate(只兼容ie)、script、requestAnimationFrame、messageChannel、UI渲染、一些浏览器api、IO操作、postMessage 微任务(microtask)：语言本身提供的，比如promise.thenthen、queueMicrotask(基于then)、mutationObserver(浏览器提供)、messageChannel 、mutationObersve、queueMicrotask JS运行的环境。一般为浏览器或者Node。 在浏览器环境中，有JS 引擎线程和渲染线程，且两个线程互斥。 Node环境中，只有JS 线程。 不同环境执行机制有差异，》不同任务进入不同Event Queue队列。 当主程结束，先执行准备好微任务，然后再执行准备好的宏任务，一个轮询结束。 浏览器中的事件环（Event Loop)可以理解为是一个桥梁，连接着应用程序的js和系统调用之间的通道 事件环的运行机制是，先会执行栈中的内容，栈中的内容执行后执行微任务，微任务清空后再执行宏任务，先取出一个宏任务，再去执行微任务，然后在取宏任务清微任务这样不停的循环。 eventLoop 是由JS的宿主环境（浏览器）来实现的； 事件循环可以简单的描述为以下四个步骤: 函数入栈，当Stack中执行到异步任务的时候，就将他丢给WebAPIs,接着执行同步任务,直到Stack为空； 此期间WebAPIs完成这个事件，把回调函数放入队列中等待执行（微任务放到微任务队列，宏任务放到宏任务队列） 执行栈为空时，Event Loop把微任务队列执行清空； 微任务队列清空后，进入宏任务队列，取队列的第一项任务放入Stack(栈）中执行，执行完成后，查看微任务队列是否有任务，有的话，清空微任务队列。重复4，继续从宏任务中取任务执行，执行完成之后，继续清空微任务，如此反复循环，直至清空所有的任务。 123456789101112131415161718192021222324252627282930313233343536373839console.log(&quot;script start&quot;);const promiseA = new Promise((resolve, reject) =&gt; &#123; console.log(&quot;init promiseA&quot;); resolve(&quot;promiseA&quot;);&#125;);const promiseB = new Promise((resolve, reject) =&gt; &#123; console.log(&quot;init promiseB&quot;); resolve(&quot;promiseB&quot;);&#125;);setTimeout(() =&gt; &#123; console.log(&quot;setTimeout run&quot;); promiseB.then(res =&gt; &#123; console.log(&quot;promiseB res :&gt;&gt; &quot;, res); &#125;); console.log(&quot;setTimeout end&quot;);&#125;, 500);promiseA.then(res =&gt; &#123; console.log(&quot;promiseA res :&gt;&gt; &quot;, res);&#125;);queueMicrotask(() =&gt; &#123; console.log(&quot;queue Microtask run&quot;);&#125;);console.log(&quot;script end&quot;);// script start// init promiseA// init promiseB// script end// promiseA res :&gt;&gt; promiseA// queue Microtask run// setTimeout run// setTimeout end// promiseB res :&gt;&gt; promiseB 传送门 ☞ # 宏任务和微任务 Node 环境中的事件环（Event Loop)Node是基于V8引擎的运行在服务端的JavaScript运行环境，在处理高并发、I&#x2F;O密集(文件操作、网络操作、数据库操作等)场景有明显的优势。虽然用到也是V8引擎，但由于服务目的和环境不同，导致了它的API与原生JS有些区别，其Event Loop还要处理一些I&#x2F;O，比如新的网络连接等，所以Node的Event Loop(事件环机制)与浏览器的是不太一样。 执行顺序如下： timers: 计时器，执行setTimeout和setInterval的回调 pending callbacks: 执行延迟到下一个循环迭代的 I&#x2F;O 回调 idle, prepare: 队列的移动，仅系统内部使用 poll轮询: 检索新的 I&#x2F;O 事件;执行与 I&#x2F;O 相关的回调。事实上除了其他几个阶段处理的事情，其他几乎所有的异步都在这个阶段处理。 check: 执行setImmediate回调，setImmediate在这里执行 close callbacks: 执行close事件的callback，一些关闭的回调函数，如：socket.on(‘close’, …) setTimeout、Promise、Async&#x2F;Await 的区别 setTimeout settimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行。 Promise Promise本身是同步的立即执行函数， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then&#x2F;catch等，当主栈完成后，才会去调用resolve&#x2F;reject中存放的方法执行。 函数接收resolve、reject参数后promise状态pendingfullfilledrejected promise构造函数中的回调函数then和catch是异步执行的 12345678910111213141516(new Promise(step1)) .then(step2)------------------------------console.log(&#x27;script start&#x27;)let promise1 = new Promise(function (resolve) &#123; console.log(&#x27;promise1&#x27;) resolve() console.log(&#x27;promise1 end&#x27;)&#125;).then(function () &#123; console.log(&#x27;promise2&#x27;)&#125;)setTimeout(function()&#123; console.log(&#x27;settimeout&#x27;)&#125;)console.log(&#x27;script end&#x27;)// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout async&#x2F;await async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。 async只是promise的语法糖，await后面的放在微任务中执行 先执行await中的语句，await后面的放异步队列，直到触发的异步操作完成 123456789101112131415161718192021222324252627async function async1()&#123; console.log(&#x27;async1 start&#x27;); await async2(); //await后面才是then的步骤 console.log(&#x27;async1 end&#x27;)&#125;async function async2()&#123; console.log(&#x27;async2&#x27;)&#125;console.log(&#x27;script start&#x27;);async1();console.log(&#x27;script end&#x27;)// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 endsetTimeout创建的定时器具有异步性，即它们不会中断程序执行，而是继续执行后续的代码。如果你希望在执行完一个函数后再执行另一个函数，可以使用回调函数或Promise等技术。setTimeout(function () &#123; console.log(&#x27;settimeout&#x27;) &#125;,1000)setTimeout(console.log(&#x27;sss&#x27;),1000);这两个setTimeout函数调用有一些区别。第一个setTimeout函数调用使用了匿名函数，它将在1秒后执行console.log(&#x27;settimeout&#x27;)。这个函数是作为参数传递给setTimeout函数的，并且被封装在一个匿名函数中。第二个setTimeout函数调用直接将console.log(&#x27;sss&#x27;)作为参数传递给setTimeout函数，并且也设置了1秒的延迟。但是，由于console.log(&#x27;sss&#x27;)是一个立即执行的函数，它将在当前代码执行到此处时立即执行，而不是等待1秒后执行。因此，第一个setTimeout函数调用将在1秒后打印出&quot;settimeout&quot;，而第二个setTimeout函数调用将在当前代码执行到此处时立即打印出&quot;sss&quot;。同时，无论哪个setTimeout函数调用先执行，最后都会打印 传送门 ☞ # JavaScript Promise 专题 Async&#x2F;Await 如何通过同步的方式实现异步Async&#x2F;Await就是一个自执行的generate函数。利用generate函数的特性把异步的代码写成“同步”的形式,第一个请求的返回值作为后面一个请求的参数,其中每一个参数都是一个promise对象. 介绍节流防抖原理、区别以及应用节流：（死的）（时间内）事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用最先被触发的那次，直到这波过了。所以适用于函数被频繁调用的场景。 一种将多次执行变成每隔一段时间执行的模式。和高频事件触发时每次触发都设置一个延迟调用方法不同，节流会取消之前延时调用的方法。简单来说，就是每次触发事件时都会判断是否需要等待执行的延时函数。 布尔判断闭包是否执行 防抖：（每次重置） （时间外）触发事件后在 n 秒内函数只能执行一次回调，如果在 n 秒内又触发了事件，会重新计算函数执行时间。（只有过了设定的时间&amp;&amp;没在设定时间内操作后，才会执行） 将多次执行变为最后一次执行的模式。在防抖触发高频率事件时，如果在n秒内再次触发，则会重新计算。简单来说，每次触发时都会取消之前的延时调用。 闭包 使用场景：节流：滚动加载更多、搜索框搜的索联想功能、高频点击、表单重复提交……防抖：搜索框搜索输入，并在输入完以后自动搜索、手机号，邮箱验证输入检测、窗口大小 resize 变化后，再重新渲染。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 节流函数 一个函数执行一次后，只有大于设定的执行周期才会执行第二次。有个需要频繁触发的函数，出于优化性能的角度，在规定时间内，只让函数触发的第一次生效，后面的不生效。 * @param fn要被节流的函数 * @param delay规定的时间 */function throttle(fn, delay) &#123; //记录上一次函数触发的时间 var lastTime = 0; return function()&#123; //记录当前函数触发的时间 var nowTime = Date.now(); if(nowTime - lastTime &gt; delay)&#123; //修正this指向问题 // this 指向触发 scroll 事件的 DOM 元素 fn.call(this); //同步执行结束时间 lastTime = nowTime; &#125; &#125;&#125;document.onscroll = throttle(function () &#123; console.log(&#x27;scllor事件被触发了&#x27; + Date.now());&#125;, 200); /** * 防抖函数 一个需要频繁触发的函数，在规定时间内，只让最后一次生效，前面的不生效 * @param fn要被节流的函数 * @param delay规定的时间 */function debounce(fn, delay) &#123; //记录上一次的延时器 var timer = null; return function () &#123; //清除上一次的演示器 clearTimeout(timer); //重新设置新的延时器 timer = setTimeout(function()&#123; //修正this指向问题 fn.apply(this); &#125;, delay); &#125;&#125;document.getElementById(&#x27;btn&#x27;).onclick = debounce(function () &#123; console.log(&#x27;按钮被点击了&#x27; + Date.now());&#125;, 1000); 异步异步函数是一种可能会在执行过程中暂停程序，等待某些操作完成后再继续执行的函数 异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。 拓展运算符是浅拷贝 reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。 数据驱动数据驱动，数据往往”模板“的形式放在存在，实现了组件化，每一个组件只是完成一个页面中的一小部分，需要更新的时候是直接用指定修改数据的方式，修该数据。不用于结构产生关系。（结构层与数据层分离） 继承原型链、构造函数、组合继承、寄生式继承、寄生式组合继承、es6的class继承 https://blog.csdn.net/huohuoit/article/details/106696533 https://es6.ruanyifeng.com/#docs/class-extends 原型链继承prototype 原型链继承是一种较早期的继承方式，它的核心思想是子类的原型对象指向父类的实例，但并不提供直接在子类构造函数中传递参数给父类构造函数的机制。ES6才引入了类和 super 关键字 1234567891011121314151617/*由于所有Child实例原型都指向同一个Parent实例，引用类型的私有属性公有化了， 因此对某个Child实例的父类引用类型做变量修改会影响所有的Child实例*/function Parent() &#123; this.names = [&#x27;Alice&#x27;, &#x27;Bob&#x27;];&#125;function Child() &#123; &#125;Child.prototype = new Parent();const child1 = new Child();const child2 = new Child();child1.names.push(&#x27;Charlie&#x27;);console.log(child2.names); // 输出: [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Charlie&#x27;] 构造函数继承call 子类的构造函数中执行父类的构造函数，并为其绑定子类的 this，让父类的构造函数把成员属性和方法都挂到子类的 this 上去，这样既能避免实例之间共享一个原型实例，又能向父类构造方法传参 解决了原型继承中“引用类型私有属性变公有”、“不可传递参数”两个问题 缺点：继承不到父类原型上的方法（所以不能单独使用咯 ~） 12345678910111213function Parent(name) &#123; this.name = name&#125;Parent.prototype.getName = function () &#123; return this.name&#125;function Child() &#123; // 执行父类的构造函数，并修改 this 指向到子类, 使得父类中的属性能够赋到子类的 this 上 Parent.call(this, &#x27;huohuo&#x27;) // 既能避免实例之间共享一个原型实例，又能向父类构造方法传参&#125;const child1 = new Child()console.log(child1.name) // huohuochild1.getName() // 报错, 找不到getName(), 构造函数继承的方式继承不到父类原型上的方法 组合继承call + prototype + constructor 使用原型链继承原型上的属性和方法，而通过构造函数继承实例属性（构造函数+原型对象 缺点：每次创建子类实例都执行了两次构造函数（Parent.call() 和 new Paren()），虽然这并不影响对父类的继承，但子类创建实例时，原型中会存在两份相同的属性和方法，这并不优雅 123456789101112131415161718192021function Parent (name) &#123; this.name = name&#125;Parent.prototype.getName = function () &#123; return this.name&#125;function Child () &#123; // 构造函数继承 Parent.call(this, &#x27;huohuo&#x27;) // 既能避免实例之间共享一个原型实例，又能向父类构造方法传参&#125;//原型链继承Child.prototype = new Parent() // 父类的方法可以被子类通过原型拿到Child.prototype.constructor = Child // 顺带绑定下 constructor (增强对象) //测试const child1 = new Child()const child2 = new Child()child1.name = &#x27;foo&#x27;console.log(child1.name) // fooconsole.log(child2.name) // huohuochild2.getName() // &#x27;huohuo&#x27; 寄生式继承Object.create() 创建一个实现继承的函数，改函数内部以某种形式来增强对象，最后返回对象 缺点：类似构造函数继承，会导致函数难以重用 123456789101112131415function ParasInherit(obj) &#123; const child = Object.create(obj) // 通过调用函数创建一个对象 child.sayHi = function () &#123; // 增强对象 console.log(&#x27;HelloHuohuo&#x27;); &#125; return child // 基于 obj 对象返回了一个新的对象 （具有 obj 的所有属性和方法）&#125; // 测试const person = &#123; name: &#x27;huohuo&#x27;, data: [&#x27;3&#x27;, &#x27;180&#x27;, &#x27;50&#x27;]&#125;const inheritPerson = ParasInherit(person)inheritPerson.sayHi() // HelloHuohuo 寄生式组合继承object.create() +call + constructor + prototype&#x3D;prototype 但需要浅拷贝(也不算浅拷贝吧,总之算是复制了原型对象),唯一一个子类会影响到父类的 解决第三种继承提到的构造函数被执行两次的问题, 我们将指向父类实例改为指向父类原型, 减去一次构造函数的执行 1234567891011121314151617181920212223242526function Parent(name) &#123; this.name = name&#125;Parent.prototype.getName = function() &#123; return this.name&#125;function Child() &#123; // 构造函数继承 Parent.call(this, &#x27;huohuo&#x27;) &#125;//原型链继承// Child.prototype = new Parent()Child.prototype = Parent.prototype //将`指向父类实例`改为`指向父类原型`Child.prototype.constructor = Child //测试const child1 = new Child()const child2 = new Child()child1.name = &#x27;foo&#x27;console.log(child1.name) // fooconsole.log(child2.name) // huohuochild2.getName() // &#x27;huohuo&#x27;但这种方式存在一个问题，由于子类原型和父类原型指向同一个对象，我们对子类原型的操作会影响到父类原型，例如给 Child.prototype 增加一个getName()方法，那么会导致 Parent.prototype 也增加或被覆盖一个 getName 方法，为了解决这个问题，我们给 Parent.prototype 做一个浅拷贝 //Child.prototype = Parent.prototype改为 Child.prototype = Object.create(Parent.prototype) 封装后： 1234567891011121314151617181920// 封装一下function myInherit (child, parent) &#123; // 接受两个参数：父子构造函数 let prototype = Object.create(parent.prototype) // 创建父类原型的拷贝 prototype.constructor = child // 解决重写原型导致的 constructor 丢失问题（增强对象） child.prototype = prototype // 将新对象赋值给子类原型&#125; // 测试function Parent (name) &#123; this.name = name&#125;Parent.prototype.getName = function () &#123; return this.name&#125;function Child () &#123; Parent.call(this, &#x27;huohuo&#x27;)&#125;myInherit(Child, Parent)const child1 = new Child()console.log(child1.name); // huohuo class继承extends + super class通过extends,要用this或者是新的自定义变量，必须super()，但是属于子类的实例 ​\t由于super()在子类构造方法中执行时，子类的属性和方法还没有绑定到this，所以如果存在同名属性，此时拿到的是父类的属性。 子类必须在constructor中调用super()，否则报错，无法得到自己的this对象（继承在前，实例在后，与es5相反。先将父类属性方法放一个空对象上，再将该对象作为子类的实例，所以父类构造函数先运行一次） 不管有没有显式定义，任何一个子类都有且只有一个constructor()方法。 除了私有属性，父类的所有属性和方法，都会被子类继承 除非有相关get去return，否则子类都没法读写这些变量（私有变量） static静态属性（软拷贝&#x3D;浅拷贝，数值类不影响父类的值，对象类会改变父类（对对象的一个引用，一个指向原始对象的指针或引用））方法会被子类继承 123456789101112131415161718192021// Class 类继承class Father &#123; constructor(surname) &#123; this.surname = surname; // 类的属性声明用 this 即可 &#125; saySurname () &#123; console.log(&#x27;My surname is &#x27; + this.surname); // 访问类的属性要用 this &#125;&#125;class Son extends Father &#123; // 这样子类就继承了父类的属性和方法 constructor(surname, firstname) &#123; super(surname); // 通过调用 super 来调用父类的构造函数，并初始化父类的属性 this.firstname = firstname; // 初始化一个子类属性 &#125; sayFirstname () &#123; console.log(&#x27;My firstname is &#x27; + this.firstname); &#125;&#125;const cc = new Son(&#x27;ai&#x27;, &#x27;huohuo&#x27;);cc.saySurname(); // My surname is aicc.sayFirstname(); // My firstname is huohuo 深浅拷贝浅拷贝：（原地改变） 创建一个新对象，并将原始对象的非函数属性逐个复制到新对象中。浅拷贝不会复制原始对象中的函数或原型链。 用一个数组装,hasOwnProperty检查一下属性是不是对象的自有属性就行了 123456789浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。只是拷贝了基本类型的数据；而引用类型数据，复制之后也是会发生引用。换句话说，浅拷贝仅仅是指向被复制的内存地址，如果原地址中对象被改变，那么浅拷贝出来的对象也会相应改变；可以使用 for in(仅函数,得不到对象属性的值,只能得到名,但可以手动通过其它方式复制来实现浅拷贝 hasOwnProperty(kk[key])、 Object.assign、 扩展运算符 ... 、 Array.prototype.slice()、Array.prototype.concat() 等 深拷贝：（重新找个地方变） 创建一个新对象，并将原始对象中的所有内容（包括函数、原型链和所有属性）都复制到新对象中。 1234深拷贝和浅拷贝是针对复杂数据类型（对象及数组）来说的，浅拷贝只拷贝一层，而深拷贝是|层层拷贝|。在计算机中开辟一块新的内存地址用于存放复制的对象深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。 深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。 https://blog.csdn.net/m0_65558076/article/details/123790238 实现方式： 递归拷贝 递归拷贝是通过递归的方式，逐层遍历对象或数组，并复制其每个元素。如果元素是对象或数组，则递归地复制该元素。这种方式实现简单，但在处理嵌套层次较深的对象或数组时可能会导致栈溢出。此外，如果对象中有引用类型的数据结构（如数组、对象等），递归拷贝可能会导致大量重复复制，效率较低。 完美拷贝 完美拷贝是一种更高效的深拷贝方式。它通过使用哈希表来记录已经复制的对象，避免了重复复制的问题。具体来说，它首先遍历对象或数组，将每个元素转换为一个字符串形式的键，并将该键对应的值存储在哈希表中。然后，它再次遍历对象或数组，根据哈希表中的键值对，将每个元素复制到新的对象或数组中。这种方式避免了递归拷贝的栈溢出问题，同时也避免了重复复制的问题，效率更高。 1. 递归去复制所有层级属性，即：遍历对象、数组直到里边都是基本数据类型，然后再去复制。 1234567891011121314151617181920212223242526function deepClone(obj) &#123; let objClone = Array.isArray(obj) ? [] : &#123;&#125;; if(obj &amp;&amp; typeof obj === &#x27;object&#x27;) &#123; for(key in obj) &#123; // 判断对象是否包含特定的自身（非继承）属性。检测属性是否为对象的自有属性,如果是,返回true if(obj.hasOwnProperty(key)) &#123; // 判断obj子元素是否为对象，如果是，递归复制 if(obj[key] &amp;&amp; typeof obj[key] === &#x27;object&#x27;) &#123; objClone[key] = deepClone(obj[key]); &#125; else &#123; objClone[key] = obj[key]; &#125; &#125; &#125; &#125; return objClone;&#125; let arr = [1,2,[3,4],5];let arr1 = arr;let arr2 = deepClone(arr);arr[2][0] = 9;console.log(arr); // [1,2,[9,4],5]console.log(arr1); // [1,2,[9,4],5] 可以看到改变 arr 后 arr1 的值也改变了；console.log(arr2); // [1,2,[3,4],5] 2. 借用 JSON 对象的stringify + parse : 这种方法虽然可以实现数组或对象深拷贝，但不能处理函数。 继承的属性x functionx undefinedx Date类型x symbolx 原型链上的属性x 12345function deepClone(obj) &#123; let _obj = JSON.stringify(obj); let objClone = JSON.parse(_obj); return objClone;&#125; 3. 借用 jQuery 中 extend 方法： 123$.extend(true,target,a,b,...) // 不管后面有多少个对象，都将成为第一个对象 target 的属性；// true：表示为深拷贝； 完美深拷贝 其余复杂 非复杂 已存在 设置 循环 123456789101112131415161718192021222324252627创建了一个新的对象 t，这个对象的构造方法和 obj 相同，然后将 obj 和 t 关联起来，存入一个哈希表中。// hash为空赋值为new WeakMap(),不为空就不赋值function deepClone(obj, hash = new WeakMap()) &#123; //递归拷贝 if (obj instanceof RegExp) return new RegExp(obj); if (obj instanceof Date) return new Date(obj); if (obj === null || typeof obj !== &#x27;object&#x27;) &#123; //如果不是复杂数据类型，直接返回 return obj; &#125; if (hash.has(obj)) &#123; return hash.get(obj); &#125; // * // * 如果obj是数组，那么 obj.constructor 是 [Function: Array] // * 如果obj是对象，那么 obj.constructor 是 [Function: Object] let t = new obj.constructor(); hash.set(obj, t); //创建了一个新的对象 t，这个对象的构造方法和 obj 相同，然后将 obj 和 t 关联起来，存入一个哈希表中。免得被递归无限循环 for (let key in obj) &#123; //递归 if (obj.hasOwnProperty(key)) &#123;//是否是自身的属性 t[key] = deepClone(obj[key], hash); &#125; &#125; return t; &#125; 手写深拷贝 这个题一定要会啊！笔者面试过程中疯狂被问到！ 文章推荐：如何写出一个惊艳面试官的深拷贝? 这个多了判断伪数组 1234567891011121314151617181920212223 /** * 深拷贝 * @param &#123;Object&#125; obj 要拷贝的对象 * @param &#123;Map&#125; map 用于存储循环引用对象的地址 */ function deepClone(obj = &#123;&#125;, map = new Map()) &#123; if (typeof obj !== &quot;object&quot;) &#123; return obj; &#125; if (map.get(obj)) &#123; //Map.get()方法用于获取Map中所有元素中的特定元素。如果映射中不存在作为参数传递的键，则Map.get()方法将返回undefined return map.get(obj); &#125; let result = &#123;&#125;; // 初始化返回结果 if (obj instanceof Array || Object.prototype.toString(obj) === &quot;[object Array]&quot;) &#123; // 加 || 的原因是为了防止 Array 的 prototype 被重写，Array.isArray 也是如此 防止受到伪数组的影响 result = []; &#125; // 防止循环引用 - obj1 中的 a 属性引用 obj2,obj2 中的 b 属性引用 obj1 map.set(obj, result); for (const key in obj) &#123; // 保证 key 不是原型属性 if (obj.hasOwnProperty(key)) &#123; // 递归调用 result[key] = deepClone(obj[key], map); &#125; &#125; // 返回结果 return result; &#125; for in 、传统 for 循环、forEach 有什么区别针对数组而言,都可以完成我们的需求 for循环的优点是,可以控制循环的起始和结束 for…in一般是针对对象的循环； forEach() 只能循环遍历数组,不能循环遍历对象 ES6新增API 类； 模块化； 箭头函数； 函数参数默认值； 模板字符串； 解构赋值； 延展操作符； 对象属性简写； Promise； Let与Const； https://zhuanlan.zhihu.com/p/619630186 ES next新特性有哪些？https://zhuanlan.zhihu.com/p/598816995?utm_id=0 css和js加载是同步同步模式又称阻塞模式,会阻止浏览器的后续处理。流览器之所以会采用同步模式,是因为加载的js文件中有对dom的操作。 js执行默认是会阻塞html解析的，给script标签加defer和async属性(和src连用)，或者采用动态创建script标签方式，js就不会阻塞html。 动态创建:let script &#x3D; document.createElement(‘script’);script.src &#x3D; ‘https://example.com/some-script.js‘;document.head.appendChild(script); script标签什么情况不阻塞渲染？为什么会有这三种模式？async、defer和动态创建标签。 可以让script异步加载避免阻塞dom渲染，提升首屏渲染速度。 requestAnimationFrame与setTimeout的区别制作 JavaScript 动画，计时器的特性而带来一些问题 间隔时间不精确，可能被阻塞。计时器的间隔指的是将回调函数推入任务队列的间隔时间，任务队列中的任务只有在主线程任务执行完毕后才会被执行。 计时器动画的间隔时间如果设定过短就会出现过度渲染占用大量资源，消耗cpu；设定过长就会影响动画的流畅度。只能够估计合适的时间间隔。画面不展示时候，定时器依然执行，导致不必要的CPU资源消耗 多数浏览器对于计时器动画没有优化。 使用 requestAnimationFrame 方法来定义动画就不会出现以上这些问题。 requestAnimationFrame 动画的帧数是由系统根据当前页面是否可见，CPU 的占用情况等等来决定的，可以最大化地利用系统性能。 浏览器对 requestAnimationFrame 动画进行了优化。 如何计算白屏和首屏时间？onload事件发生了什么？白屏结束时间 &#x3D; FP事件触发时间 FP（First Paint）表示渲染出第一个像素点的时间。FP一般在HTML解析完成或者解析一部分时候触发。 首屏结束时间 &#x3D; FCP事件触发时间 FCP（First Contentful Paint）表示渲染出第一个内容的时间，这里的“内容”可以是文本、图片、canvas。 Onload Event，它代表页面中依赖的所有资源：DOM、图片、CSS、Flash等都加载完。 指标计算方法,通过performance API 12345678// FPconst fp = performance.getEntries(&#x27;paint&#x27;).filter(entry =&gt; entry.name == &#x27;first-paint&#x27;)[0].startTime;// FCPconst fcp = performance.getEntries(&#x27;paint&#x27;).filter(entry =&gt; entry.name == &#x27;first-contentful-paint&#x27;)[0].startTime;// Onload Eventconst l = performance.timing.loadEventEnd - performance.timing.navigationStart; FCP&#x2F;FMP&#x2F;FP分别是怎样定义，如何统计？FMP（First Meaningful Paint），首次渲染有意义的内容的时间，“有意义”没有一个标准的定义，FMP的计算方法也很复杂。 lighthouse的计算的大体思路是，将页面中最大布局变化后的第一次渲染事件作为FMP事件，并且计算中考虑到了可视区的因素。 没有现成的performance API，如果希望在监控中上报这个指标，可以自己使用MutationObserver计算。 创建ajax过程1234567891011121314151617181920212223242526272829303132// 1. 创建一个xml对象，使用XMLHttpRequest()方法，ie的话是new ActiveObject(&#x27;Microoft.XMLHTTP&#x27;)var xmlHttpif (window.XMLHttpRequest) &#123; xmlHttp = new XMLHttpRequest()&#125; else &#123; xmlHttp = new ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;)&#125;if (option.type.toLowerCase() === &#x27;get&#x27;) &#123; // 2. 调用open指定发送的类型和地址 xmlhttp.open(&#x27;GET&#x27;, url); //3.发送请求 xmlhttp.send();&#125; else if (option.type.toLowerCase() === &#x27;post&#x27;) &#123; xmlhttp.open(&#x27;POST&#x27;, url); // 4. 如果是post的话还需要设置http请求头的内容，位于open和send之间 xmlhttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); xmlhttp.send(str);&#125;// 5. 处理服务器的响应，使用readyStatechange监测状态的变化，触发回调函数// 6. 如果readyState是4，并且响应码处于200,300，或是等于304，就执行成功的回调xmlHttp.onreadyStateChange = function () &#123; // 返回一个 XMLHttpRequest 代理当前所处的状态（0 unsent 1opened 2 已经调用send了 3下载中 4下载完毕done） if (xmlHttp.readyState == 4) &#123; // 服务器返回的状态码 if (xmlhttp.status &gt;= 200 &amp;&amp; xmlhttp.status &lt; 300 || xmlhttp.status === 304) &#123; console.log(xmlhttp.responseText) &#125; &#125; else &#123; console.log(xmlhttp.status) &#125;&#125;"},{"title":"打包部署后侧边栏消失","path":"/undefined/打包部署后侧边栏消失/","content":"问题描述：技术：vue3 + vue-admin-template 代码部署到nginx后侧边栏消失，但是本地运行又是正常的 输入后发现引入的文件里面为空 解决方案:https://www.cnblogs.com/zz-1q/p/17480275.html 在scss文件名后缀前添加“.module”。sidebar.scss &#x3D;&gt; sidebar.module.scss 解决思路（碎碎念）：以为是loader的原因，但在vue.config.js中重新引入后失败。 排除后发现无论是打包部署后还是本地运行引入的scss文件都为空，去查scss的export有没有问题，最终确定为上述解决方案"},{"title":"软考","path":"/undefined/ruankao/","content":"软考计算机系统组成 硬件 + 软件 硬件 运算器、控制器、存储器、输入设备、输出设备 其它 汇编程序中，可直接访问通用寄存器存取数据 可访问状态寄存器(标志寄存器，运算器的一部分)获取有关数据处理结果 可通过程序计数器(PC)寻址 不能访问任何指令寄存器，指令寄存器的位数取决于指令字长，根据指令字长设计指令存储器数量 中央处理单元(CPU) 功能 程序控制 通过执行指令控制执行顺序 操作控制（控制器） 产生每条指令操作信号，并将操作信号送往对应部件，控制相应部件按指令进行操作 时间控制 对各种操作进行时间上的控制，即指令执行过程中操作信号的出现时间、持续时间及出现的时间顺序都需要进行严格控制 数据处理 对数据进行算术运算及逻辑运算等方式进行加工处理 对系统内部和外部的中断（一场）做出相应，进行相应的处理 运算器、控制器（寄存器组、内部总线） 程序控制、操作控制、时间控制 - 数据处理 控制器决定了计算机运行过程的自动化 运算器 组成 算数逻辑单元(ALU) 处理数据、算术运算、逻辑运算 由很多部件组成，例如 加法器 等 累加寄存器(AC) 累加器、算通用寄存器 算术逻辑单元执行算数或逻辑运算时，为ALU提供一个工作区，运算结果放在累加器中 - 运算器中至少存在一个 数据缓冲寄存器(DR) - 只是一个中转站，是一个缓冲 状态条件寄存器(PSW) 相当于标记运算的结果，比如进位之类 主要功能 算术运算 逻辑运算（与或非） 零值测试：这个值是不是0 所有操作由控制器指挥，只能完成运算，为执行部件 控制器 功能 控制cpu工作，决定计算机运行过程的自动化 保证程序指令正确执行 能处理异常事件 组成 逻辑组成 指令控制逻辑 取指令，分析指令、执行指令 取，译码，按指令操作码执行，形成下一条指令地址 时序控制逻辑 总线控制逻辑 中断控制逻辑 部件 指令寄存器(IR) cpu执行指令时，先把它从内存储器取到缓冲寄存器(DR)中，再送入IR暂存。指令译码器(ID)根据IR的内容产生各种微操作指令，控制其他部件工作 只是短暂存在这 执行指令下都放这里 要识别完了才直接执行 程序计数器(PC) &#x3D; 指令计数器 程序执行的方式：顺序执行&#x2F;转移执行（不按顺序跳），转移指令寻址 pc内容由cpu修改，pc起始地址在内存加载时确定，顺序执行就pc+1（0x1）&#x2F; 转移执行是当前指令地址+位移量 or 直接地址 跟踪保存下一条指令的地址 指令&#x3D;操作码+地址码，所以根据地址码能从内存这种读取操作码，所以首先要把pc送到地址总线上 地址总线是一种计算机总线，是CPU或有DMA能力的单元，用来沟通这些单元想要访问（读取&#x2F;写入）计算机内存组件&#x2F;地方的物理地址。 程序员可访问 地址寄存器(AR) 保存当前CPU所访问”内存单元的地址“ 因为CPU和内存存在操作速度差异，所以需要保持地址信息到内存的读写操作完成为止 指令译码器(ID) 指令&#x3D;操作码+地址码 操作码：+ - * &#x2F; &amp; 等 执行指令必须对“操作码”进行分析 功能：识别指令的操作，向操作控制器发出控制信号控制工作 硬件系统核心 CPU 数据处理、逻辑运算、控制 获取程序指令，译码指令，执行 对系统内外中断（异常）做出响应 存储器 虚拟存储器&#x3D;主存+辅存 按存储器构成材料：磁&#x2F;半导体&#x2F;光 按存储器位置分类 内部（内存） 速度高、容量小、临时存放 向CPU提供信息 存程序和数据 设在主机或主机板上 外部（外存&#x2F;辅存） 存当前不参加运行的大量信息，在需要时调入内存 按存储器工作方式分类 读&#x2F;写存储器 RAM 只读存储器 固定只读存储器 ROM，一般用于存放系统程序BIOS和用于微程序控制 可编程只读存储器 PROM，内容可由用户一次性写入，写入后不能再修改 可擦除可编程的只读存储器 EPROM，内容可读&#x2F;写&#x2F;改，紫外线擦除信息 电擦除可编程的xxxxx EEPROM，内容可内容可读&#x2F;写&#x2F;改，电擦除信息 闪速存储器（闪存），特性介于EPROM和EEPROM之间，电信号进行信息的擦除操作。整块闪存可以在数秒内删除（以块为单位），速度远快于EPROM 可代替ROM，不可代替主存 掉电后信息不丢失 嵌入式系统中可以用Flash代替ROM存储器 相当于U盘 按访问方式分类 按地址访问 按内容访问 相联存储器 按寻址方式分类 随机存储器 RAM，对任何存储单元存入或读取数据，访问任何一个存储单元所需的时间时相同的 顺序存储器 SAM，访问数据所需时间和所在存储位置相关，例如磁带 直接存储器 DAM，介于随机存取和顺序存取，例如磁盘：磁道寻址随机，磁道内顺序寻址 cpu去寻址的时候，时间局部性：刚刚要这个地址，可能一会又要了，空间局部性：只能访问相邻的存储单元 高速缓存 存放当前最活跃的程序和数据（经常访问的），位于CPU和主存之间，容量在几千字节到几兆字节之间，速度一般比主存快5~10倍，由快速半导体存储器构成，其内容是主存局部域的副本，对程序员来说是透明的（程序员不需要关心） 内存速度比CPU慢，有时候CPU要等着内存取数据出来，cache和CPU速度差不多，取数据更快一点 cpu找不到就从内存拿，内存拿了之后给cache，cache如果满了，就要替换数据出来 cache位于主存和cpu之间 全相联就是随便哪一块都可以到随便哪块区域，冲突多 组相联映像，有上述两个的特点，按组分的。组合组间关系固定，但是组里的每一块在组里面随便，冲突较少 cache与主存地址的映射是由硬件完成的（考了6次） 影响cache命中率的因素很多，目的都是为了提高命中率 冲突次数最小 全相联-组相联-直接 DRAM是通过周期性刷新来保持数据的存储器件 外部输出设备（外设） 输入、输出设备（可屏蔽中断） 控制方式 程序查询 - - 中断驱动 也是一次只能读取一个字 直接存储器（DMA）（直接内存读取） - - 主存与外设间建立了直接的数据通路 cpu占用的系统资源是系统总线，DMA是靠I&#x2F;O设备所以是存储设备周期 计算机基本单位位（比特） b&#x2F;bit 最小的数据单位 字节 byte&#x2F;B 最小的存储单位 千字节 K&#x2F;KB兆字节 MB吉字节 GB太字节 TB进制十进制（D）二进制（B）八进制（O）十六进制（H） 09 AF（10~15），除16就行 例如 一位16进制 &#x3D; 四组8进制 - 方法（十进制与n进制） 按权展开求和 n进制-&gt;十进制 192 &#x3D; 1 * 10^2 + 9 * 10^1 + 2 * 10^0 除n取余 十进制-&gt;n进制 例子：192(D)转十进制，取余数 17(D)-&gt;?（B） 除2取余 10001 可以按权求和验证 进制加法 逢n进1 进制减法 借1当n 原码与反码0正1负，一共八位，最高位为符号位，【n-1，0】为绝对值正数 原码&#x3D;反码&#x3D;补码 -2^7 ~ 2^7 - 1 &#x3D;&gt; -128 ~ +127 负数 原码&#x3D;反码出符号位取反 补码&#x3D;反码+1 【补码】补码 &#x3D; 原码 采用补码可以简化计算机运算部件的设计 移码 &#x3D; 补码符号位取反定点数浮点数定点数，小数点位置不变的数（普通数） 直接表示，小数点不需要占用存储位 在总位数相同的情况下，浮点表示法可以表示更大的数，因为由阶码决定 当机器字长为n时，定点数的补码和移码可表示2^n个数，而其原码和反码之恶能表示2^n - 1个数（0的表示占用了两个编码） 一个二进制数N可以表示为 N &#x3D; 2^E * F 1011.10101 &#x3D; 2^4 * 0.10101 阶符 阶码 数符 尾数 尾数为纯小数 否则多余的整数丢失（精度丢失），所以小的向大的转 表示数值范围由阶码决定，精度由尾数决定 F为1时，随便多少位都只取一位 如果浮点数的阶码（包括阶符）用R位移码表示 + 尾数（包括1位数符）用M位补码表示，则这种浮点数表示数值范围： 最大正数 最小负数 工业标准IEEEE754浮点数格式：阶码-移码，尾数-原码 规格化：将位数的绝对值限定在区间[0.5,1]寻址 立即寻址最快，都不用去找 寄存器寻址速度 &gt; 直接寻址， 比从内存拿快 - 寄存器间接寻址：又从寄存器取又从内存取，&gt; 直接寻址 后面两个考得很少 采用不同寻址方式的目的：扩大寻址空间并提高编程灵活性校验码 码距&#x3D;2能检测，&gt;&#x3D;3才有纠错能力 奇偶校验码- 只能检错，不能纠错 海明码 码距&#x3D;3 利用多组数位的奇偶性来检错纠错 循环冗余码（概念） 可以检错，但不能纠错 记蓝线部分就行 RISC和CISC流水线流水线总用时 &#x3D; 第一条指令的执行时间 + （n - 1) * 最长段的时间 操作周期 &#x3D; 最长时间段 加速比 &#x3D; 顺序执行时长 &#x2F; 流水线时长吞吐率 &#x3D; 1 &#x2F; 最长时间段的倒数执行n条指令的吞吐率：n &#x2F; 流水线总用时不能采用异步控制，会增加耗费中断遇到急需处理的事件，暂停当前正在运行的程序，专区执行有关服务程序，处理完后返回源程序断点一般叫中断向量：提供所有中断服务程序的入口地址（中断向量）汇集为中断向量表中断响应时间：发出中断请求开始到进入中断服务程序响应之前，保存现场（多级中断，堆栈最有效），以便恢复现场执行源程序总线考得偏，分值低，了解即可总线分类 数据总线 地址总线 控制总线 PCI总线：并行内总线SCSI：并行外总线系统总线 &#x3D; 内总线总线宽度 内存中存放数据需要地址，所以对应地址总线4G&#x3D;2^32; 字长被数据总线存储，直接对应数据总线，为32 目的：减少了线的数量，模块化更容易200MHz&#x3D;200M个周期&#x2F;秒 &#x3D;&gt; 200次&#x2F;秒，5次传送32bit，一秒传送多少MB？ 时钟周期&#x2F;时钟频率&#x3D;cpu执行时间 总线宽度4字节&#x2F;CPU执行时间&#x3D;带宽 加密技术和认证技术- 窃听 加密 篡改 摘要 假冒 数字证书 否认 加密技术 对称加密（密文传输，密钥才能解密） 加密和解密时同意把密钥，只有一把密钥 密钥分发有缺陷，不能保证只有接收方有（因为要传过去） 非对称加密 - 被动攻击（窃听） 加密和解密不是同一把密钥，用公钥加密只能用私钥解密，反之 只有私钥可以推出公钥，反之则不行 用接收方的公钥加密明文 混合加密 对称 + 非对称 先用对称加密明文，再用对方的公钥加密对称密钥，形成数字信封 处理被动攻击 认证技术 摘要：一般和数字签名（用私钥）一起用 明文hash后和密文一起传过去，传过去解密再hash与这个摘要对比，没变化就说明没篡改 数字签名：发送方用自己的私钥对摘要进行签名（加密），得到数字签名放在密文后一起发送过去（不可否认） |||| 接收方用发送方的公钥对数字签名解密验证，验证成功消息没有被假冒+不能否认 |– 否则为假冒发送 数字证书 CA：权威机构 认证身份 处理主动攻击 可可能再分发公钥过程中被中间人篡改公钥，导致后续出现一系列问题 也可以附在信息后面 私钥：解密+签名；公钥：加密+认证（验证） 加密算法 - 公钥算法2个sa+一个cc 可靠性公式 串联：R1R2R3…… 并联：1-(1-R1)(1-R2)(1-R3)……"},{"title":"校内项目","path":"/undefined/school/","content":"基于socket的在线聊天室（原生+socket） 不给学分的课 地址：https://github.com/abulili/online-chat技术：socket + express + jquery描述：用户在自主选择头像和输入昵称后进入聊天室，实现跨浏览器(express + socket)的带图片、表情(jquery)的实时交流。在交流过程中可以使用文字转语音(pinyin)的功能 难点：太久了，有点忘了，感觉挺简单的功能。 老照片修复（django） 学校内的项目，投了个校刊，另一个项目拿的新型实用专利，感觉和当初想的内容隔了十万八千里。 修复算法是两个开源代码结合在一起的，只负责结合。 太大了传到svn上了，但是域名现在应该过期了 技术：django描述：用户在上传一张照片后可以选择修复划痕&#x2F;修复颜色&#x2F;都修复的功能，选择好之后后台进行处理跳转显示出处理前和出来后的照片。 难点：第一次接触，试了很多种方法想把这两个算法合起来，没成功，最后还是决定分开调用。 二手交易平台（vue2+springboot，前后端分离） 毕业论文产物 感觉还可以往里塞东西补充完美，再说吧 项目地址：https://github.com/abulili/secondStore技术：vue2 + elementui + springboot + mybatis-plus + mysql描述：用户在登录前只能访问主页、商品详情、登录注册页，在商品详情页进行任何操作跳转登录页。登陆后以身份的不同决定主页功能，实现管理员圈定范围内定点交易(腾讯地图 + 凸包)，在线交易、评论、交谈，商品收藏、加入购物车，相关管理，信息举报等功能。 难点： 写完一刷新，信息都没了，引入vuex-persistedstate进行持久化 地图选点的时候，由于用的vue2和官方文档不太一样，没法把圈定范围的点显示，引入vue-bmap-gl解决 上传商品图图片太大，需要压缩图片，引入image-compressor解决 在交流中用户和用户之间一对一的对话失败，并且在用户1主动私信用户2时，用户2必须也点击用户1才能看到用户1的对话，在传输信息过程中在头部加上主动用户的用户名长度和用户名，信息尾部加上被动用户的用户名长度和用户名。 后端由于部分是由mybatis-plus生成的，所以用到哪学到哪，主要是从数据库拿东西有点问题。 优化点： 前端部分： 要花钱的：身份证识别&#x2F;手机号码验证 地图交易那部分可以联通学校库，不同的学校有不同的范围&#x2F;管理 后端部分： 总之就是缺少的电商那一套 基于百度地图的练手项（springboot+html） 给学分的课，这老师教得蛮好 项目地址：https://github.com/abulili/spring-simpleCase技术：springboot + mysql + 原生html描述：对员工基本信息进行显示和管理。网站登录、员工信息的添加、查询、修改、删除操作；对员工的位置信息通过百度地图 API 来进行显示。 难点：jwt 基于vue2和nodejs的音乐系统 不给学分的课 项目地址：https://github.com/abulili/webMusicPlayer技术栈：vue2 + express + elementui + mariaDB + axios描述：一个播放音乐的网站，用户的登陆注册，能对音乐进行收藏、上传、删除上传，暂停、播放，管理员对音乐信息进行管理。 难点： 音乐播放时进度条的移动，采用组件监听的方式通过播放时长与总时长的百分比，借助vue的双向绑定特性改变。 使用BFC避免了多列布局由于宽度自动换行,通过对数据队列划分解决渲染时数据竖着排布 通过读写session对页面访问权限进行控制并渲染出对应角色访问菜单 使用了Promise.all解决了在页面初始渲染时通过不同方法获取数据的异步加载使用了nextTick解决了在页面加载后无法获取dom的行为 优化点：播放时字幕随着音乐滚动 调节音量 当时的记录：BFC 使用的fixed，块级格式上下文，规定内部区域元素不会影响到外部区域，最重要的是内部box垂直放置，浮动元素参与计算，垂直距离margin塌陷（clearfix）， 如何创建BFC？(在某些情况下，特定的CSS属性值会使元素自动创建BFC) 根元素，即HTML元素 (每当浏览器遇到一个HTML文档时，它会自动创建一个BFC，这个BFC包含了整个HTML文档的内容) float的值不为none position为absolute或fixed display的值为inline-block (指定对象为内联块元素)、table-cell (指定对象作为表格单元个,类似td)、table-caption (指定对象作为表格标题。类同于html标签caption) overflow的值不为visible BFC的使用场景 去除边距重叠现象 清除浮动（让父元素的高度包含子浮动元素） 避免某元素被浮动元素覆盖 避免多列布局由于宽度计算四舍五入而自动换行 session express-session模块 提一嘴使用v-if和v-show（css） nextTick 解决了异步渲染获取不到更新后DOM的问题了 我也有简单了解nextTick实现，它会在callbacks里面加入我们传入的函数，然后用timerFunc异步方式调用它们，首选的异步方式会是Promise。这让我明白了为什么可以在nextTick中看到dom操作结果。 对数据竖着 ceil取条数，slice进行分割 123&lt;el-row :gutter=&quot;20&quot; v-for=&quot;(row, rowIndex) in Math.ceil(MusicList.length / 4)&quot; :key=&quot;rowIndex&quot;&gt; &lt;el-col :span=&quot;6&quot; v-for=&quot;(item, colIndex) in MusicList.slice(rowIndex * 4, (rowIndex + 1) * 4)&quot; :key=&quot;colIndex&quot;&gt; 还有时间提一嘴如何进行监听去更新音乐播放器进度条 setTimeout，setinterval每个两秒重算 1234567891011this.audio.addEventListener(&#x27;timeupdate&#x27;, () =&gt; &#123; let duration = this.audio.duration; setTimeout(() =&gt; &#123; let currentTime = this.audio.currentTime this.current = currentTime console.log(&#x27;当前播放时间:&#x27;, currentTime) this.percentage = (currentTime / duration) * 100 this.percentage = this.percentage.toFixed(0) console.log(&#x27;播放进度百分比:&#x27;, this.percentage) &#125;, 1000);&#125;); 基于微信小程序的在线论坛（云开发） 给学分的课，软件工程结课产物 忘了，没啥难点吧，写起来还挺顺利的，边查边写 项目地址：https://github.com/abulili/wechat_cloudComment描述：实现了仿知乎的论坛小程序,能发布帖子并对帖子进行增删查改,能对帖子进行评论、点赞、收藏实现了评论楼中楼。 难点： 评论楼中楼的加载，最终选择评论套评论，仅显示一条，剩下的在用户点击查看更多再进行请求。 对首页帖子加载进行了性能优化,监听上滑操作后进行了节流,使得在规定时间内只触发一次 使用云函数实现了高度抽离可复用方法,使得可以一次编写多次使用 使用全局管理对象存储了用戶的登录信息,可以在任何页面得到用戶的登录状态 当时的记录：节流 节流：（时间内）事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用最先被触发的那次，直到这波过了。所以适用于函数被频繁调用的场景。 防抖： 只有过了设定的时间&amp;&amp;没在设定时间内操作后，才会执行 全局 说一下和vuex很像 vuex:数据存储中心。Vuex其实就是一个状态管理工具，所谓的状态，就是数据，通过这个工具进行管理某些数据。当多个组件都需要同一个数据时，可以将这个数据交给Vuex进行统一的管理. state:vuex的基本数据，用来存储变量，存放的数据是响应式的。 mutations:提交更改数据，同步更新状态。 actions:提交mutations，可异步操作。 getters：是store的计算属性。 modules:模块，每个模块里面有四个属性。 async&#x2F;await async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。 自执行的generate函数。利用generate函数的特性把异步的代码写成“同步”的形式,第一个请求的返回值作为后面一个请求的参数,其中每一个参数都是一个promise对象. 打僵尸游戏（unity） 跟着视频做的，排除了游戏行业，素材实在麻烦，c++写起来还是很爽，做太久都忘了 现在版本落后了，要运行得大改 项目地址：https://github.com/abulili/first_game-购物网站（jsp） 最早的课，怎么又是购物网站，忘了 jsp比较起来真难用，还得是前后端分离 项目地址：https://github.com/abulili/jsp_Web_mysql_SHOP/tree/main其他的课太落后就不管了"},{"title":"其它1","path":"/undefined/compang1/","content":"这样应该不算违反保密协议吧… 大屏项目负责部分：对接口 封装当时存在的一部分babylon方法为SDK，使其可以直接被引用 打包apk 实现大屏适配 通过优化遗留下来的方法，使响应速度提升30%，优化请求数 优化控制端分辨率 参与处理rtsp监控视频流 模型替换及改变（threeJs） 修改模型及交互条件（babylonJs） 其它网页端项目录制网页，全景图 照模板写调研文档，写招标文件 地图调研，接口调用 手机端项目迁移网页端项目至app端 uniapp"},{"title":"实习1","path":"/undefined/workOne/","content":"对我做的第一个在公司的项目做一个总结 看不懂要表达什么，再说吧 html123456&lt;el-table-column label=&quot;操作&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button size=&quot;mini&quot; @click.native.prevent=&quot;handleEdit(scope.$index, wordsLists)&quot;&gt;编辑&lt;/el-button&gt; &lt;el-button size=&quot;mini&quot; type=&quot;danger&quot; @click.native.prevent=&quot;handleDelete(scope.$index, wordsLists)&quot;&gt;移除 &lt;/el-button&gt; &lt;/template&gt;&lt;/el-table-column&gt; 12345&lt;el-table-column fixed prop=&quot;a&quot; label=&quot;详情链接&quot; width=&quot;220px&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button size=&quot;mini&quot; @click=&quot;jumpBaidu(scope.row)&quot;&gt;点击跳转百度百科&lt;/el-button&gt; &lt;/template&gt;&lt;/el-table-column&gt; vue:在引用时 1234const requestMethods = &#123; // 得到后端的服务，存关键路名（暂时只处理路名） onSuccess(response, file, fileList) &#123;&#125; &#125; 1234&lt;script src=&quot;./../../http/request.js&quot;&gt;&lt;/script&gt;methods: &#123;\tonSuccess: requestMethods.onSuccess,&#125; 获取图片imgNode,在无法用自带的file时 12345678910111213onChange(file) &#123; console.log(&#x27;onChange&#x27;, file) let id = setInterval(() =&gt; &#123; const images = document.getElementsByTagName(&#x27;img&#x27;); if (images.length != 0) &#123; // 后面记得清空 v.imgNode = images[0] clearInterval(id) // console.log(v.imgNode.src.substring(5, v.imgNode.src.length)) v.getImgLocation() &#125; &#125;, 1000); &#125;, 添加的时候就去重了 12345678910if (!v.data1.includes(&#123; key: i, label: v.wordsLists[i].content, disabled: false &#125;)) v.data1.push(&#123; key: i, label: v.wordsLists[i].content, disabled: false &#125;) 杂筛选以市州结尾，前面不带市州的字符串 1234567891011var pattern = /[^市州]+[市州]/g;var matches = word.match(pattern);if (matches) &#123; matches.forEach(function (match) &#123; if (!v.ProvinceList.includes(match)) v.ProvinceList.push(match) return true &#125;); &#125; else &#123; return false &#125; axios.post上传file 123456789101112131415imgTags(file) &#123; const formData = new FormData(); formData.append(&#x27;file&#x27;, file.__ob__.value.raw); // 将文件添加到FormData对象中 axios.post(&#x27;&#x27;, formData, &#123; // 使用axios发送POST请求到服务器 headers: &#123; &#x27;Content-Type&#x27;: &#x27;multipart/form-data&#x27; // 设置请求头为multipart/form-data &#125; &#125;).then(response =&gt; &#123; console.log(response.data.result) v.TagsDeal(response.data.result) // 处理响应数据 &#125;).catch(error =&gt; &#123; // 处理错误信息 &#125;); &#125;,"},{"title":"BFS","path":"/undefined/BFS/","content":"🔗 对于步骤一直出错，不如直接queue&lt;pair&lt;int, int&gt;&gt;; 以下为贪心推导 双端队列bfs:基本用法差不多，但是 w &#x3D; 0放头， w &#x3D; 1放尾（类似与dp）"},{"title":"背包合集","path":"/undefined/bagT/","content":"复习下 01背包、完全背包、多重背包、混合背包的板子 基础P1216 [USACO1.5] [IOI1994]数字三角形 Number Triangleshttps://www.luogu.com.cn/problem/P1216 这道题说明了背包的最终态与初始态之间的关系。 在我的理解里就是所有的路径汇总到一起形成一个唯一的最终态（值是唯一，因为是最大值） 最长公共子序列字符串 abcde 与字符串 acde 最长公共子序列acde 当出现两个不同的需要计算状态，并需要得到最终统一态，则分开计算共同判断 12f[i][j] i为A前i个字符，j为B前i个字符A的前i个字符和B的前j个字符最大有多少个相同的 最长不下降子序列以怎么样的、什么结尾是这道的核心 以ai结尾 upper_bound找出可替换的数替换 [NOIP2005] 采药https://www.luogu.com.cn/problem/P1048"},{"title":"2882. 「JOISC 2014 Day4」两个人的星座","path":"/undefined/joisc2014/","content":"题目链接oi-wiki链接题解参考 先看oi-wiki的，不懂再看这个 将[-180°,+180°] &#x3D;&gt; [0°,360°] 12if(b[i].tan &lt;= 0) b[i].tan += pi; 由极轴定义：极轴是原点向正y延伸的射线或线段。 故b[i].y &lt; 0代表极轴下半轴；当b[i].y &#x3D;&#x3D; 0 时代表点在极轴上，当b[i].x &gt; 0时表示$&#x2F;theta$为0而不为Π，在极轴下方 1if(b[i].y &lt; 0 || (b[i].y == 0 &amp;&amp; b[i].x &gt; 0)) 在u点进行极轴的改变（旋转），上下点的数量发生变化，该减减，该加加 一个点b[i]可能会被用于多个三角形的构造中，因此需要在统计完一个三角形后将涉及到的点b[i]的状态取反（即从极轴上方变为下方或从下方变为上方），以避免重复统计。 123456for (int i = 1; i &lt;= st; ++i) &#123; sum[bl[i]][b[i].c]--; ans += calc(0, b[i].c) * calc(1, a[u].c); ans += calc(1, b[i].c) * calc(0, a[u].c); sum[bl[i] ^= 1][b[i].c]++;&#125; 对每个三角形而言，涉及到的两个点都会被a[u]更新，同一条公切线会被枚举两次。 1cout &lt;&lt; ans / 4;"},{"title":"springboot","path":"/undefined/springboot/","content":"以前（见：springboot大作业）虽然也使用过，但是没有系统学过。 还是边看视频边学吧 最终目标：基础-&gt;高并发 锋迷商城视频地址：https://www.bilibili.com/video/BV12p4y187Dj 运营模式 B2C:平台与买家（小米商城） ​ 维护商品、用户 C2B2C:都是平台用户（淘宝&#x2F;闲鱼） ​ 维护买家、卖家、商品、服务 开发模式 企业级开发（供企业内部使用，无注册） 互联网开发（所有用–用户量级） 技术选型SSM企业开发框架–基础开发技术，可以用springboot代替 演化：单体-前后端分离-分布式-微服务 单体项目：一个项目里面包含这个项目中全部代码,一个应用搞定全部功能,部署到服务器上，然后用户进行请求.jsp 前后端分离：.html + ajax 分布式项目：把一个项目按照特定要求（模块或功能）拆分成多个项目，每个项目分别部署到不同的服务器上。mysql可能会挂，多个服务器访问一个mysql 基于redis实现分布式锁 分布式数据库mysql redis集群 数据库中间件 消息中间件 微服务：将一个单一应用程序开发为一组小型服务的方法，单独开发和部署 关于tomcat Tomcat只能处理200-300个请求 java部署只能用tomcat Tomcat后端的服务器可以再加（服务器集群），但可能会造成忙的忙死闲的闲死，所以需要在之前设置一个总的服务器来处理请求交给哪个服务器（负载均衡） 服务器集群：多个服务器构成的整体 服务器节点：集群中的某台服务器 负载：服务器压力 将对集群的并发请求按需分配到不同的服务器节点上 此项目涉及到的技术 项目架构：前后端分离 前端：vue+axios+layui+bootstrap+ui 后端：springboot+MyBatis+RESTful+swagger 服务器搭建：Linux、Nginx MyBatis:基于Java语言的持久层框架,它通过XML描述符或注解将对象与存储过程或SQL语句进行映射,并提供了普通SQL查询、存储过程和高级映射等操作方式 RESTful:一种架构的规范与约束、原则，符合这种规范的架构就是RESTful架构。 swagger是一款可以根据resutful风格生成的生成的接口开发文档，并且支持做测试的一款中间软件。 Nginx 可以作为静态页面的 web 服务器，万级并发 SpringBootSpringboot应用需要依赖远程服务器进行创建 springboot官方：https://start.spring.io 阿里：https://start.aliyun.com 创建要联网 Version 是项目的版本号，例：1.0-SNAPSHOT 。其中1.0是版本号，SNAPSHOT版本代表不稳定、尚处于开发中的版本。而衍生的有Release版本则代表稳定的版本 snapshot不用，平台不稳定 第二种是网页创建 解决方法： https://blog.csdn.net/C_Engineer/article/details/130835522 或者在网页上打开https://start.aliyun.com/ https://start.spring.io/ 配置springboot完成通用性配置 深色可删 maven窗口打开：https://blog.csdn.net/weixin_44438032/article/details/121701104 对自创建的文件夹和包作映射 12mybatis.mapper-locations=classpath:mappers/*Mapper.xmlmybatis.type-aliases-package=com.abc.spring.demo.entity 在启动界面给出dao包的路径就可以使用了 1@MapperScan(&quot;com.abc.spring.demo.dao&quot;) 因为springboot应用自带servlet容器-tomcat，因此无需进行额外的服务配置，所以应用只需要启动类就可以了 启动失败之源发行版 17 需要目标发行版 17 https://blog.51cto.com/u_16213423/7066869 啊啊啊啊啊今天就看不懂了-2023.11.26 换一个看算了 版本管理https://www.bilibili.com/video/BV12p4y187Dj?t=848.7&amp;p=14 https://www.bilibili.com/video/BV13a411q753 https://www.bilibili.com/video/BV1bf4y1V7Bx 电脑商城https://www.bilibili.com/video/BV1bf4y1V7Bx/?spm_id_from=333.999.0.0&amp;vd_source=32c7f6ec6ba676c7527b509106db968a 某一模块的开发 持久层开发：依据前端页面的设置规划相关的sql语句 业务层开发：核心功能控制、业务操作、异常处理 控制层开发：接收请求、处理响应 版本jdk：1.8以上，maven：3.6.1，mariadb&#x2F;mysql：5.1以上 企业电商项目建立项目 maven&#x2F;java web&#x2F;mybatis framwork&#x2F;mysql driver 数据库配置 src&#x2F;main&#x2F;resources&#x2F;application.properties 现在只用前三个 创建数据库测试连接启动Springboot主类，是否有对应Spring图形输出，有无报错（例如版本） 在单元测试类中测试数据库连接是否可以正常加载 test文件就是整个目录的测试类 在test的主类下面 12345678如果要测试某个单元，需要加载数据源信息需要Spring自动装配,使用注解进行修饰的描述@Autowired这个数据源信息是类的对象，所以要声明出来private DataSource dataSource;@Test 写注解表明是测试类void getConnection()&#123;&#125; 鼠标，是自动抛异常 现在输出看有没有这个类 有Hikar代表跑通了 出问题了老师 源发行版 17 需要目标发行版 17 jdk版本之类不匹配，要统一 project structure-&gt;project-&gt;sdk版本 ​ -&gt;modules-&gt;language level settings-&gt;javacomplier-&gt;project bytecode version选择 ​ -&gt;module选择 pom文件java.version检查 请删除该文件或确保该文件位于正确的类路径子目录中 springboot与jdk版本冲突，3.x版本不支持jdk1.8 springboot所有版本号：https://zhuanlan.zhihu.com/p/652895555 dependencies.dependency.version‘ for mysql:mysql-connector-java:jar is missing Unable to instantiate org.springframework.boot.sql.init.dependency.DependsOnDatabaseInitializationDetector [org.mybatis.spring.boot.autoconfigure.MybatisDependsOnDatabaseInitializationDetector] mybatis版本与spring不匹配 改为了2.3.0 点下面的dependency可以直接修改版本，就不用去找哪个版本号才是存在的了 所有静态资源复制到static目录下 idea对于js代码兼容性较差，编写了js代码又是不能加载 1.idea缓存清理 2.clear-&gt;install 3.rebuild 4.重启idea和操作系统 web下是要访问的静态资源 所以 localhost:8080&#x2F;web&#x2F;index.html 又肯初次加载不成功，就2，打开侧栏maven&#x2F;lifecycle&#x2F;clean双击等待加载完后install 123456789101112131415161718comment注解 盐值指加密create table t_user(\tuid int auto_increment comment &#x27;用户id&#x27;,\tusername varchar(20) not null comment &#x27;用户名&#x27;,\tpassword char(32) not null comment &#x27;密码&#x27;,\tsalt char(36) comment &#x27;盐值&#x27;,\tphone varchar(20) comment &#x27;电话号码&#x27;,\temail varchar(30) comment &#x27;电子邮箱&#x27;,\tgender int comment &#x27;性别：0-女，1-男&#x27;,\tavatar varchar(50) comment &#x27;头像&#x27;,\tis_delete int comment &#x27;是否删除：0-未删除，1-已删除&#x27;,\tcreated_user varchar(20) comment &#x27;日志-创建人&#x27;,\tcreated_time DATETIME comment &#x27;日志-创建时间&#x27;,\tmodified_user varchar(20) comment &#x27;日志-最后修改执行人&#x27;,\tmodified_time DATETIME comment &#x27;日志-最后修改事件&#x27;,\tPRIMARY key (uid)) ENGINE=INNODB DEFAULT CHARSET=utf8; 有些公司直接校验is_delete是不是1已删除，没有做真删除的操作 12345678910111213141516171819202122create table t_address(\taid int auto_increment comment &#x27;用户id&#x27;,\tuid int comment &#x27;归属的用户id&#x27;,\tname varchar(20) comment &#x27;收货人姓名&#x27;,\tprovince_name varchar(15) comment &#x27;省-名称&#x27;,\tprovince_code char(6) comment &#x27;省-行政代号&#x27;,\tcity_name varchar(15) comment &#x27;市-名称&#x27;,\tcity_code char(6) comment &#x27;市-行政代号&#x27;,\tarea_name varchar(15) comment &#x27;区-名称&#x27;,\tarea_code char(6) comment &#x27;区-行政代号&#x27;,\tzip char(6) comment &#x27;邮政编码&#x27;,\taddress varchar(50) comment &#x27;详细地址&#x27;,\tphone varchar(20) comment &#x27;手机&#x27;,\ttel varchar(20) comment &#x27;固话&#x27;,\ttag varchar(6) comment &#x27;标签&#x27;,\tis_default int comment &#x27;是否默认：0-不默认，1-默认&#x27;,\tcreated_user varchar(20) comment &#x27;创建人&#x27;,\tcreated_time Datetime comment &#x27;创建事件&#x27;,\tmodified_user varchar(20) comment &#x27;修改人&#x27;,\tmodified_time datetime comment &#x27;修改时间&#x27;,\tPRIMARY key (aid)) ENGINE=INNODB DEFAULT CHARSET=utf8; 用户注册创建用户的实体类公共字段放在实体类的基类中，BaseEntity 1public class BaseEntity implements Serializable Serializable是一个对象序列化的接口,一个类只有实现了Serializable接口,它的对象才是可序列化的 序列化就是将对象属性转变为二进制数据 1java变量命名规范--createdUser 声明方法 @Data或者generate来生成 对于老版本来说lombok有时候兼容性差 这里使用generator-getter ans setter 然后是equal的hashcode方法 -比较两个对象是否相等，定义相等的规则 toString方法 -方便进行测试 创建用户的实体类这里需要继承BaseEntity的基类 非传统三大层要用@Component修饰，spring才能自动进行对象的创建维护 而SpringBoot开发更简洁，遵循约定大于配置 持久层 规划需要执行的sql语句，通过mybatis操作数据库，做mybatis开发的流程 用户注册 insert into t_user(username, password) values (值列表) select * from t_user where username=? 123456789- **设计接口和抽象方法**，定义Mapper接口 - 目录结构下创建mapper包，在这个包下根据不同的功能模块创建不同的mapper接口,要在接口中定义sql语句抽象方法 - 创建UserMapper接口（interface） - ```java public interface UserMapper - （快速注释/**回车） - ![image-20231210215628176](D:\\Typeeasy\\image-20231210215628176.png) - 添加Mappe注解修饰 - 缺陷：一个项目中很多Mapper - 解决：主添加包路径 - ![image-20231210215845733](D:\\Typeeasy\\image-20231210215845733.png) 编写映射，定义xml映射文件，与对应的接口进行关联 资源文件，放resoureces&#x2F;mapper&#x2F; 创建接口对应的映射文件，和接口名称保持一致 https://mybatis.org/mybatis-3/zh/getting-started.html &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; namespace属性用于指当前的映射文件和哪个接口进行映射，需要指定接口的文件路径，需要标注包的完整路径接口 namespace=&quot;org.cy.store.UserMapper&quot; &lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt; &lt;select id=&quot;selectBlog&quot; resultType=&quot;Blog&quot;&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; 12345- 配置接口中的方法对应上sql语句，需要借助标签完成 - ``` insert/update/delete/select 比以前直接在方法里写sql语句好，起到了解耦的作用，sql语句变了，但是java代码不用做任何改变 建议关键词用大写，#{}占位符，因为里面的数据是动态的 id关联 select查询返回的是1~n个对象 resultType：要求表字段和属性一模一样 resultMap：表资源和类的对象属性字段名称不一致时，来自定义查询结果的映射规则 映射规则一般放在前面，resultMap标签来完成映射规则的定义 column是数据库表的字段，property是属性的名字 把id值作为下面结果的映射 改一下下划线为大写 id=&quot;insert&quot; uid没有进行插入操作，mybatis不会自动做这个表值的触发，所以要开启主键自增 加配置 mybatis.mapper-locations=classpath:mapper/*.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071- **单元测试** - 每个独立的层编写完毕后需要编写单元测试，测试当前功能 - test/mapper/下进行测试 ![image-20231211125504470](D:\\Typeeasy\\image-20231211125504470.png) - ![image-20231211125609548](D:\\Typeeasy\\image-20231211125609548.png) - 因为mybatis帮忙创建了这个接口的动态代理的实现类，现在才能用这个接口 ![image-20231211221114223](D:\\Typeeasy\\image-20231211221114223.png) - 或者![image-20231211221338913](D:\\Typeeasy\\image-20231211221338913.png) - 注解也可以，但麻烦一点##### 业务层- 规划异常 - 用户进行注册时，可能会产生被占用的错误，抛出一个异常（RuntimeException）：java自带异常太宽泛，所以自己写比较好，但自己写的可以作为自带异常的子类来继承这个异常。业务层异常的基类，ServiceException异常。异常机制 - 关于业务层的异常E - 异常的接口I -因为面向接口编程 - 接口依赖于实现类 impl - alt + fn + insert选择override重写RuntimeException父类的全部方法 - 就有很多可以new的不同的异常信息了 - 根据业务层不同的功能来详细定义具体的异常的类型，统一继承ServiceException - 正在执行数据插入操作时，服务器、数据库宕机，处于正在执行插入的过程中出现的错误InsertException- 设计接口 + 抽象方法 - 命名：I开头，业务层末尾跟上Service - 创建一个实现类的UserServiceImpl类，实现这个接口，并且实现抽象方法 - 重写接口 - 看底层需要什么参数（mapper/UserMapper），声明后再自动装配 - 做操作，思考可能出现的异常（在这里是插入异常，查询异常，也可以认为是不该出现的/不想出现的结果） - 根据数据库来决定- 单元测试 UserServiceTests - 为UserServicceImpl添加@Service业务层描述 - @Service：将当前类的对象交给Spring管理，自动创建对象及对象的维护- 测试完后想把密码不以明文形式展示，采用md5进行加密 - 串 + password + 串 ---&gt; md5算法进行加密，连续加密三次 盐值 + password + 盐值 --- 盐值本身是一个随机的字符串 - `String salt = UUID.randomUUID().toString().toUpperCase();` - 整体加密，用byte版的（因为字符串很容易转换为字节） - 将加密之后的密码重新补全设置到user对象中 - 忽略了原有莫玛强度，提示了数据的安全性 - 盐值salt也要记下来，不然没法验证密码对不对##### 控制层- 创建响应、状态描述信息、数据，这部分功能封装到一个类中，将这类方法作为返回值，返回给前端浏览器 - JsonResult - 要实现返回json数据的格式，需要继承Serializable ![img](D:\\Typeeasy\\OR@KW@80RP7XDA82(7@)N`A.png) - 方法按可能出现的返回结果进行构造- 设计请求 - 根据当前业务功能模块进行请求的设计 - ``` 请求路径：/user/reg 请求参数：User user 请求类型：POST 响应结果：JsonResult&lt;Void&gt; 处理请求 创建一个控制层对应的类UserController类，依赖于业务层的接口，要添加相应的注解@Controller @RequestMapping(&quot;users&quot;)定义什么样的接口会被拦截测试 @ResponseBody 表示此方法的响应结果以json格式进行数据的响应给前端 但是这样就每一个都要写，麻烦 推荐按组合注解 @RestController ( &#x3D; @Controller + @RespenseBody) package com.cy.store.controller; import com.cy.store.entity.User; import com.cy.store.service.IUserService; import com.cy.store.service.ex.InsertException; import com.cy.store.service.ex.UsernameDuplicatedException; import com.cy.store.util.JsonResult; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(&quot;users&quot;) public class UserController &#123; @Autowired private IUserService userService; @RequestMapping(&quot;reg&quot;) public JsonResult&lt;Void&gt; req(User user) &#123; // 创建响应结果对象 JsonResult&lt;Void&gt; result = new JsonResult&lt;&gt;(); try &#123; userService.reg(user); result.setState(200); result.setMessage(&quot;用户注册成功&quot;); &#125; catch (UsernameDuplicatedException e) &#123; // 可能碰到用户名被占用的错误 result.setState(4000); result.setMessage(&quot;用户名被占用&quot;); &#125; catch (InsertException e) &#123; // 可能碰到用户名插入时的错误 result.setState(5000); result.setMessage(&quot;注册时产生位置异常&quot;); &#125; return result; &#125; &#125; 123456789101112131415161718192021222324252627282930- 但是这样有点麻烦了，因为业务层抛出的所有异常都需要控制层去处理，如果其它业务层也有这些问题，那就还要改- 控制层优化设计 - 在控制层抽离一个父类，在这个父类中统一的去处理关于异常的相关操作。BaseController统一处理 - @ExceptionHandler 用于统一处理抛出的异常，定义在方法上面，会自动将异常对象传递给此方法的参数列表上 - @ExceptionHandler(ServerCloneException.class) 凡是ServerCloneException.class抛出的异常都会被这个方法拦截##### 前端页面注册- 点击事件，($(&quot;选择器&quot;))，再去添加点击的事件，`$.ajax()`函数是jquery封装的一个函数，通过对象调用了ajax函数，可以异步加载相关的请求。依靠的是javascript提供的一个对象XHR（XmlHttpResponse），封装了这个对象- ajax使用方式，需要传递一个方法体作为方法的参数使用；一堆大括号：方法体 接收多个参数，参数与参数之间使用&quot;,&quot;分割，每一组参数之间使用&quot;:&quot;分割，参数的值要求用字符串来标识，参数声明顺序没有要求 ```javascript $.ajax(&#123; url: &quot;&quot;, type: &quot;&quot;, data: &quot;&quot;, dataType: &quot;&quot;,//提交的数据类型，一般指定为jsons success: funciton() &#123; //当服务器正常响应客户端时，会自动调用success参数的方法，并且将服务器返回的数据以参数的形式传递给这个方法的参数上 &#125;, error: function() &#123; &#125; &#125;); 但是这样还是麻烦了 jquery提供的序列化api，#form-reg是表单的id 由后端返回的数据类型 js代码无法正常被服务器解析执行，体现在点击页面中的按钮没有任何的响应。解决方案： 在项目的maven中clear清理项目-install重新部署 在项目的file选项下-cash清理缓存 重新构建项目：build-rebuild 重启idea 重启电脑 用户登录当用户输入用户名和密码将数据提交给后台数据库进行查询，如果存在对应的用户名和密码，则登陆成功，登录成功后跳转index.html，跳转在前端 持久层 规划需要执行的sql语句 依据用户提交的用户名和密码做select查询，密码的比较在业务层执行 1select * from t_user where username=? 说明：如果在分析过程中发现某个功能模块已经被开发完成，就可以省略当前的开打步骤，但分析过程不能省略 接口设计和抽象方法 不用重复开发，单元测试无需单独执行 业务层 规划异常 用户名对应的密码错误，密码匹配失败的异常：PasswordNotMatchException异常，属于 运行时异常，业务异常 用户名未找到，UsernameNotFoundException，运行时异常，业务异常 异常编写： 业务层异常需要继承ServiceException异常类 在具体的异常类中定义构造方法（可以使用快捷键来生成，有5个构造方法） 设计业务层接口和抽象方法 直接在IUserService接口中编写抽象方法，login(String username, String password)。将当前登录成功的用户数据以当前用户对象的形式进行返回。状态管理：可以将数据保存在cookie或session中，可以避免重复度很高的数据多次频繁操作数据进行获取（用户名、用户ID等存在session中，用户头像存在cookie中） 在这里写了之后回到UserserviceImpl出现了波浪号，按波浪号导入方法即可 抽象方法实现 需要在实现类中实现父接口中抽象方法 检测用户是否存在 检测用户密码是否匹配 先获取盐值 将用户密码按相同的md5算法规则进行加密 将密码进行比较 判断用户是不是已经注销过了 在测试类中测试业务层登录的方法是否可以执行通过。 如果一个类没有手动创建就直接将这个类复制到项目，idea找不到这个类，之前缓存导致补能够正常找到这个类的符号，就重新构建项目 build-rebuild 1java: 找不到符号 控制层 处理异常 关注业务层抛出的异常，需要在统一异常处理类中进行统一的捕获和处理，如果抛出的异常类型已经在统一异常处理类中处理过，则不需要重复复添加 1234567else if(e instanceof UsernameNotFoundException) &#123; result.setState(5001); result.setMessage(&quot;用户数据不存在的异常&quot;); &#125; else if(e instanceof PasswordNotMatchException) &#123; result.setState(5002); result.setMessage(&quot;用户名密码错误的异常&quot;); &#125; 设计请求 1234请求路径：/user/login请求方式：POST请求数据：String username,String password请求结果：JSONResult&lt;User&gt; 处理请求 在UserController类中变系处理请求的方法 前端 优化 存储登陆的数据 用户会话session 存在服务器端，用于保存服务器的临时数据对象 seesion.getAttrbute(&quot;key&quot;)可以将获取seesion中的数据这种行为进行封装，因为都要经过Base层，所以封装在baseController层 封装seesion对象中数据的获取（封装父类中）、数据的设置（当用户登录成功够进行数据的设置，设置到全局的session对象） 在父类中封装两个数据：获取uid和username对应的两个方法。用户头像暂时不考虑，将来封装到cookie中 在登录的方法中将数据封装在session对象中。子类登录方法那里。服务器本身自动创建有session对象，已经是一个全局的session对象。SpringBoot可以直接使用session对象，直接将HttpSession类型的对象作为请求处理方法的参数，会自动将全局的Session对象注入到请求处理方法的session形参上。 发现之前设计的请求不再满足要求了 1234请求路径：/user/login请求方式：POST请求数据：String username,String password，HttpSession session请求结果：JSONResult&lt;User&gt; 如果服务器有session，那session会随同客户端发送给服务器，客户端的存在cookie中，每一次发送请求时，cookie又将里面的所有信息重新提交给客户端；只要服务端每次相应一个id，那客户端就会提交一次id 拦截器 统一将所有请求拦截到拦截器中，可以在拦截器中定义过滤的规则，若不满足系统设置的过滤规则，统一的处理是冲洗去打开login.html页面（重定向和转发），推荐使用重定向 有时候可能是把一个模块的分支代码部署到另一个服务器上，所以如果转发就可能出现不在一台服务器上没法转发。 SpringBoot本质是依靠springMVC来完成的。SprngMVC提供了一个HandlerInterceptor接口，用于表示定义一个拦截器。受限于自定义类，在这个类中实现这个接口。 定义一个LoginInterceptor类继承接口HandlerInterceptor 分析源码： 123456789101112//在调用所有处理请求的方法之前被自动调用执行的方法default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return true; &#125;// （jsp/login响应完之后调）在ModelAndView对象返回之后调 default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123; &#125;// 在整个请求所关联的资源被执行完毕最后所执行的方法// 一般用于资源回收// 一般最后两个都用不到 default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123; &#125; 因为下图，所以要在前端控制器之前进行拦截 注册过滤器：添加白名单（哪些资源可以在不登陆的情况下访问）、黑名单 注册过滤器的技术：借助WebMvcConfigure接口，可以将用户定义的拦截器进行注册，才可以保证拦截器能够生效和使用。定义一个类，然后让这个类实现WebMvcConfigure接口。配置信息建议存放在项目的config包结构下。 LoginInterceptorConfigurer.java 继承WebMvcConfigurer类 addInterceptors将自定义拦截器进行注册，也实现了一个接口 不要一直回车测试，浏览器机制，会提醒重定向次数过多，login.html页面无法打开，白名单黑名单都不见了 cookie清除，浏览器设为初始设置 修改密码 需要用户提交原始密码和新密码，再根据给当前登录的用户进行信息的修改操作 持久层 规划sql语句 根据uid修改用户password的值 12update t_user set password=?,modified_user=?,modified_time=? where uid=?跟踪用户的修改 根据uid查询用户数据，确保用户存在，是否被标记为已删除，输入的原始密码是否正确 1select * from t_user where uid=? 设计接口、抽象方法 UserMapper接口，将以上的两个方法的抽象定义出来，将来映射到sql语句上 sql的映射 配置到映射文件userMapper.xml中 1234567891011&lt;update id=&quot;updatePasswordByUid&quot;&gt; UPDATE t_user SET password=#&#123;password&#125;, modified_user=#&#123;modified_user&#125;, modified_time=#&#123;modified_time&#125; where uid=#&#123;uid&#125; &lt;/update&gt; &lt;select id=&quot;findByUid&quot; resultMap=&quot;UserEnityMap&quot;&gt; SELECT * FROM t_user WHERE uid=#&#123;uid&#125; &lt;/select&gt; 单元测试 业务层 规划异常 原密码错误，is_delete&#x3D;&#x3D;1、uid找不到，在用户没有发现的异常UsernotFounfException(之前有) update更新时产生的未知异常UpdateException 设计接口和抽象方法 执行用户修改密码的核心方法 之前的findByUid要放在UpdatePasswordByUid中进行辅助 在实现类中实现当前的抽象方法UserServiceImpl -changePassword 单元测试 UserServiceTests 控制层 处理异常 业务层有没有抛出异常，有就写，没有就过 新增的UpdatePasswordByUid需要配置再统一的异常处理方法中 BaseController 设计请求 /users/change_password post String oldPassword, String newPassword,HttpSession session //需要和表单中的name属性值保持一致 JsonResult&lt;void&gt; 123456789101112131415161718192021222324252627- 处理请求 - 到控制类UserController中声明出来 - 登录之后才能进行测试 ![image-20231227214643944](D:\\Typeeasy\\image-20231227214643944.png)##### 前端![image-20231227214950117](D:\\Typeeasy\\image-20231227214950117.png)#### 资料修改先分析，用户名已经放在session当中了第二部分类似密码修改![image-20231227215326182](D:\\Typeeasy\\image-20231227215326182.png)##### 持久层- 规划sql语句 ```sql update t_user set phone=?, email=?, gender=?,modified_user=?, modified_time=? where uid=? 1select * from t_user where uid=? https://www.bilibili.com/video/BV1bf4y1V7Bx?t=499.0&amp;p=12 业务层控制层前端瑞吉外卖https://www.bilibili.com/video/BV13a411q753/?p=2&amp;vd_source=32c7f6ec6ba676c7527b509106db968a 前后端分离项目1 前端技术 说明 vue vuex 全局状态管理框架 elementui axios vue-element-admin 项目脚手架（开源） 后端技术 说明 springboot 容器+mvc框架 mybatis orm框架 mybatis-plus（使用） mybatis增强工具 redis 非关系型数据库 数据库xdb用户表 1234567891011create table x_user &#123;\tid int(11) not null auto_increment,\tusername varchar(50) not null,\tpassword varchar(100) default null,\temail varchar(50) default null,\tphone varchar(20) default null,\tstatus int(1) default null,\tavatar varcahr(200) default null,\tdeleted int(1) default 0,\tprimary key(id)&#125; engine=innodb auto_increment=3 default charset=utf8 角色表 菜单表 用户角色映射表 角色菜单映射表 环境 node 稍低-v16.12.0 vue-admin-template https://panjiachen.gitee.io/vue-element-admin-site/zh/guide/ D:\\pdf\\vue-admin-template-4.4.0\\vue-admin-template-4.4.0 index.html是单页面应用（？） request.js里就有对axios的拦截配置，往里面写东西、返回相应的请求时判断成不成功 安装依赖可以设置淘宝镜像 npm config set registry http://registry.npm.taobao.org/ npm i 运行npm run dev 配置修改 关闭lint校验 后端https://start.spring.io/ https://start.aliyun.com/"},{"title":"最短路（路径规划）","path":"/undefined/road/","content":"找到实习了，想起面试的时候问了一嘴会不会路径规划和DP，这两天复习一下。打个标记，这公司还要前端还要3D oi-wiki定义 做的题在 知乎-如何加快城市路网中最短路径查询效率？ 快速总结 Floyd任意两点最短路，时间O(n3), 空间O(n2) Bellman–Ford最短路，可判负环，时间O(nm),空间O(m) SPFA卡常，但是最坏时间是O(nm),开发中稀疏图应该能用（存疑） Dijkstra非负最短路，开发用这个才最合适吧 Johnson任意两点最短路,类似Floyd，时间O(NMlogM) 其它：A*（a到b所有路径中第k短）等 Dij拓展基本都用的优先队列，没深挖，在当时已经够用了 n为边，m为顶点 暴力：时间复杂度O(n2) 二叉堆：插入修改时间复杂度O(logn),总时间复杂度O(mlogn) 优先队列：时间复杂度O(mlogm) Fibonacci 堆：插入O(1),时间复杂度O(nlogn+m)，时间复杂度最优 参考1 参考2 相对于优先队列，只是改变了抽最小节点出来的方式 …这代码也太长了 1之后再补充 线段树：类似二叉堆原理，时间复杂度O(mlogn) Johnson补充 虚拟节点0向其它所有点边权为0，bf找出0到其他店的最短路（hi） 重设边的边权w+hu-hv 跑dij A*k短路-A* 最坏O(nklogn) f(x) &#x3D; g(x) + h(x) a-&gt;b的第k小 g(x)为初始点a到当前的x点的距离；h(x)为x点到b点的最小距离， 先将其余点到a的最小值求出来（优先队列&#x2F;operator&lt;） 同时取出优先队列最小的状态，枚举点的出边，对应的子状态计入优先队列 重复操作,相当于dij 再次当访问b点达到了k次，完成"},{"title":"面试准备","path":"/undefined/faceReady/","content":"第一次面试，应该不太可能找到工作。先准备好，看看有哪些欠缺吧。 记得录音，好复盘自我介绍，语速放慢点 &lt;&#x3D;2min 先破冰：你好，请问怎么称呼您呢？ x老师非常高兴你今天来面试我 （不用破冰也行，） 再进行自我介绍，拆段说项目、生活 与这个岗位适配理由，例如专业能力（毕竟面试官也需要向上汇报） 你好，很高兴今天你来面试我。我叫xx，是明年毕业计科专业，我想应聘公司的xxxx，一直对这个专业很感兴趣，我相信前端在未来几年内还是不可替代的。在校期间成绩还不错，同时参加了一些相关竞赛，做了一些项目。获得并学习到了xx。我也是一个很喜欢进行探索学习，喜欢新事物的人，希望可以在这方面进行发展，有机会进入贵公司工作。 我做的项目巴拉巴拉巴拉，怎么做的，有什么难点，才好提问 其它问题： 为什么选择我们公司首先是我个人的职业发展规划，我觉得自己认真的性格加上专业，很适合这个岗位，也希望能在xx岗位长期发展。我举得贵公司可以让我发挥自己的优势，得到成长。 职业发展规划：分阶段，快速熟悉，接触核心业务，独立带项目 你认为你最大的优点是什么？执行能力强，学习探索能力较强，不懂的问题能主动通过自己的方式解决，解决问题念能力强。比如竞赛经历使我对调bug很擅长 缺点在有人解决问题时看见错误会怀疑自己有问题，不敢提。-会委婉说有没有可能&#x2F; 公开演讲能力欠缺。 作为应届生，在工具使用趋势方面缺乏经验，关注一些博主，保持信息获取 加班作为新人刚进新岗位加班很正常，为跟上工作节奏，我也会在初期投入时间学习，尽快熟悉业务。其此，随着工作的熟练，我会替身自己的工作效率，减少无效加班，请问公司的加班情况什么样？ 期望薪资4500 有什么问的工作内容，转正， 第一次面试还挺紧张，谢谢你的时间，我们聊完之后，1-10分对我感兴趣的程度是几分，为什么是这个分数呢能告诉我吗"},{"title":"vue3后台管理系统","path":"/undefined/vue3.2后台管理心得/","content":"思维导图说不清楚的放在这里 vue-cli: 基于插件的架构，所以依赖名：@vue/cli-plugin- 开头 插件可以修改 webpack 的内部配置，也可以向 vue-cli-service 注入命令 以vue-cli-service访问 不是每个应用都需要是一个单页应用。Vue CLI 支持使用 vue.config.js 中的 pages 选项构建一个多页面的应用。构建好的应用将会在不同的入口之间高效共享通用的 chunk 以获得最佳的加载性能。 静态资源可以通过两种方式进行处理： 在 JavaScript 被导入或在 template&#x2F;CSS 中通过相对路径被引用。这类引用会被 webpack 处理。 放置在 public 目录下或通过绝对路径被引用。这类资源将会直接被拷贝，而不会经过 webpack 的处理。 当你在 JavaScript、CSS 或 *.vue 文件中使用相对路径 (必须以 . 开头) 引用一个静态资源时，该资源将会被包含进入 webpack 的依赖图中。在其编译过程中，所有诸如 &lt;img src=&quot;...&quot;&gt;、background: url(...) 和 CSS @import 的资源 URL 都会被解析为一个模块依赖。 例如，url(./image.png) 会被翻译为 require(&#39;./image.png&#39;)，而： 1&lt;img src=&quot;./image.png&quot;&gt; 将会被编译到： 1h(&#x27;img&#x27;, &#123; attrs: &#123; src: require(&#x27;./image.png&#x27;) &#125;&#125;) 在其内部，我们通过 webpack 的 Assets Modules 配置，用版本哈希值和正确的公共基础路径来决定最终的文件路径，并将小于 8KiB 的资源内联，以减少 HTTP 请求的数量。 你可以通过 chainWebpack 调整内联文件的大小限制。例如，下列代码会将内联图片资源限制设置为 4KiB： 123456789101112// vue.config.jsmodule.exports = &#123; chainWebpack: config =&gt; &#123; config.module .rule(&#x27;images&#x27;) .set(&#x27;parser&#x27;, &#123; dataUrlCondition: &#123; maxSize: 4 * 1024 // 4KiB &#125; &#125;) &#125;&#125; URL 转换规则 # 如果 URL 是一个绝对路径 (例如 /images/foo.png)，它将会被保留不变。 如果 URL 以 . 开头，它会作为一个相对模块请求被解释且基于你的文件系统中的目录结构进行解析。 如果 URL 以 ~ 开头，其后的任何内容都会作为一个模块请求被解析。这意味着你甚至可以引用 Node 模块中的资源： 1&lt;img src=&quot;~some-npm-package/foo.png&quot;&gt; 如果 URL 以 @ 开头，它也会作为一个模块请求被解析。它的用处在于 Vue CLI 默认会设置一个指向 &lt;projectRoot&gt;/src 的别名 @。**(仅作用于模版中)** 任何放置在 public 文件夹的静态资源都会被简单的复制，而不经过 webpack。你需要通过绝对路径来引用它们。 注意我们推荐将资源作为你的模块依赖图的一部分导入，这样它们会通过 webpack 的处理并获得如下好处： 脚本和样式表会被压缩且打包在一起，从而避免额外的网络请求。 文件丢失会直接在编译时报错，而不是到了用户端才产生 404 错误。 最终生成的文件名包含了内容哈希，因此你不必担心浏览器会缓存它们的老版本。 public 目录提供的是一个应急手段，当你通过绝对路径引用它时，留意应用将会部署到哪里。如果你的应用没有部署在域名的根部，那么你需要为你的 URL 配置 publicPath 在模板中，你首先需要向你的组件传入基础 URL： 12345data () &#123; return &#123; publicPath: process.env.BASE_URL &#125;&#125; 然后： 1&lt;img :src=&quot;`$&#123;publicPath&#125;my-image.png`&quot;&gt; 何时使用 public 文件夹 # 你需要在构建输出中指定一个文件的名字。 你有上千个图片，需要动态引用它们的路径。 有些库可能和 webpack 不兼容，这时你除了将其用一个独立的 &lt;script&gt; 标签引入没有别的选择。 非必要不用public文件夹 调整 webpack 配置最简单的方式就是在 vue.config.js 中的 configureWebpack 选项提供一个对象： 12345678// vue.config.jsmodule.exports = &#123; configureWebpack: &#123; plugins: [ new MyAwesomeWebpackPlugin() ] &#125;&#125; 该对象将会被 webpack-merge 合并入最终的 webpack 配置。 警告 有些 webpack 选项是基于 vue.config.js 中的值设置的，所以不能直接修改。例如你应该修改 vue.config.js 中的 outputDir 选项而不是修改 output.path；你应该修改 vue.config.js 中的 publicPath 选项而不是修改 output.publicPath。这样做是因为 vue.config.js 中的值会被用在配置里的多个地方，以确保所有的部分都能正常工作在一起。 如果你需要基于环境有条件地配置行为，或者想要直接修改配置，那就换成一个函数 (该函数会在环境变量被设置之后懒执行)。该方法的第一个参数会收到已经解析好的配置。在函数内，你可以直接修改配置，或者返回一个将会被合并的对象： 12345678910// vue.config.jsmodule.exports = &#123; configureWebpack: config =&gt; &#123; if (process.env.NODE_ENV === &#x27;production&#x27;) &#123; // 为生产环境修改配置... &#125; else &#123; // 为开发环境修改配置... &#125; &#125;&#125; Vue CLI 内部的 webpack 配置是通过 webpack-chain 维护的。这个库提供了一个 webpack 原始配置的上层抽象，使其可以定义具名的 loader 规则和具名插件，并有机会在后期进入这些规则并对它们的选项进行修改。 你可以通过传递 --mode 选项参数为命令行覆写默认的模式。例如，如果你想要在构建命令中使用开发环境变量： 1vue-cli-service build --mode development —官方文档 package.json 文件里的 browserslist 字段 (或一个单独的 .browserslistrc 文件)，指定了项目的目标浏览器的范围。这个值会被 @babel&#x2F;preset-env 和 Autoprefixer 用来确定需要转译的 JavaScript 特性和需要添加的 CSS 浏览器前缀。 12345&quot;config&quot;: &#123; &quot;commitizen&quot;: &#123; &quot;path&quot;: &quot;node_modules/cz-customizable&quot; &#125; &#125; commitizen” 配置项用于指定使用的 Commitizen 工具的路径。Commitizen 是一个用于规范化提交信息的工具，它有助于生成符合规范的 Git 提交消息，使项目的提交历史更加清晰和易于理解。具体来说： &#x2F;&#x2F; “path” 指定了 Commitizen 工具的路径，这里指定为 “node_modules&#x2F;cz-customizable”。这表示项目将使用 cz-customizable 包中的 Commitizen 工具。 可以使用 git cz 命令来生成规范化的提交消息，然后按照提示填写相应的信息。 service.interceptors.response.use 是 Axios 中的一个拦截器（interceptor）用于在发送网络请求后，在接收响应之前对响应数据进行处理。这是一个非常有用的功能，可用于全局或局部地处理响应数据，例如处理错误、添加通用的处理逻辑等。 具体来说，service.interceptors.response.use 通常用于以下目的： 处理成功的响应数据：您可以在这个拦截器中处理成功的响应数据，例如提取有用的数据或进行某些后续操作。如果您的网络请求成功，那么这个拦截器将接收到服务器返回的响应数据。 处理错误响应：您可以在这个拦截器中处理请求失败或服务器返回的错误。这包括处理 HTTP 错误状态码（如 404、500 等）或应用程序定义的错误（例如，如果服务器返回一个错误的 JSON 格式或特定错误消息）。 对响应进行通用处理：您可以在这里执行一些通用的处理，例如显示通知、记录请求和响应等。这可以用于全局错误处理或应用程序级别的通用逻辑。 123456789101112service.interceptors.response.use( // 第一个参数处理成功响应 function (response) &#123; // 处理成功的响应逻辑 return response; &#125;, // 第二个参数处理错误响应 function (error) &#123; // 处理错误响应逻辑 return Promise.reject(error); &#125;); service.interceptors.request.use 是 Axios 中用于添加请求拦截器的方法，它允许您在发送请求之前对请求进行修改或添加自定义逻辑。让我详细解释它的意义： service: 这是一个之前通过 axios.create(&#123;&#125;) 创建的 Axios 实例，它代表了一个可以用于发起网络请求的对象。 interceptors: Axios 拥有请求拦截器和响应拦截器，这里使用的是请求拦截器。拦截器允许您在请求发送或响应返回时执行一些操作。 request.use(callback, errorCallback): 这个方法用于添加一个请求拦截器，其中 callback 是一个函数，它会在发送请求之前执行。errorCallback 是一个可选的函数，它会在请求拦截器发生错误时执行。 在具体的代码中，您可以看到以下操作： 如果本地存储中存在一个名为 ‘token’ 的数据，就会执行请求拦截器的 config 回调函数，该函数用于修改请求的配置对象 config。 在这个回调函数中，首先检查了一个名为 ‘token’ 的数据，如果存在并且满足 diffTokenTime() 的条件，将执行以下操作： 调用 this.$store.dispatch(&#39;app/logout&#39;) 以触发 Vuex 中的 app/logout 动作（通常用于用户退出登录的操作）。 返回一个 Promise，拒绝它并抛出一个 ‘token 失效’ 的错误。 如果没有满足条件，将在请求的 config 对象中设置 Authorization 头部，以包含存储在本地的 ‘token’ 数据。 这种方式允许您在每个请求发起之前对请求进行检查和修改。通常，它用于添加身份验证信息、设置请求头、记录请求日志等操作。 utils 文件夹通常用于存放各种实用工具函数、帮助函数以及通用工具类。这些工具函数和类可以在整个项目中共享和重复使用，以提高代码的可维护性和可重用性。 以下是一些常见的用途，通常会在 utils 文件夹中放置的内容： 工具函数：包括各种通用的 JavaScript 函数，例如日期处理、字符串操作、数组操作、数学计算等。这些函数可以帮助简化代码，减少重复劳动。 HTTP 请求处理：如果您的应用程序需要与后端进行 HTTP 请求，您可以将处理请求和响应的功能封装到一个或多个文件中，以便在整个应用程序中重用。 验证函数：如果您需要对用户输入的数据进行验证，可以创建一些验证函数，以确保数据的完整性和合法性。 配置文件：存放一些应用程序的配置信息，例如 API 地址、密钥、常量等。这些配置信息可以集中管理，方便在应用程序中引用。 日志记录器：如果您需要记录应用程序的日志，可以创建一个日志记录器工具，用于记录和管理日志消息。 路由帮助函数：在使用路由库（如 Vue Router 或 React Router）时，可以创建一些帮助函数来处理路由导航、权限控制等。 格式化函数：用于格式化数据的函数，例如货币格式、日期时间格式、数字格式等。 通用组件：如果您的应用程序包含可在多个页面或组件中重复使用的通用组件，可以将这些组件放在 utils 文件夹中。 测试工具：用于单元测试或集成测试的工具函数和测试辅助函数。 总之，utils 文件夹通常包含与项目相关的各种通用工具，这些工具可以帮助简化代码、提高开发效率并提供更好的代码组织和维护。但请确保按照项目的需求和规范来组织和命名这些工具函数和类。 api 文件夹通常用于存放与后端 API 通信相关的代码。这包括定义和管理 API 请求、处理响应以及与后端服务进行数据交互的功能 &lt;router-view /&gt; 是 Vue Router 的核心概念之一，它用于渲染匹配当前路由的组件内容。具体来说： 当你的应用程序导航到不同的路由时，Vue Router 会根据路由规则确定要显示哪个组件。 &lt;router-view /&gt; 元素充当容器，用于呈现这些匹配的组件。 你可以将 &lt;router-view /&gt; 放在你的应用程序布局中的任何地方，以确保匹配的组件被正确渲染。 所以，这个代码片段表示你的组件模板中唯一的内容是一个用于呈现路由组件的 &lt;router-view /&gt; 元素。这是构建具有多个视图和页面的单页应用程序时常见的方式。 URL 中的哈希值（hash）和传统的浏览器历史记录中的路径在使用方式和行为上有一些区别： 哈希值路径（例如 #/home）： 这种方式使用 URL 中的哈希部分（通常是 # 后面的内容）来表示路由路径。 哈希路径的变化不会触发浏览器向服务器发送请求。这意味着，对于前端路由，页面的切换是在客户端完成的，不会导致页面的完全重新加载。 哈希路径在单页应用程序（SPA）中常用，因为它不需要服务器端配置，且可以在前端路由中进行导航。 传统路径（例如 /home）： 这种方式使用 URL 中的标准路径来表示路由路径，不涉及哈希部分。 传统路径的变化通常会导致浏览器向服务器发送请求，服务器需要响应并提供相应的页面。这会导致页面完全重新加载。 传统路径通常用于传统的多页应用程序，其中每个不同的路径对应于服务器上的不同页面。 在前端开发中，哈希路径通常更适用于单页应用程序（SPA），因为它们可以在不刷新整个页面的情况下进行页面切换，提供更好的用户体验。传统路径通常用于传统的多页应用程序或需要与服务器进行交互的情况。不过，也可以使用前端路由库（如 Vue Router）来实现传统路径的前端导航，而不需要完全重新加载页面。 表单验证通常是通过 Vue 的 v-model 指令和 ref 来处理的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;form ref=&quot;myForm&quot; @submit.prevent=&quot;submitForm&quot;&gt; &lt;input v-model=&quot;formData.username&quot; placeholder=&quot;Username&quot; /&gt; &lt;input v-model=&quot;formData.password&quot; type=&quot;password&quot; placeholder=&quot;Password&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref &#125; from &#x27;vue&#x27;;export default &#123; setup() &#123; // 创建表单引用 const formRef = ref(null); // 表单数据 const formData = &#123; username: &#x27;&#x27;, password: &#x27;&#x27;, &#125;; // 提交表单时的处理函数 const submitForm = () =&gt; &#123; // 使用 formRef.value.validate 来触发表单验证 formRef.value.validate((valid) =&gt; &#123; if (valid) &#123; // 表单验证通过，可以执行提交操作 console.log(&#x27;Form is valid&#x27;); // 这里可以执行提交表单的逻辑 &#125; else &#123; // 表单验证失败 console.log(&#x27;Form is invalid&#x27;); &#125; &#125;); &#125;; return &#123; formRef, formData, submitForm, &#125;; &#125;,&#125;;&lt;/script&gt; 1234567891011在 &lt;el-form-item&gt; 元素中配置 prop 属性的作用是将该表单项与表单数据对象中的字段关联起来，从而使表单项的值能够正确地绑定到数据对象的对应字段。具体来说，prop 属性的值应该与表单数据对象中的字段名一致，例如 prop=&quot;username&quot; 表示该表单项与表单数据对象中的 username 字段相关联。这样，当用户在表单项中输入数据时，Vue.js 就会自动将这些数据更新到 form.username 这个字段中。配置 prop 属性的好处包括： 数据绑定：可以确保表单项的值与数据对象中的字段保持同步，无需手动处理数据的收集和更新。 表单验证：如果使用了 Element UI 的表单验证功能，配置了 prop 属性后，会自动应用表单验证规则到关联的字段上，从而方便地进行表单验证。 表单提交：在提交表单时，可以直接使用数据对象，而不需要单独获取每个表单项的值。 v-slot 是 Vue 3 中的新语法，用于定义具名插槽。 #default 是 Vue 2 中的语法，用于定义匿名插槽。 在 Vue 2 中，你可以使用 v-slot 来定义具名插槽，但一般情况下，#default 用于匿名插槽，而具名插槽则使用 v-slot:name Vue Router 是 Vue.js 官方的路由管理器 带name “没有硬编码的 URL” 意味着你不需要在应用程序的各个地方手动编写 URL。而是使用路由的名称（name）来引用路由，使得在整个应用程序中，路由的 URL 都是自动生成和管理的。 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 全局单例模式管理： 这是一种设计模式，通常用于在应用程序中维护全局状态。在 Vue.js 中，这可以通过 Vuex 来实现，它是一个专门用于状态管理的库。使用 Vuex，你可以将应用程序的共享状态抽取出来，以一个全局单例（单一的数据存储）的方式管理。这意味着无论在你的应用程序中的哪个组件，都可以访问和修改相同的状态，而不需要手动传递数据或处理事件。 Vue.js 的默认组件通信方式（父组件传递给子组件或通过事件传递）变得不太适用，因为兄弟组件之间没有直接的父子关系。(vuex-store) 每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的**状态 (state)**。Vuex 和单纯的全局对象有以下两点不同： Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 https://vuex.vuejs.org/zh/guide/#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84-store 在 Vuex 中，所有的应用程序状态都存储在一个单一的 JavaScript 对象中，这个对象被称为“状态树”或“存储”（store）。这个状态树包含了整个应用程序的状态，无论应用中有多少组件或模块，它们都共享这个状态树。 关键点如下： 单一数据源 (SSOT)： Vuex 鼓励将应用程序的所有状态集中管理，这意味着你不需要在不同的组件之间传递状态或维护多个分散的状态副本。这种集中式管理使得状态更加可维护和可预测。 一个 store 实例： 在一个 Vue.js 应用中，通常只会创建一个 Vuex store 实例。这个实例在整个应用中起到全局状态管理的作用。无论你在哪个组件中需要访问状态，都可以通过这个 store 实例来获取或修改状态。 模块化： 虽然整个应用共享一个状态树，但你可以使用 Vuex 的模块化系统来将状态树拆分为多个模块。这可以帮助你在大型应用中更好地组织状态，每个模块都有自己的状态、mutations、actions 等。 数据响应式系统： Vue 使用响应式系统来追踪数据的变化。当数据发生变化时，Vue 会自动更新视图以反映这些变化。这个系统依赖于 JavaScript 的事件循环（Event Loop）机制。如果 mutation 是异步的，那么它可能无法在数据变化之前同步提交变化，从而导致视图和状态不一致。 开发者工具： Vuex 提供了强大的开发者工具，可以追踪和调试状态的变化。如果 mutation 是异步的，这些工具将变得不可靠，因为它们无法准确地追踪异步操作的状态变化。 同步函数是一种在执行过程中不会阻塞或暂停程序执行的函数。当调用一个同步函数时，它会立即执行其中的代码，并在执行完毕后返回结果。同步函数通常用于处理那些不涉及异步操作（如网络请求、文件读写等）的任务。 异步函数是一种可能会在执行过程中暂停程序，等待某些操作完成后再继续执行的函数 timer &amp;&amp; clearTimeout(timer);：这一行是在每次滚动事件触发时，首先清除之前设置的定时器，以确保在下一次滚动事件之前不会执行函数。"},{"title":"vue项目的创建过程","path":"/undefined/vue项目创建过程/","content":"首先打开cmd，键入vue ui打开vue图形界面 将建好的空白文件夹路径粘贴到更多-管理-创建 手动配置，不保存预设 涉及到sass&#x2F;css&#x2F;eslink、linter&#x2F;vuex&#x2F;router、axios、husky、vue-vli app.vue好像是整体都有的 “app.vue是vue页面资源的首加载项，是主组件，页面入口文件，所有页面都是在App.vue下进行切换的；也是整个项目的关键，app.vue负责构建定义及页面组件归集。 app.vue中不但可以当做是网站首页,也可以写所有页面中公共需要的动画或者样式， 所有的页面都是在app.vue中进行切换的 ref 属性 ref 属性被用来给元素或子组件注册引用信息(id的替代者),相当于对页面元素或子组件标识 import { Edit } from ‘@element-plus&#x2F;icons-vue’ 直接引用，组件首字母大小 aria-hiddenhttps://blog.csdn.net/qq_54334713/article/details/127344641 1--legacy-peer-deps npm run serve 拖入prettierrc的配置文件 在配置下.eslintrc.js里的rules 新增 为了解决eslint与prettier冲突indent: 0,‘space-before-function-paren’: 0 git commit代码提交规范 npm install -g &#99;&#111;&#x6d;&#x6d;&#x69;&#116;&#105;&#122;&#x65;&#x6e;&#x40;&#52;&#46;&#50;&#46;&#x34;npm i &#99;&#x7a;&#45;&#99;&#x75;&#115;&#x74;&#x6f;&#x6d;&#x69;&#x7a;&#97;&#98;&#108;&#x65;&#x40;&#x36;&#46;&#x33;&#x2e;&#48; –save-dev 123456789101112131415&lt;template&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;router-view /&gt;&lt;/template&gt;&lt;script setup&gt;const boxWidth = &#x27;100px&#x27;&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt;.box &#123;width: v-bind(boxWidth);height: 100px;background-color: red;&#125;&lt;/style&gt;vue3.0 css绑定js"},{"title":"linee","path":"/undefined/linee/","content":"线段是否相交123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;template&lt;class T&gt; bool judge2(T a, T b, T c, T d)&#123; if(max(a.first , b.first) &gt;= min(c.first, d.first) &amp;&amp; max(c.first, d.first) &gt;= min(a.first, b.first) &amp;&amp; max(a.second, b.second) &gt;= min(c.second, d.second) &amp;&amp; max(c.second, d.second) &gt;= min(a.second, b.second)) return true; return false; &#125;template&lt;class T&gt; bool judge1(T a, T b, T c, T d)&#123;//跨立实验 if(!judge2(a, b, c, d)) return false; double d1 = (a.first - c.first) * (d.second - c.second) - (d.first - c.first) * (a.second - c.second); double d2 = (d.first - c.first) * (b.second - c.second) - (b.first - c.first) * (d.second - c.second); double d3 = (c.first - a.first) * (b.second - a.second) - (b.first - a.first) * (c.second - a.second); double d4 = (b.first - a.first) * (d.second - a.second) - (d.first - a.first) * (b.second - a.second); if(d3 * d4 &gt;= 0 &amp;&amp; d1 * d2 &gt;= 0) return true; else return false;&#125;//一般做题是先快速排斥， 后跨立int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; pair&lt;double, double&gt; p[4]; cin &gt;&gt; p[0].first &gt;&gt; p[0].second &gt;&gt; p[1].first &gt;&gt; p[1].second &gt;&gt; p[2].first &gt;&gt; p[2].second &gt;&gt; p[3].first &gt;&gt; p[3].second; if (judge1(p[0], p[1], p[2], p[3])) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; return 0;&#125; 线段相交是否规范（只能过90%数据，先占个位） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//#include&lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;vector&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;climits&gt;#define IOS ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL);using namespace std;const int maxx = 1e4 + 5;const int maxn = 1e6 + 5;#define N 10000100#define ll long long#define endl &#x27; &#x27;const ll mod = 998244353;#define test printf(&quot;-------------------------- &quot;);#define re(a) memset((a), 0, sizeof((a)))#define remax(a) memset((a), 0x3f3f3f3f, sizeof((a)))#define PII pair&lt;int, int&gt;const double pi=acos(-1.0);inline int llog(int n)&#123; return 31 - __builtin_clz(n);&#125; //取对数// struct cmp&#123;// friend bool operator &gt; (const struct scoree &amp;a, const struct scoree &amp;b)&#123;// return a.score &gt; b.score;// &#125;// &#125;;template&lt;class T&gt; bool judge2(T a, T b, T c, T d)&#123; if(max(a.first , b.first) &gt;= min(c.first, d.first) &amp;&amp; max(c.first, d.first) &gt;= min(a.first, b.first) &amp;&amp; max(a.second, b.second) &gt;= min(c.second, d.second) &amp;&amp; max(c.second, d.second) &gt;= min(a.second, b.second)) return true; return false;&#125;template&lt;class T&gt; bool judge1(T a, T b, T c, T d)&#123; if(!judge2(a, b, c, d))&#123; return 0; &#125; double d1 = (a.first - c.first) * (d.second - c.second) - (d.first - c.first) * (a.second - c.second); double d2 = (d.first - c.first) * (b.second - c.second) - (b.first - c.first) * (d.second - c.second); double d3 = (c.first - a.first) * (b.second - a.second) - (b.first - a.first) * (c.second - a.second); double d4 = (b.first - a.first) * (d.second - a.second) - (d.first - a.first) * (b.second - a.second); if(d3 * d4 &gt;= 0 &amp;&amp; d1 * d2 &gt;= 0)&#123; return true; &#125; else return false;&#125;bool judge3(PII a, PII b, PII c, PII d) &#123; if((b.first - a.first) * (c.first - d.first) + (b.second - a.second) * (d.second - c.second) == 0) &#123; return true; &#125; return false;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; pair&lt;double, double&gt; p[4]; cin &gt;&gt; p[0].first &gt;&gt; p[0].second &gt;&gt; p[1].first &gt;&gt; p[1].second &gt;&gt; p[2].first &gt;&gt; p[2].second &gt;&gt; p[3].first &gt;&gt; p[3].second; if(judge1(p[0], p[1], p[2], p[3]))&#123; if(judge3(p[0], p[1], p[2], p[3])) cout &lt;&lt; 1 &lt;&lt; endl; else cout &lt;&lt; 2 &lt;&lt; endl; &#125; else cout &lt;&lt; 0 &lt;&lt; endl; &#125; return 0;&#125;"},{"title":"lca(最近公共祖先)","path":"/undefined/lca/","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 5e5 + 5;const int DEG = 30;#define re(a) memset(a, -1, sizeof(a))struct Edge&#123; int to, next;&#125;edge[maxn * 2];int head[maxn], tot;void addedge(int u, int v)&#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;void init()&#123; tot = 0; re(head);&#125;int fa[maxn][DEG], deg[maxn];void bfs(int root)&#123; queue&lt;int&gt; que; deg[root] = 0; fa[root][0] = root; que.push(root); while(!que.empty())&#123; int tmp = que.front(); que.pop(); for(int i = 1; i &lt; DEG; ++i)&#123; fa[tmp][i] = fa[fa[tmp][i - 1]][i - 1]; &#125; for (int i = head[tmp]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(v == fa[tmp][0]) continue; deg[v] = deg[tmp] + 1; fa[v][0] = tmp; que.push(v); &#125; &#125;&#125;int lca(int u, int v)&#123; if(deg[u] &gt; deg[v])&#123; swap(u, v); &#125; int hu = deg[u], hv = deg[v]; int tu = u, tv = v; for (int det = hv - hu, i = 0; det; det &gt;&gt;= 1, ++i)&#123; if(det &amp; 1) tv = fa[tv][i]; &#125; if(tu == tv) return tu; for(int i = DEG - 1; i &gt;= 0; --i)&#123; if(fa[tu][i] == fa[tv][i])&#123; continue; &#125; tu = fa[tu][i]; tv = fa[tv][i]; &#125; return fa[tu][0];&#125;bool flag[maxn];int main()&#123; int n, m, s; init(); memset(flag, false, sizeof(flag)); cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for (int i = 1; i &lt; n; ++i)&#123; int a, b; cin &gt;&gt; a &gt;&gt; b; addedge(a, b); addedge(b, a); flag[b] = true; &#125; int root; for (int i = 1; i &lt;= n; ++i)&#123; if(!flag[i]) &#123; root = i; break; &#125; &#125; bfs(s);//根节点 for (int i = 0; i &lt; m; ++i)&#123; int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; lca(a, b) &lt;&lt; endl; &#125; return 0;&#125; cost12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 5e5 + 5;#define re(a) memset(a, 0, sizeof(a));vector&lt;int&gt; v[maxn], w[maxn];int fa[maxn][31], cost[maxn][31], dep[maxn];int n, m;int a, b, c;void dfs(int root, int faa)&#123; fa[root][0] = faa; dep[root] = dep[fa[root][0]] + 1; for(int i = 1; i &lt; 31; ++i)&#123; fa[root][i] = fa[fa[root][i - 1]][i - 1]; //cost[root][i] = cost[fa[root][i - 1]][i - 1]; &#125; int sz = v[root].size(); for (int i = 0; i &lt; sz; ++i)&#123; if(v[root][i] == faa) continue; //cost[v[root][i]][0] = w[root][i]; dfs(v[root][i], root); &#125;&#125;int lca(int x, int y)&#123; if(dep[x] &gt; dep[y]) swap(x, y); int temp = dep[y] - dep[x]; //, ans = 0; for (int j = 0; temp; ++j, temp &gt;&gt;= 1) if(temp &amp; 1) // ans += cost[y][j]; y = fa[y][j]; if (y == x) return y; for (int j = 30; j &gt;= 0 &amp;&amp; y != x; --j)&#123; if(fa[x][j] != fa[y][j]) &#123; //ans += cost[x][j] + cost[y][j]; x = fa[x][j]; y = fa[y][j]; &#125; &#125; //ans += cost[x][0] + cost[y][0]; return fa[x][0];&#125;bool flag[maxn];int main()&#123; re(fa); re(cost); re(dep); int s; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for(int i = 1; i &lt; n; ++i)&#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b; //++a, ++b; v[a].push_back(b); v[b].push_back(a); // w[a].push_back(c); // w[b].push_back(c); &#125; dfs(s, 0); //cin &gt;&gt; m; for (int i = 0; i &lt; m; ++i)&#123; int a, b; cin &gt;&gt; a &gt;&gt; b; //++a, ++b; cout &lt;&lt; lca(a, b) &lt;&lt; endl; &#125; return 0;&#125;"},{"title":"最小生成树","path":"/undefined/tree-min/","content":"Kruskal123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;const int maxn = 1e5 + 5;int pre[maxn];struct node&#123; int from, to, w;&#125;g[maxn];bool cmp(node a, node b)&#123; return a.w &lt; b.w;&#125;void init()&#123; for(int i = 1; i &lt;= n; ++i)&#123; pre[i] = i; &#125;&#125;int find(int x)&#123; if(pre[x] == x) return x; return pre[x] = find(pre[x]);&#125;// void merge(int x, int y)&#123;//看个人习惯，也可以写到kru内部// x = find(x);// y = find(y);// if(x != y)// pre[x] = y;// &#125;int kru(int n, int m)&#123; int ans = 0, cnt_edge = 0; sort(g, g + m, cmp); for (int i = 0; i &lt; m; ++i)&#123; int x = g[i].from; int y = g[i].to; x = find(x), y = find(y); if(x != y)&#123; pre[x] = y; ans += g[i].w; ++cnt_edge; if(cnt_edge == n - 1) &#123; cout &lt;&lt; ans; return; &#125; &#125; &#125; cout &lt;&lt; &quot;没连通&quot;;&#125;int main()&#123; init(); return 0;&#125; prim123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;#define re(a) memset(a, 0, sizeof(a));#define remax(a) memset(a, 0x3f, sizeof(a));#define PII pair&lt;int, int&gt;const int maxn = 1e4 + 5;int dis[maxn], e[maxn][maxn];int n;bool vis[maxn];int ans;int prim(int s)&#123; remax(dis); re(vis); priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; q; dis[s] = 0; for (int i = 0; i &lt; n; ++i)&#123; int u = -1, minx = 0x3f3f3f; for (int j = 0; j &lt; n; ++j)&#123; if(!vis[j] &amp;&amp; dis[j] &lt; minx)&#123; u = j; minx = dis[j]; &#125; &#125; if(u == -1) return -1; vis[u] = true; ans += dis[u]; for (int v = 0; v &lt; n; ++v)&#123;//中间点 if(!vis[v] &amp;&amp; e[u][v] != 0x3f3f3f3f) dis[v] = min(dis[v], e[u][v]); &#125; &#125; return ans;&#125;int main()&#123; return 0;&#125;"},{"title":"树状数组","path":"/undefined/treeArray/","content":"差分12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1e5;int a[maxn];int sum[maxn];int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; a[i]; sum[i] = a[i] - a[i - 1]; &#125; int l, r, c; for (int i = 1; i &lt;= m; ++i)&#123; cin &gt;&gt; l &gt;&gt; r &gt;&gt; c; sum[l] += c; sum[r + 1] -= c; &#125; for (int i = 1; i &lt;= n; ++i)&#123; a[i] = sum[i] + a[i - 1]; // if (i == 1) // cout &lt;&lt; (sum[i] + a[i - 1]); // else cout &lt;&lt; &quot; &quot; &lt;&lt; (sum[i] + a[i - 1]); //这样是错误的， 前面 a[i - 1] 会影响到后续的计算 if (i == 1) cout &lt;&lt; a[i]; else cout &lt;&lt; &quot; &quot; &lt;&lt; a[i]; &#125; cout &lt;&lt; endl; return 0;&#125; 单点更新区间查询12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;const int maxn = 2e4;int n;int a[maxn], C[maxn];inline int lowbit(int x)&#123;//lowbit（）函数用来取一个二进制最低位的一与后边的0组成的数 return x &amp; (-x);&#125;int sum(int x)&#123; //sum[1, i] int sum = 0; while(x &gt; 0)&#123; sum += C[x]; x -= lowbit(x);// &#125; return sum;&#125;//单点更新void updata(int x, int val)&#123;//更新（由小到大）是查询的逆过程 while(x &lt;= n)&#123;//可能会是maxn C[x] += val; x += lowbit(x);// &#125;&#125;int main()&#123; return 0;&#125; 区间更新单点查询123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;const int maxn = 1e5;int n;int a[maxn], C[maxn];//这样就把，原来要更新一个区间的值变成了只需要更新两个点//通过两个端点的更新inline int lowbit(int x)&#123; return x &amp; (-x);&#125;int sum(int i)&#123; //sum[1, i] int sum = 0; while(i &gt; 0)&#123; sum += C[i]; i -= lowbit(i);// &#125; return sum;&#125;//单点更新void updata(int i, int val)&#123;//更新（由小到大）是查询的逆过程 while(i &lt;= n)&#123; C[i] += val; i += lowbit(i);// &#125;&#125;int main()&#123; int x, y, k; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; a[i]; updata(i, a[i] - a[i - 1]); &#125; //[x, y] 加 k updata(x, k);//a[x] - a[x - 1] 加 k updata(y + 1, -k); //a[y + 1] - a[y] 减 k int i; //查询i位置的值 int sum_ = sum(i); return 0;&#125; 区间更新区间查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;const int maxn = 1e5;int n;int a[maxn], C[maxn];inline int lowbit(int x)&#123; return x &amp; (-x);&#125;int sum1[maxn], sum2[maxn];int sum(int i)&#123; //sum[1, i] int sum = 0, x = i; while(i &gt; 0)&#123; sum += x *sum1[i] - sum2[i]; i -= lowbit(i);// &#125; return sum;&#125;//单点更新void updata(int i, int val)&#123;//更新（由小到大）是查询的逆过程 int x = i; while(i &lt;= n)&#123; sum1[i] += val; sum2[i] += val; i += lowbit(i);// &#125;&#125;int main()&#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; a[i]; updata(i, a[i] - a[i - 1]); &#125; int x, y, k; //[x, y] 加 k updata(x, k);//a[x] - a[x - 1] 加 k updata(y + 1, -k); //a[y + 1] - a[y] 减 k int i; //[x, y]区间和 int sum_ = sum(y) - sum(x - 1); return 0;&#125;"},{"title":"背包板子","path":"/undefined/bag/","content":"01背包12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;deque&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;queue&gt;using namespace std;// N 件物品和一个容量是 V 的背包。每件物品只能使用一次#define re(a) memset((a), 0, sizeof((a)))#define rem(a) memset((a), 0x3f, sizeof((a)))#define ll long longint n, m;const int maxn = 1e6 + 5;ll a[maxn], b[maxn], pre[maxn], aft[maxn];ll dp[1005];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; a[i] &gt;&gt; b[i]; &#125; dp[0] = 0; for(int i = 1; i &lt;= n; ++i) for (int j = m; j &gt;= 0; --j)&#123;//倒着 //dp[j] = dp[j]; if(j - a[i] &gt;= 0) dp[j] = max(dp[j], dp[j - a[i]] + b[i]); &#125; cout &lt;&lt; dp[m]; return 0;&#125; 完全背包1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;deque&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;queue&gt;using namespace std;//N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。#define re(a) memset((a), 0, sizeof((a)))#define rem(a) memset((a), 0x3f, sizeof((a)))#define ll long longint n, m;const int maxn = 1e6 + 5;ll a[maxn], b[maxn], pre[maxn], aft[maxn];ll dp[1005][1005];int main()&#123; cin &gt;&gt; n &gt;&gt; m; //n件物品，m的体积 for (int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; a[i] &gt;&gt; b[i]; &#125; dp[0][0] = 0; for(int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt;= m; ++j)&#123;//顺着 dp[i][j] = dp[i - 1][j]; if(j - a[i] &gt;= 0) dp[i][j] = max(dp[i - 1][j], dp[i][j - a[i]] + b[i]); &#125; cout &lt;&lt; dp[n][m]; return 0;&#125; 多重背包1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;#include&lt;vector&gt;//N 种物品和一个容量是 V 的背包。//第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。using namespace std;int dp[105];int main()&#123; int v, w, s; int N, V; cin &gt;&gt; N &gt;&gt; V; //------------------------------朴素 for(int i = 0; i &lt; N; ++i)&#123; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; for(int j = V; j &gt;= 0; --j)&#123; for(int k = 0; k &lt;= s &amp;&amp; k * v &lt;= j; ++k)&#123; dp[j] = max(dp[j], dp[j - k * v] + k * w); &#125; &#125; &#125; cout &lt;&lt; dp[V]; //--------------------------2000内优化 vector&lt;pair&lt;int, int&gt;&gt; vv; int f[2005]; for (int i = 0; i &lt; N; ++i)&#123; int v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; for (int k = 1; s &gt;= k; k *= 2)&#123; s -= k; vv.push_back(&#123;v * k, w * k&#125;); &#125; if(s &gt; 0) vv.push_back(&#123;v * s, w * s&#125;); &#125; for(auto w: vv)&#123; for (int i = V; i &gt;= w.first; --i)&#123; f[i] = max(f[i], f[i - w.first] + w.second); &#125; &#125; cout &lt;&lt; f[V] &lt;&lt; endl; //-----------------------------20000数组模拟单调队列优化 int q[20002], g[20002], dp[20002]; int N, V; cin &gt;&gt; N &gt;&gt; V; for (int i = 0; i &lt; N; ++i)&#123; int v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; memcpy(g, dp, sizeof dp); for (int j = 0; j &lt; v; ++j)&#123;//枚举余数即等价类 int head = 0, tail = -1; for (int k = j; k &lt;= V; k += v)&#123;//枚举同一等价类的背包体积 if(head &lt;= tail &amp;&amp; k - s * v &gt; q[head])//当前编号-队列最大容积（间隔v 容积s * v）＞首元素，则需将首元素出队 ++head;//要维护一个不超过s的集合。 while(head &lt;= tail &amp;&amp; g[q[tail]] - (q[tail] - j) / v * w &lt;= g[k] - (k - j) / v * w) --tail;//分别表示队尾元素的值和当前元素的值 f[0] if(head &lt;= tail)// dp[i - 1] dp[k] = max(dp[k], g[q[head]] + (k - q[head]) / v * w); //f[v] - 1 * w f[2v] - 2 * w q[++tail] = k;//k个 去除了比当前小的元素，保证队列里的元素都比当前元素大，入队 &#125; &#125; &#125; cout &lt;&lt; dp[V] &lt;&lt; endl; return 0;&#125; 混合背包1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;struct node&#123; int v, w, flag;&#125;;vector&lt;node&gt; ve;int dp[1005];int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; ++i)&#123; int v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; if(s &lt;= 0) ve.push_back(&#123;v, w, s&#125;); else &#123; int k; for (int k = 1; k &lt;= s; k *= 2)&#123; s -= k; ve.push_back(&#123;v * k, w * k, -1&#125;);//拆成01 &#125; if(s &gt; 0) ve.push_back(&#123;v * s, w * s, -1&#125;); &#125; &#125; for(auto w: ve)&#123; if(w.flag &lt; 0)&#123; for (int j = m; j &gt;= w.v; --j)&#123; dp[j] = max(dp[j], dp[j - w.v] + w.w); &#125; &#125; else &#123; for (int j = w.v; j &lt;= m; ++j)&#123; dp[j]= max(dp[j], dp[j - w.v] + w.w); &#125; &#125; &#125; cout &lt;&lt; dp[m]; return 0;&#125;"},{"title":"线段相交判定板子","path":"/undefined/线段相交判定/","content":"线段是否相交1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;using namespace std;// template&lt;class T&gt; double chaji(T c, T d, T a)&#123;// // return (p3.x - p1.x) * (p3.y - p2.y) - (p3.x - p2.x) * (p3.y - p1.y);// return (a.first - c.first) * (d.second - c.second) - (d.first - c.first) * (a.second - c.second);// &#125;template&lt;class T&gt; bool judge2(T a, T b, T c, T d)&#123; if(max(a.first , b.first) &gt;= min(c.first, d.first) &amp;&amp; max(c.first, d.first) &gt;= min(a.first, b.first) &amp;&amp; max(a.second, b.second) &gt;= min(c.second, d.second) &amp;&amp; max(c.second, d.second) &gt;= min(a.second, b.second)) return true; return false; &#125;template&lt;class T&gt; bool judge1(T a, T b, T c, T d)&#123;//跨立实验 if(!judge2(a, b, c, d)) return false; double d1 = (a.first - c.first) * (d.second - c.second) - (d.first - c.first) * (a.second - c.second); double d2 = (d.first - c.first) * (b.second - c.second) - (b.first - c.first) * (d.second - c.second); double d3 = (c.first - a.first) * (b.second - a.second) - (b.first - a.first) * (c.second - a.second); double d4 = (b.first - a.first) * (d.second - a.second) - (d.first - a.first) * (b.second - a.second); if(d3 * d4 &gt;= 0 &amp;&amp; d1 * d2 &gt;= 0) return true; else return false;&#125;//一般做题是先快速排斥， 后跨立int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; pair&lt;double, double&gt; p[4]; cin &gt;&gt; p[0].first &gt;&gt; p[0].second &gt;&gt; p[1].first &gt;&gt; p[1].second &gt;&gt; p[2].first &gt;&gt; p[2].second &gt;&gt; p[3].first &gt;&gt; p[3].second; if (judge1(p[0], p[1], p[2], p[3])) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; return 0;&#125; 线段相交是否规范（只能过90%数据，先占个位） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//#include&lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;vector&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;climits&gt;#define IOS ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL);using namespace std;const int maxx = 1e4 + 5;const int maxn = 1e6 + 5;#define N 10000100#define ll long long#define endl &#x27; &#x27;const ll mod = 998244353;#define test printf(&quot;-------------------------- &quot;);#define re(a) memset((a), 0, sizeof((a)))#define remax(a) memset((a), 0x3f3f3f3f, sizeof((a)))#define PII pair&lt;int, int&gt;const double pi=acos(-1.0);inline int llog(int n)&#123; return 31 - __builtin_clz(n);&#125; //取对数// struct cmp&#123;// friend bool operator &gt; (const struct scoree &amp;a, const struct scoree &amp;b)&#123;// return a.score &gt; b.score;// &#125;// &#125;;template&lt;class T&gt; bool judge2(T a, T b, T c, T d)&#123; if(max(a.first , b.first) &gt;= min(c.first, d.first) &amp;&amp; max(c.first, d.first) &gt;= min(a.first, b.first) &amp;&amp; max(a.second, b.second) &gt;= min(c.second, d.second) &amp;&amp; max(c.second, d.second) &gt;= min(a.second, b.second)) return true; return false;&#125;template&lt;class T&gt; bool judge1(T a, T b, T c, T d)&#123; if(!judge2(a, b, c, d))&#123; return 0; &#125; double d1 = (a.first - c.first) * (d.second - c.second) - (d.first - c.first) * (a.second - c.second); double d2 = (d.first - c.first) * (b.second - c.second) - (b.first - c.first) * (d.second - c.second); double d3 = (c.first - a.first) * (b.second - a.second) - (b.first - a.first) * (c.second - a.second); double d4 = (b.first - a.first) * (d.second - a.second) - (d.first - a.first) * (b.second - a.second); if(d3 * d4 &gt;= 0 &amp;&amp; d1 * d2 &gt;= 0)&#123; return true; &#125; else return false;&#125;bool judge3(PII a, PII b, PII c, PII d) &#123; if((b.first - a.first) * (c.first - d.first) + (b.second - a.second) * (d.second - c.second) == 0) &#123; return true; &#125; return false;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; pair&lt;double, double&gt; p[4]; cin &gt;&gt; p[0].first &gt;&gt; p[0].second &gt;&gt; p[1].first &gt;&gt; p[1].second &gt;&gt; p[2].first &gt;&gt; p[2].second &gt;&gt; p[3].first &gt;&gt; p[3].second; if(judge1(p[0], p[1], p[2], p[3]))&#123; if(judge3(p[0], p[1], p[2], p[3])) cout &lt;&lt; 1 &lt;&lt; endl; else cout &lt;&lt; 2 &lt;&lt; endl; &#125; else cout &lt;&lt; 0 &lt;&lt; endl; &#125; return 0;&#125;"},{"title":"最短路","path":"/undefined/dij/","content":"##先总结吧 学习链接Floyd 任意两个结点之间的最短路 我觉得像dp 12345678//自己到自己标为0或1， 没有通路为∞ for (int k = 1; k &lt;= n; ++k)&#123;//是否经过k的最短路 for(int i = 1; i &lt;= n; ++i)&#123; for (int j = 1; j &lt;=n; ++j)&#123; map[i][j] = min(map[i][j], map[i][k] + map[k][j]); &#125; &#125; &#125; 只允许经过规定结点 123456789101112131415161718192021//只允许经过3 for(int i = 1; i &lt;= n; ++i)&#123; for(int j = 1; j &lt;= n; ++j)&#123; if(map[i][j] &gt; map[i][3] + map[3][j]) map[i][j] = map[i][3] + map[3][j]; &#125; &#125; //只允许经过3、4 for(int i = 1; i &lt;= n; ++i)&#123; for(int j = 1; j &lt;= n; ++j)&#123; if(map[i][j] &gt; map[i][3] + map[3][j]) map[i][j] = map[i][3] + map[3][j]; &#125; &#125; for(int i = 1; i &lt;= n; ++i)&#123; for(int j = 1; j &lt;= n; ++j)&#123; if(map[i][j] &gt; map[i][4] + map[4][j]) map[i][j] = map[i][4] + map[4][j]; &#125; &#125; 点到点连通 12345678910111213141516171819//1 for(int i = 1; i &lt;= n; ++i)&#123; bool flag = true; for(int j = 1; j &lt;= n; ++j)&#123; if(!g[j][i])&#123; flag = false; break; &#125;\t&#125;\tif(flag) &#123; cout &lt;&lt; i &lt;&lt; endl; return 0;\t&#125;&#125;//2 边权变为0/1std::bitset&lt;SIZE&gt; f[SIZE];for (k = 1; k &lt;= n; k++) for (i = 1; i &lt;= n; i++) if (f[i][k]) f[i] = f[i] | f[k]; johnson进阶版floyd bellman-ford 含负权，单源最短路, 不能出现负权回路 初始所有的点位∞，起点为0 循环n次， 遍历m松弛操作（逐步接近，移动，取min） 容易理解的版本 123456789101112131415161718192021222324252627bool bf()&#123; int n, m; int map[105][105]; int s = 1; int d[105]; memset(d, INF, sizeof(d)); int flag = 0; for (int i = 0; i &lt;= n; ++i)&#123; for (int j = 1; j &lt;= n; ++j)&#123; for (int k = 1; k &lt;= n; ++k)&#123; if(d[k] &gt; d[j] + map[j][k])&#123; d[k] = d[j] + map[j][k]; flag = 1; &#125; &#125; &#125; if(!flag) return true; &#125; for (int i = 1; i &lt;= n; ++i)&#123; for (int j = 1; j &lt;= m; ++j)&#123; if(d[j] &gt; d[i] + map[i][j])&#123; return false;//判断是否有负环 &#125; &#125; &#125;&#125; 这个代码更好 12345678910111213141516171819202122232425262728293031323334//oi wiki// C++ Versionstruct edge &#123; int v, w;&#125;;vector&lt;edge&gt; e[maxn];int dis[maxn];const int inf = 0x3f3f3f3f;bool bellmanford(int n, int s) &#123; memset(dis, 63, sizeof(dis)); dis[s] = 0; bool flag; // 判断一轮循环过程中是否发生松弛操作 for (int i = 1; i &lt;= n; i++) &#123; flag = false; for (int u = 1; u &lt;= n; u++) &#123; if (dis[u] == inf) continue; // 无穷大与常数加减仍然为无穷大 // 因此最短路长度为 inf 的点引出的边不可能发生松弛操作 for (auto ed : e[u]) &#123; int v = ed.v, w = ed.w; if (dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; flag = true; &#125; &#125; &#125; // 没有可以松弛的边时就停止算法 if (!flag) break; &#125; // 第 n 轮循环仍然可以松弛时说明 s 点可以抵达一个负环 return flag;&#125; spfa:反正被卡是基操就不写了，最坏时间复杂度和bf一样Dijkstra相当于bfs 123456789101112131415161718192021void dij(int s)&#123; memset(dis, 0x3f, sizeof(dis)); memset(vis, false, sizeof(vis)); priority_queue &lt; pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; q;//也可以用struct代替 dis[s] = 0; q.push(&#123;dis[s], s&#125;); while(!q.empty())&#123; int now = q.top().second; q.pop(); if(vis[now]) continue; vis[now] = true; for (int i = head[now]; ~i; i = edge[i].next)&#123; int v = edge[i].to; if(!vis[v] &amp;&amp; edge[i].w + dis[now] &lt; dis[v])&#123; dis[v] = edge[i].w + dis[now]; q.push(&#123;dis[v], v&#125;); &#125; &#125; &#125;&#125; ##题荐 青蛙思路：单源最短路，两两之间取max floyd 123456789101112131415161718192021222324252627282930313233343536//5552mspair&lt;int, int&gt; p[210];double dist[210][210];int t;int pre[210];int main() &#123;\tIOS;\tint cnt = 1;\twhile (cin &gt;&gt; t &amp;&amp; t) &#123; re(p); re(dist); re(pre); for (int i = 1; i &lt;= t; ++i) cin &gt;&gt; p[i].first &gt;&gt; p[i].second; //求距离 for (int i = 1; i &lt;= t - 1; ++i) &#123;//这里注意范围，否则要错 for (int j = i + 1; j &lt;= t; ++j) &#123; dist[i][j] = dist[j][i] = sqrt((p[i].first - p[j].first) * (p[i].first - p[j].first) + (p[i].second - p[j].second) * (p[i].second - p[j].second)); &#125; &#125; //floyd for (int k = 1; k &lt;= t; ++k) &#123; for (int i = 1; i &lt;= t - 1; ++i) &#123;//范围 for (int j = i + 1; j &lt;= t; ++j) &#123; if (dist[i][k] &lt; dist[i][j] &amp;&amp; dist[k][j] &lt; dist[i][j]) dist[i][j] = dist[j][i] = max(dist[i][k], dist[k][j]); &#125; &#125; &#125; printf(&quot;Scenario #%d &quot;, cnt++); printf(&quot;Frog Distance = %.3f &quot;, dist[1][2]);\t&#125;\treturn 0;&#125; dij太久没用优先队列都不会了orz优先队列用法最大的收获是：在while里面定义，记得初始化，最好用全int，最后再改值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//1947mspair&lt;int, int&gt; p[210];int t;int dis[210];bool vis[210];struct node&#123; int j, dist;&#125;;int main() &#123;\tIOS;\tint cnt = 1;\twhile (cin &gt;&gt; t &amp;&amp; t) &#123; re(p); remax(dis); re(vis); vector&lt;node&gt; a[210]; for (int i = 1; i &lt;= t; ++i) cin &gt;&gt; p[i].first &gt;&gt; p[i].second; for(int i = 1; i &lt;= t; ++i)&#123; for (int j = i + 1; j &lt;= t; ++j)&#123; if(i != j)&#123; int w = (p[i].first - p[j].first) * (p[i].first - p[j].first) + (p[i].second - p[j].second) * (p[i].second - p[j].second); a[i].push_back(&#123;j, w&#125;); a[j].push_back(&#123;i, w&#125;); &#125; &#125; &#125; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; q; q.push(&#123;0, 1&#125;); dis[1] = 0; while(!q.empty())&#123; int now = q.top().second; q.pop(); if(vis[now]) continue; vis[now] = true; for(auto w : a[now])&#123; int j = w.j; if(dis[j] &gt; max(dis[now], w.dist))&#123; dis[j] = max(dis[now], w.dist); q.push(&#123;dis[j], j&#125;); &#125; &#125; &#125; printf(&quot;Scenario #%d &quot;, cnt++); printf(&quot;Frog Distance = %.3f &quot;, sqrt(dis[2]));\t&#125;\treturn 0;&#125; 货物运输和上一道思路一模一样，怎么说呢，做了和没做好像没有什么区别，还给我整焦虑了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct node&#123; int v, w;&#125;;bool vis[1005];int dist[1005];void dij(vector&lt;node&gt; v[])&#123; re(vis); re(dist); priority_queue&lt;pair&lt;int, int&gt;&gt; q; q.push(&#123;2e9,1&#125;); dist[1] = 2e9;//相当于要求的是最大的最长的路径，和上一题唯一不同点 while(!q.empty())&#123; pair&lt;int, int&gt; temp = q.top(); q.pop(); if(vis[temp.second]) continue; vis[temp.second] = true; for(auto w : v[temp.second])&#123; int v = w.v; if(dist[v] &lt; min(dist[temp.second], w.w))&#123; dist[v] = min(dist[temp.second], w.w); q.push(&#123;dist[v], v&#125;); &#125; &#125; &#125;&#125;int main() &#123;\tIOS;\t// freopen(&quot;P1908_6.in&quot;,&quot;r&quot;,stdin);//读入数据\t// freopen(&quot;P1908.out&quot;,&quot;w&quot;,stdout); //输出数据 int t; cin &gt;&gt; t; for(int c = 1; c &lt;= t; ++c)&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; //来建图 vector&lt;node&gt; v[1005]; for (int i = 1; i &lt;= m; ++i)&#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; v[a].push_back(&#123;b, c&#125;); v[b].push_back(&#123;a, c&#125;); &#125; dij(v); printf(&quot;Scenario #%d: &quot;,c); printf(&quot;%d &quot;, dist[n]); &#125; return 0;&#125; 最小值中的最大值初始化: ans &#x3D; 0;最大值中的最小值出初始化： ans &#x3D; 0x3f3f3f;然后ans逐渐缩小范围，得到最优解"},{"title":"树的中/后序遍历（简易）","path":"/undefined/tree-round/","content":"全部都是先左子树，再右子树 中序: 先往左下走，无再向左的决策，输出该点回到上一点(父节点)再次判断。后序:先往左下走，无可选择的决策，输出该点回到上一点判断 决策: 决定这一步向左子树走还是向右子树走。 递归也是这样的道理"},{"title":"蓝桥杯","path":"/undefined/蓝桥杯/","content":"枚举模拟、数论、图论、动规、贪心 dijkstra、floyd、gcd、素数筛、质因数分解 dp简单的就那几个，挨个挨个方法试（-1啊、|、max、*） 这个看不清就换个方式看或者打表 excel会自动忽略第一天 遇到不知道的：暴力枚举骗分 不明所以的数可能是比例 找出必定成立的地方 二分是最优策略 dp相同的限制可以矩阵快速幂 感觉少了就加一维 裴蜀定理解方程 组合数可以用二位前缀和 组合 -&gt; 递归 &#x2F; dp（主要看数据范围） 矩阵快速幂 123456789101112void mul(int a[][2], int b[][2], int c[][2])&#123; int temp[][2] = &#123;&#123;0, 0&#125;, &#123;0, 0&#125;&#125;; for (int i = 0; i &lt; 2; i ++ ) for (int j = 0; j &lt; 2; j ++ ) for (int k = 0; k &lt; 2; k ++ ) &#123; long long x = temp[i][j] + (long long)a[i][k] * b[k][j]; temp[i][j] = x % MOD; &#125; memcpy(a, temp, sizeof temp);&#125; 快速幂 123456789ll fast_power(ll a, ll b, ll p)&#123; ll pr = 1; while(b &gt; 0)&#123; if(b &amp; 1) pr = pr * a % p; a = a * a % p; b &gt;&gt;= 1; &#125;&#125; 拓展欧几里得 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;int exgcd(int a, int b, int &amp;x, int &amp;y)&#123; if(!b)&#123;//因为那个式子是以y的 x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x;//----!!! return d;&#125;int main()&#123; int a, b, x, y; cin &gt;&gt; a &gt;&gt; b; int d = exgcd(a, b, x, y); printf(&quot;%d * %d + %d * %d = %d&quot;, a, x, b, y, d); //同时扩大 if((b - a) % d)&#123; cout &lt;&lt; &quot;FOREVER&quot; &lt;&lt; endl; &#125; else &#123; x *= (b - a) / d; mod /= d; cout &lt;&lt; (x % mod + mod) % mod &lt;&lt; endl;\t&#125; return 0;&#125; 素数筛（注意范围） 1234567891011121314151617int cnt = 0;int prime[maxn];bool p[maxn];void ola()&#123; for (int i = 2; i &lt; 1048575; ++i)&#123; if(!p[i]) prime[++cnt] = i; for (int j = 1; j &lt;= cnt &amp;&amp; prime[j] &lt; 1048575 / i; ++j)&#123; p[i * prime[j]] = true; if(i % prime[j] == 0) break; &#125; &#125;&#125;//找因子的可以先把因子（含合数）全弄出来（% == 0），再看 龟速乘 123456789101112131415using namespace std;typedef long long ll;int n;ll fast_mult(ll a, ll b) &#123; ll res = 0; while (b &gt; 0) &#123; if (b &amp; 1) &#123; res = (res + a) % n; &#125; b &gt;&gt;= 1; a = (a + a) % n; &#125; return res % n;&#125; dijkstra（负权不行） 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int dis[105], vis[105], head[105];void dij(int s)&#123; memset(dis, 0x3f, sizeof(dis)); memset(vis, false, sizeof(vis)); priority_queue &lt; pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; q; dis[s] = 0; q.push(&#123;dis[s], s&#125;); while(!q.empty())&#123; int now = q.top().second; q.pop(); if(vis[now]) continue; vis[now] = true; for (int i = head[now]; ~i; i = edge[i].next)&#123; int v = edge[i].to; if(!vis[v] &amp;&amp; edge[i].w + dis[now] &lt; dis[v])&#123; dis[v] = edge[i].w + dis[now]; q.push(&#123;dis[v], v&#125;); &#125; &#125; &#125;&#125;int main()&#123; //一个节点到其他所有节点的最短路， 类似bfs， 不带负权 return 0;&#125; floyd 12345678for (int k = 1; k &lt;= n; ++k)&#123; for(int i = 1; i &lt;= n; ++i)&#123; for (int j = 1; j &lt;=n; ++j)&#123; if(map[i][j] &gt; map[i][k] + map[k][j]) map[i][j] = map[i][k] + map[k][j]; &#125; &#125; &#125; 并查集 1234567891011121314151617181920212223242526void init(int n)&#123; for(int i = 1; i &lt;= n; ++i)&#123; pre[i] = i;//初始化自己 &#125;&#125;int find(int x)&#123;//不是直接用的 if(pre[x] == x) return x; return pre[x] = find(pre[x]);&#125;void merge(int x, int y)&#123; x = find(x); y = find(y); if(x == y) return; if(rankk[x] &gt; rankk[y])//高度 pre[y] = x; else &#123; if(rankk[x] == rankk[y]) rankk[y]++; pre[x] = y; &#125;&#125; 背包考前看视频吧，其余dp看一下 12345678//01 dp[0] = 0; for(int i = 1; i &lt;= n; ++i) for (int j = m; j &gt;= 0; --j)&#123;//倒着 //dp[j] = dp[j]; if(j - a[i] &gt;= 0) dp[j] = max(dp[j], dp[j - a[i]] + b[i]); &#125; cout &lt;&lt; dp[m]; 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;deque&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;queue&gt;using namespace std;//N 种物品和一个容量是 V 的背包，每种物品都有无限件可用 完全背包#define re(a) memset((a), 0, sizeof((a)))#define rem(a) memset((a), 0x3f, sizeof((a)))#define ll long longint n, m;const int maxn = 1e6 + 5;ll a[maxn], b[maxn], pre[maxn], aft[maxn];ll dp[1005][1005];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; a[i] &gt;&gt; b[i]; &#125; dp[0][0] = 0; for(int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt;= m; ++j)&#123;//顺着 dp[i][j] = dp[i - 1][j]; if(j - a[i] &gt;= 0) dp[i][j] = max(dp[i - 1][j], dp[i][j - a[i]] + b[i]); &#125; cout &lt;&lt; dp[n][m]; return 0;&#125; 树状数组 12345678910111213141516171819202122232425262728293031323334inline int lowbit(int x)&#123; return x &amp; (-x);&#125;int sum(int i)&#123; //sum[1, i] int sum = 0; while(i &gt; 0)&#123; sum += C[i]; i -= lowbit(i);// &#125; return sum;&#125;//单点更新void updata(int i, int val)&#123;//更新（由小到大）是查询的逆过程 while(i &lt;= n)&#123; C[i] += val; i += lowbit(i);// &#125;&#125;int main()&#123; int x, y, k; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; a[i]; updata(i, a[i] - a[i - 1]); &#125; //[x, y] 加 k updata(x, k);//a[x] - a[x - 1] 加 k updata(y + 1, -k); //a[y + 1] - a[y] 减 k int i; //查询i位置的值 int sum_ = sum(i);"},{"title":"小函数","path":"/undefined/小函数/","content":"大小写转化： 12transform(src.begin(), src.end(), src.begin(), ::toupper);transform(src.begin(), src.end(), dst.begin(), ::tolower); 全排列： 1234do &#123; cout &lt;&lt; s &lt;&lt; endl;\t&#125; while (next_permutation(s.begin(), s.end()));//升序prev_permutation(s,s+3) 读入空格： 12345cin &gt;&gt; noskipws; //设置cin读取空白符；char ch;//cout &lt;&lt; s &lt;&lt; &quot; &quot;;//真无语还有空格while (cin &gt;&gt; ch) if(ch == &#x27; &#x27;) ++cnt; cin &gt;&gt; skipws;//恢复 字符互转： 1atoi(tem.c_str());"},{"title":"寒假新学总结","path":"/undefined/寒假新学总结/","content":"123456789map&lt;int, multiset&lt;int&gt;, greater&lt;int&gt;&gt; mp;for (auto w : mp) &#123; cout &lt;&lt; w.first; for (auto v : w.second) &#123; cout &lt;&lt; v; cout &lt;&lt; w.first; &#125;\t&#125; 12345678910#include&lt;algorithm&gt;对给定范围进行&quot;排序&quot; nth_element(l, set, r, compare)a中第k小的值，第二个参数就应该填a+k-1当元素较多时平均时间复杂度为O(N)，元素较少时最坏情况下时间复杂度为O(N^2)。 求[first, last]这个区间中第n大小的元素，如果参数加入了compare函数，就按compare函数的方式比较。 sort函数底层使用的是快速排序算法 O(nlog2n) 其它：https://www.jianshu.com/p/a68390d78386 因此此题直接将字符画贴源码里直接交(PHP)能过。 $$a_i| a_j &gt;&#x3D; lcm(a_i, a_j)$$ 12对于 x,y (x≤y)，若x∣y，那么 lcm(x, y) = y是一组解。否则lcm(x, y) ≥ 2y &gt; x or y，不可能是解。于是就变成找序列中是不是存在一个数是另一个数的因数 LL其实代表long long，*1LL是为了在计算时，把int类型的变量转化为long long，然后再赋值给long long类型的变量不至于后面计算溢出 （1ll &#x3D; 1, 2ll &#x3D; 2） 看第 i 位是不是1，可以右移 i 位再 &amp;1 看 u &gt;&gt; i &amp; 1 （要从0开始枚举） 看取不取： state的u位置成1，说明选这个数，某种程度上可以代替数组 state | (1 &lt;&lt; u) 奇偶本质是01 边权是0或者是1就可以转化成双端队列 scanf(“%*d“, &amp;v[i]); 那个是跳过不读的意思 10进制转n进制： 取余倒排 二分： 123int mid = (l + r) / 2; l = mid + 1, r = mid;int mid = (l + r + 1) / 2; l = mid, r = mid - 1; memeset( , 0x3f, ); 相当于每个都是0x3f3f3f3f (4个) 1state |= x &lt;&lt; i //不重，记数字 把x加到state的i位 &lt;=&gt; 第i位是x 1auto &amp;[k, v] : mp 将 xx 的二进制写两次等价于将 xx 后面添加一些’0’ 离正方体最远最近的点是中心和脚 二分就是 最优化问题转化为判定性问题： ​\t判断一下满足或是不满足能不能再细分 问最小值的我们一般都会想到二分 一个二叉树的小常识： 二叉树节点 向下投影，映射成的数组序列就是 中序遍历序列 区间合并"},{"title":"离散化","path":"/undefined/离散化/","content":"不是算法，只是一个降低复杂度的Trick 把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率 你有一个10^3个数据，数据大小在10^12之内，如果直接开一个10^12的数组就肯定会超，而开一个10^3的long long数组就不会超。 map可以实现离散化 所以，我们只需要先把数据存在一个结构体数组里面，对数据排序后再将结构体数组中的数据位置转存到另一个数组上就完全可以避免MLE 题目只需要各元素之间的大小关系而与元素具体大小无关（相对关系） 排序之后，枚举着放回原数组 用一个结构体存下原数和位置，按照原数排序 结构体里面写个重载，也可以写一个比较函数 最后离散化后数在b[]里面 12345678910111213141516171819202122232425262728293031323334复杂度更优，但不能处理重复元素int b[500010];离散后的数据struct in&#123; int shu;实际元素大小 int weizhi;元素所在的位置&#125;dian[500010];bool cmp(in a , in b)&#123; if(a.shu == b.shu) return a.weizhi &lt; b.weizhi; return a.shu &lt; b.shu;&#125;for(int i = 1 ; i &lt;= n ; i ++) &#123; cin &gt;&gt; dian[i].shu; dian[i].weizhi = i;\t&#125;\tsort(dian + 1 , dian + 1 + n , cmp);\tfor(int i = 1 ; i &lt;= n ; i ++)&#123; b[dian[i].weizhi] = i;\t&#125;\tv: 3 6 5 10 8 id:1 2 3 4 5 排序以后： v: 3 5 6 8 10 id:1 3 2 5 4 所以离散化以后： v: 3 5 6 8 10 id:1 3 2 5 4 rk:1 2 3 4 5 在按原来的顺序排列： v: 3 6 5 10 8 rk:1 3 2 5 4 用一个辅助的数组把你要离散的所有数据存下来。 然后排序，排序是为了后面的二分。 去重，因为我们要保证相同的元素离散化后数字相同。 再用二分把离散化后的数字放回原数组。 1234567891011121314151617#include&lt;algorithm&gt; // 头文件 //n 原数组大小 num 原数组中的元素 lsh 离散化的数组 cnt 离散化后的数组大小 int lsh[MAXN] , cnt , num[MAXN] , n;for(int i=1; i&lt;=n; i++) &#123;\tscanf(&quot;%d&quot;,&amp;num[i]);\tlsh[i] = num[i];\t&#125;sort(lsh+1 , lsh+n+1);cnt = unique(lsh+1 , lsh+n+1) - lsh - 1; //unique是c++自带的一个函数，表示对一个数列去重,然后返回不重复的元素个数，当然在后面要减去首地 址//原序列：6 9 4 6 4//排序后：4 4 6 6 9//unique（元素去掉重复的）后：4 6 9 6 9for(int i=1; i&lt;=n; i++)\tnum[i] = lower_bound(lsh+1 , lsh+cnt+1 , num[i]) - lsh;//离散化之后的排名（即新编号）&#123;6,8,4,9,5,6,7,4&#125;，首先排序后得到&#123;4,4,5,6,6,7,8,9&#125;，去重&#123;4,5,6,7,8,9&#125;，然后原序列就变成了&#123;3,5,1,6,2,3,4,1&#125;。 注意事项： 1.去重并不是把数组中的元素删去，而是重复的部分元素在数组末尾，去重之后数组的大小要减一 2.二分的时候，注意二分的区间范围，一定是离散化后的区间 3.如果需要多个数组同时离散化，那就把这些数组中的数都用数组存下来 123456789101112//mp[i]=j;i表示这个数字,j表示这个数所在的位置map&lt;int,int&gt; mp;int n,c[maxn],st[maxn];for (int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;c[i]); st[i]=c[i];&#125;sort(st+1,st+n+1);for (int i=1;i&lt;=n;i++) mp[st[i]]=i;所以对于一个无序数组c,我们找c中任意一个数都可以快速知道它是第几大的数,且mp.size()的值就是数组c的不重复的元素个数 题： [USACO1.2]挤牛奶Milking Cows 人为离散化： 12v.erase(unique(v.begin(), v.end()), v.end());//去重(v.erase(pos, v.end()))"},{"title":"区间问题","path":"/undefined/区间问题/","content":"校门外的树🔗 12345int ans = 0;ans += r - L + 1;//(循环结束后必须再来一个这个)int res = n + 1;res -= r - l + 1; 12345678910111213sort(p, p + m, cmp);int ans = 0;int L = p[0].first, r = p[0].second;for (int i = 1; i &lt; m; ++i) &#123;\tif (p[i].first &gt; r) &#123; ans += r - L + 1; L = p[i].first; r = p[i].second;\t&#125; else &#123; r = max(p[i].second, r);\t&#125;&#125;ans += r - L + 1; cout &lt;&lt; l + 1 - ans&lt;&lt; endl; 区间合并🔗 1234567891011几个区间\tfor (int i = 1; i &lt; m; ++i) &#123; if (p[i].first &gt; r) &#123; ++ans; L = p[i].first; r = p[i].second; &#125; else &#123; r = max(p[i].second, r); &#125;\t&#125;\tcout &lt;&lt; ans + 1 &lt;&lt; endl;//(毕竟最后一个无论如何都要算) 二维的地毯🔗 画图🔗 差分： O(1) 123456789 //++a, ++b;视具体情况而定 ++g[a][b]; --g[c + 1][b]; --g[a][d + 1]; ++g[c + 1][d + 1];for (int i = 1; i &lt;= 100 + 1; ++i) &#123; for (int j = 1; j &lt;= 100 + 1; ++j) &#123; g[i][j] += g[i - 1][j] + g[i][j - 1] - g[i - 1][j - 1]; 前缀和： O(mn + n^2) 1234567891011121314for (int i = 0; i &lt; n; ++i) &#123;\tint a, b, c, d;\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;\tfor (int j = a; j &lt;= c - 1; ++j) &#123;//c-1 / c g[j][b]++; g[j][d]--;//d / d + 1\t&#125;&#125;for (int i = 0; i &lt;= 100 + 1; ++i) &#123;\tfor (int j = 0; j &lt;= 100 + 1; ++j) &#123; ans += g[i][j]; an[i][j] = ans;\t&#125;&#125; 再复杂 ： 1e5 扫描线+线段树（在差分不可用情况下）"},{"title":"字符串","path":"/undefined/字符串/","content":"🔗 类似于字符串匹配 最小的 K 的值，使得他查看任意连续 K 个邮箱序列，可以唯一确定这一序列在道路上的位置。 例如，假设沿路的邮箱序列为 ABCDABC 。 &#x3D;&#x3D;&gt; 4 ABCD 麻烦的是 rrabcrra这种 set即可解决，暴力，关键set.size() &#x3D;&#x3D; num 从1开始暴力循环，因为是长度"},{"title":"易错点","path":"/undefined/易错点/","content":"出现死循环还可能是if else差情况判断 不开long long死得不明不白 string s比大小必须是两步 12if (s.size() &gt; temp.size()) temp = s, max = cnt;else if(s.size() == temp.size() &amp;&amp; s &gt; temp) temp = s, max = cnt;"},{"title":"线段树做题总结","path":"/undefined/线段树做题总结/","content":"线段树的本质 ： 查询 + 修改 [TJOI2018]数学计算 抽象问题 不是所有函数都必须用上 不一定要在所有输入完之后才建树 修改一般是在 add[q] &#x2F; tree[q];"},{"title":"树状数组 、线段树总结","path":"/undefined/树状数组易错点总结/","content":"数星星 步骤： lowbit(int x) 12return x &amp; (-x);关键在于需要跳着去找上一步的东西 updata(int i, int val) 123456while(i &lt;= n)&#123; //这里可能是 i &lt; maxn，acwing数星星，坐标，从0开始的（记得x++） C[i] += val; i += lowbit(i);&#125;直接传 1234567891011int x = i;while(i &lt;= n)&#123; sum1[i] += val; sum2[i] += val; i += lowbit(i);&#125;cin &gt;&gt; a[i];updata(i, a[i] - a[i - 1]);updata(x, k);//a[x] - a[x - 1] 加 kupdata(y + 1, -k); //a[y + 1] - a[y] 减 k sum(int i) ​ sum(y) - sum(x - 1); 表示目标值小于等于i的前缀和 12345int sum = 0;while(i &gt; 0)&#123; sum += C[i]; i -= lowbit(i);&#125; 12345int sum = 0, x = i;while(i &gt; 0)&#123; sum += x * sum1[i] - sum2[i]; i -= lowbit(i); &#125; ———————————————————————————————————————————— 每个区间[L,R]都分解为少量特定的子区间，通过这些少量子区间的修改或统计来实现操作 全部都是从1开始！！！ 它要1e5，数组全开4 * 1e5； 如果感觉时间会被卡可以将*2的操作改为&lt;&lt;1 ， +1改为|1 记得开long long 一般1e5, 1e6是极限，scanf才能过 build(int node, int start, int end) ​ 根据数组在那个点递归构造树，同时把add[]初始为0 12345678910111213if(start == end)&#123; tree[node] = a[start];//注意下标 add[node] = 0;// return; &#125; int mid = (start + end) / 2; int left = 2 * node + 1; int right = 2 * node + 2; build(left, start, mid); build(right, mid + 1, end); tree[node] = tree[left] + tree[right];//更新 pushup add[node] = 0;// updata1(int i, int l, int r,int set, int num) ​ 单点修改，不用add[] 12345678910if(l == set &amp;&amp; r == set) &#123; tree[i] += num; return; &#125; int mid = (l + r) / 2; if(mid &gt;= set) updata1(i * 2 + 1, l, mid, set, num); else updata1(i * 2 + 2, mid + 1, r, set, num); tree[i] = tree[i * 2 + 1] + tree[i * 2 + 2]; pushdown(int k, int l, int r) 将要改变的结点向下传递 123456789int mid = (l + r) / 2; add[2 * k + 1] += add[k];//他可能不只继承一个标记tree[2 * k + 1] += (mid - l + 1) * add[k]; //加上下面那群增加的数，毕竟它代表的是区间和 add[2 * k + 2] += add[k]; tree[2 * k + 2] += (r - mid) * add[k]; add[k] = 0;//使命完成，消去标记 updata2(int q,int l,int r,int tl,int tr,int num) 对区间进行操作 12345678910111213if(l&gt;=tl&amp;&amp;r&lt;=tr)&#123; tree[q] += num * (r - l + 1); add[q] += num; return;\t&#125;if(add[q]) //除了这一步和上面那一步，其余都相同 毕竟只是引入了add这个概念 pushdown(q, l, r); int mid = (l + r) / 2; if(tl&lt;=mid) updata2(q * 2 + 1, l, mid, tl, tr, num); if(tr&gt;mid) updata2(q * 2 + 2, mid + 1, r, tl, tr, num);tree[q] = tree[q * 2 + 1] + tree[q * 2 + 2]; query(int q, int l, int r, int tl, int tr) 递归 query [tl, tr] 1234567891011if(tl &lt;= l &amp;&amp; r &lt;= tr) return tree[q]; if(add[q]) // pushdown(q, l, r); int mid = (l + r) / 2; int sum = 0; if(tl &lt;= mid)//mid决定了它在哪边找 sum += query(q * 2 + 1, l, mid, tl, tr); if(tr &gt; mid) sum += query(q * 2 + 2, mid + 1, r, tl, tr); return sum; 线段树乘法， 与之前有较大差别1ll tree[Maxn&lt;&lt;2],mul[Maxn&lt;&lt;2],add[Maxn&lt;&lt;2],a[Maxn] build(ll p,ll l,ll r) 123456789101112ll m=(l+r)&gt;&gt;1;if(l==r)&#123;\ttree[p]=a[l];//tr[p]=leaf[r];\treturn;&#125;build(p&lt;&lt;1,l,m);build(p&lt;&lt;1|1,m+1,r);tree[p]=tree[p&lt;&lt;1]+tree[p&lt;&lt;1|1];tree[p]%=md;mul[p]=1;return; pushdown(ll p,ll l,ll r) 123456789101112ll m=(l+r)&gt;&gt;1;tree[p&lt;&lt;1]=(tree[p&lt;&lt;1]*mul[p]+add[p]*(m-l+1))%md;//向左儿子传结果tree[p&lt;&lt;1|1]=(tree[p&lt;&lt;1|1]*mul[p]+add[p]*(r-m))%md;//向右儿子传结果mul[p&lt;&lt;1]=(mul[p&lt;&lt;1]*mul[p])%md;//向左儿子传乘法tagmul[p&lt;&lt;1|1]=(mul[p&lt;&lt;1|1]*mul[p])%md;//向右儿子传乘法tagadd[p&lt;&lt;1]=(add[p&lt;&lt;1]*mul[p]+add[p])%md;//向左儿子传加法tagadd[p&lt;&lt;1|1]=(add[p&lt;&lt;1|1]*mul[p]+add[p])%md;//向右儿子传加法tagmul[p]=1;add[p]=0; updmul(ll p,ll l,ll r,ll tl,ll tr,ll k) 12345678910111213if(tr&lt;l||tl&gt;r)return;//若不在此区间就返回上一层，下同if(tl&lt;=l&amp;&amp;tr&gt;=r)&#123;\ttree[p]=(tree[p]*k)%md;\tmul[p]=(mul[p]*k)%md;\tadd[p]=(add[p]*k)%md;\treturn;&#125;pushdown(p,l,r);ll m=(l+r)&gt;&gt;1;updmul(p&lt;&lt;1,l,m,tl,tr,k);//不同之处updmul(p&lt;&lt;1|1,m+1,r,tl,tr,k);tree[p] = (tree[p &lt;&lt; 1] + tree[p &lt;&lt; 1 | 1]) % md; updadd(ll p,ll l,ll r,ll tl,ll tr,ll k) 123456789101112if(tl&gt;r||tr&lt;l)return;if(tl&lt;=l&amp;&amp;tr&gt;=r)&#123;\ttree[p]=(tree[p]+(r-l+1)*k)%md;\tadd[p]=(add[p]+k)%md;\treturn;&#125;pushdown(p,l,r);ll m=(l+r)&gt;&gt;1;updadd(p&lt;&lt;1,l,m,tl,tr,k);updadd(p&lt;&lt;1|1,m+1,r,tl,tr,k);tree[p] = (tree[p &lt;&lt; 1] + tree[p &lt;&lt; 1 | 1]) % md; query(ll p,ll l,ll r,ll tl,ll tr) 12345678if(tl&gt;r||tr&lt;l)return 0;if(tl&lt;=l&amp;&amp;tr&gt;=r)&#123;\treturn tree[p];&#125;pushdown(p,l,r);ll m=(l+r)&gt;&gt;1;return (query(p&lt;&lt;1,l,m,tl,tr)+query(p&lt;&lt;1|1,m+1,r,tl,tr))%md; 区间最大值只修改为max即可，注意如果是不超过2^31 - 1,sum就等于这个数取max **&#x2F;**INT_MIN(climits) zkw线段树"},{"title":"素数筛","path":"/undefined/素数筛/","content":"12345678910111213141516int p[maxx];int cnt = 0;bool prime[maxx]; void ola() &#123; prime[0] = prime[1] = true; for (int i = 2; i &lt; maxx; ++i) &#123; if (!prime[i]) p[++cnt] = i; for (int j = 1; j &lt;= cnt &amp;&amp; i * p[j] &lt; maxx; ++j) &#123; prime[i * p[j]] = true; if (i % p[j] == 0) break; &#125; &#125;&#125;"},{"title":"mysql总结","path":"/undefined/数据库/","content":"12345Show databases;information_schema:存储系统中数据库对象信息Mysql:存储账户信息、权限信息、时区信息Pre_formance_schema:收集数据库服务器性能参数sys：通过视图将information_schema和Pre_formance_schema结合起来，查询出更容易理解的数据 12create database jwgl;use jwgl; 修改数据库: 修改已经被创建或者存在的数据库相关参数，更改全局特性 123alter database jwgl;/ alter schemadefault character set gb312;指定字符集修改default collate gb2312_chinese_ci;默认校对规则 删除数据库 1drop database jwgl; 数据类型： tinyint 8字节 -128-127 smallint 2 -32768-32767 mediumint 3 8e6 int 4 2e9 bigint 8 9e18 小数类型： float 4 单精度浮点数 double 8 双精度浮点数 decimal (m,d), dec m + 2 压缩的“严格”定点数 时间&#x2F;日期类型： year 1 YYYY time 3 HH:MM:SS date 3 YYYY-MM-DD datetime 8 YYYY-MM-DD HH:MM:SS timestamp 4 YYYY-MM-DD HH:MM:SS 字符串类型： char m[1,255] varchar l+1 l[1,255] 固定长度 tinyetext l+1 l&lt;2^8 变长 text l+2 l&lt;2^16 非常小 mediumtext l+3 l&lt;2^24 中等大小 longtext l+4 l&lt;2^32 大的 enum 1或2，取决于枚举值的数目（最大值为65535） 枚举类型，只能有一个枚举字符串值 set 1、2、3、4、8,取决于集合成员的数量（最多64） 一个设置，字符串对象可以有0个或多个set成员 二进制类型： bit (m + 7) &#x2F; 8 binary m varbinary m+1 tinyblob l+1 l&lt;28 blob l+1 l&lt;216 mediumblob l+2 l&lt;224 longblob l+4 l&lt;232 创建数据库表： 123456create table stu(\tsno 数据类型 约束条件)engine=innodb 存储引擎是innodb创建/复制数据库表create table stu like xsjbxxb;stu结果和xsjbxxb相同(like 复制表的结构)create table stu select* from xsjbxxb;完全相同 查看表结构(desc) 1describe xsjbxxb; 查看建表语句（变量） 1show create table xsjbxxb; 修改数据库表 1234567alter table stu [add啊之类的] 改变表原有的结构alter table stu add column tel int(11);添加一个int telalter table stu modify tel varchar(8); 把int tel改为varchar telalter table stu drop tel; alter table stu change tel tell int;修改字段名称varchar tel-&gt;int tellalter table stu rename stuu; 修改表名 删除表 1drop table [if exists] stu; 表记录的插入 12345insert into stu[(行的名称)] values(具体数值);指定字段及其对应的值时，字段可以不按照表中字段的顺序排列，但字段 和值要一一对应不指定时，值的顺序必须和表中顺序完全一样insert into stu values(具体数值)，(具体数值);同时插入多条数据insert into stu(字段列表) select (xsjbxxb的字段列表) from xsjbxxb [where 2的=xxx];将其他表的数据插入表中 表记录的修改 1update stu set xb = &#x27;男&#x27; where xm = &#x27;张三&#x27;;把所有姓名为张三的学生性别改为男 表记录的删除 123delete from stu [where xm = &#x27;张三&#x27;];删除stu里的xm为张三的truncate table stu;删除stu表的全部数据 主键约束： 主键（主码）由表中的一个字段或 多个字段组成，可以唯一的标识表中的一条记录。主键的取值不能为null，且取值唯一，不能重复，以此保证实体完整性。 12345678910创建时 xm varchar(12) primary key;复合主键，在末尾完了后 primary key(xm, xh)如果约束是多列定义的，某个列值可以重复，但这多列里所有列的组合值必须唯一当主键只有一个字段时，既可以将主键定义为列级完整性约束，也能是表级完整性约束；多个字段只能表级完整性约束alter table stu modify xh varchar(12) not null primaty key;对于已存在的表alter table stu add primary(xm, xh);复合主键alter table stu drop primary;删除主键约束 外键约束： 引用另一个表的一列或多列，被引用的列应该具有主键约束或唯一性约束，包含外键的表称为子表，（父表） 表在外键上的取值要么是父表中的某个主键值，要么取空值，以此保证两个表之间的连接确保实体的参照完整性;否则会失败 主属性字段在插入时，子表不允许有父表没有的。 refrences:参照性，定义中包含了外键所参照的表和列 on delete| on update:为每个外键定义参照动作 restrict 当在父表（即外键的来源表）中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。 casade 删除&#x2F;更新 A 表的数据时，对应 B 表的数据也会删除&#x2F;更新； set null on delete set null：删除&#x2F;更新 A 表的数据时，对应 B 表的外键字段置为空（前提是该字段可以为空）如果添加外键时没加上面内容，删除&#x2F;更新 A 表的数据时，如果对应 B 表有数据就会报错； no action 意思同restrict.即如果存在从数据，不允许删除&#x2F;更新主数据。 1234建表时，将学号设置为外键，在最后 foreign key(xh) references xsjbxxb(xh);已存在的表 alter table stu add foreign key(xh) references xsjbxxb(xh);删除外键约束 alter table stu drop foreign key 外键名; 指定外键注意点： 先有父表，再创子表。或者是当前正在创建的表，在这种情况下，子表（参照表），被参照表和参照表是同一个表，自参照完整性。 必须为父表定义主键，父表名后指定列名，这个列必须是这个表的主键或唯一键 外键中的列数据类型必须和被参照表中的主键的列数据类型一致或兼容，且含义一样 唯一性约束： 保证表中字段取值的唯一性，可以有一个或多个，使得它们的值在任何时候都是唯一的 12345建表时 xm varchar(12) not null unique; 或者 unique(xm,xh);已存在 alter table stu modify xm varchar(12) not null unique;删除唯一性约束 alter table stu drop index xm; 唯一键和主键的区别： 只能有一个主键，可以有多个唯一键 主键不能null,唯一键可以，但必须有null声明，且只能有一个 索引不同 非空约束： 123xm varchar(20) not null;alter stu modify sex varchar(20) not null;删除 alter table stu modify sex varchar(20); 检查约束： 添加数据时会判断是否满足约束条件 123456sex char(1) not null check(sex in(&#x27;男&#x27;,&#x27;女&#x27;))列级约束（只一个check时）birth date not null,check(birth&gt;&#x27;1990-1-1&#x27;)表级约束，大于等于一个checkalter table stu add check(sex in(&#x27;男&#x27;,&#x27;女&#x27;));alter table stu drop check sex; 默认值约束： 没赋值给的默认值 1234sex varchar(2) default &#x27;男&#x27;alter table stu modify sex varchar(2) default &#x27;男&#x27;;alter table stu modify sex varchar(2); group by: 用于将查询结果按指定的列进行排序 asc|desc 升序|降序 limit: 用于限制查询的行数，其中offset为偏移量，从0开始 into: 保存查询结果到哪 查询 1234指定字段（列） select xm, xh from stu;去掉重复值 select distinct xh from stu;表达式查询 select xm, year(now() - year(csrq)) from stu where xb = &#x27;女&#x27;;岁数，单独的一列，year(now() - year(csrq))查询指定记录 where 123in:判断某个字段的值是否在指定的集合中\tselect xh,kcdm,cj from stu where kcdm in(&#x27;01&#x27;,&#x27;20&#x27;);查询课程代码为01/02的学生选课信息select xh,kcdm,cj from stu where cj between 80 and 90; like 模糊查询 12345678910mysql不区分大小写，要区分大小写时需要更换字符集的校对规则% ：0个或多个字符_ ：单个字符like&#x27;ab%&#x27;以ab开头的任意字符串like&#x27;%ab&#x27;以ab结束…………………………like &#x27;%ab%&#x27;包含ab…………………………like &#x27;_ab&#x27;以ab结束的三个字符的字符串使用转义字符要加escapeselect xm, xh from stu where xm like &#x27;%@_%&#x27; escape &#x27;@&#x27;;查为空的 where xh is null; 设置别名 希望查询结果中的列显示时使用自己选择的列标题，as子句 1select csrq as 出生日期,xh as 学号 from stu; 聚合函数查询 1234count() 统计满足条件的记录数\tselect count(*)as 学生人数 from stu;查询记录总数 *（非null）/ all/ distinct(去除重复值)select sum(cj) as 总成绩 from stu where xh=&#x27;2001&#x27;;avg、 max、 min同理 group by分组查询 需要按某列数据的值进行分组，在分组的基础上再进行查询 12345select xb as 性别,count(*) as 人数 from stu group by xb;按男女的人数统计总的 select xb as 性别,count(*) as 人数 from stu group by xb with rollup;每个分类的汇总值having 根据条件对已分组结果进行筛选过滤执行顺序where-&gt; group by-&gt; 聚合函数-&gt; having 对所选信息进行排序 12select xb, csrq from stu where xb = &#x27;女&#x27; order by csrq desc;限制所选行数 直接在末尾加 limit 3 / limit 3,4 从3开始4行 从0开始 多表查询： 内连接： 只需返回满足连接条件的数据行。两个表在进行连接时，连接字段的名称可以不相同，但必须有相同的数据类型、长度和精度，且标答同一范畴的意义，连接列字段一般是数据表的主键和外键。系统默认 using 子句为同系列的列命名(选择) 123select xs.xh,xm,kcmc,cj from xsjbxxb as xs join xsxkb on xs.xh=xsxkb.xh join kcdmb.kcdm=kcdmb.kcdm where xs.xh=&#x27;2001&#x27;;select xs.xh,xm,kcmc,cj from xsjbxxb as xs join xsxkb using(xh) join kcdmb using(kcdm) where xs.xh=&#x27;2001&#x27;; 外连接： 返回的结果集除包括符合条件的记录外，还会返回from子句中至少一个表中的所有行，不满足条件的数据行将显示为空值，又分左外连接、右外连接、全外连接 left join:结果集中除包括满足连接条件的行外，还包括左表中不满足条件的记录行。当左表中不满足条件的记录与右表记录进行组合时，游标相应值为null right join:同理 12左外连接select xs.xh, xm, kcdm, cj from xsjbxxb as xs left join xsxkb on xs.xh=xsxkb.xh where xs.xh=&#x27;2001&#x27;; 交叉连接： 在没有where子句的情况下，产生的表的笛卡尔积 1select 字段名 from stu cross join xsjbxxb; 自连接： 一个表的两个副本之间的内连接（自己和自己连接），为了区别，还必须对表指定不同的别名 1select xs1.sh, xs1.xm from stu as xs1, stu as xs2 where xs1.zymc=xs2.zymc and xs2.xm=&#x27;王三&#x27; and xs1.xm!=&#x27;王三&#x27;;查询与王三同一个专业的学生学号和姓名 子查询：嵌套查询 比较子查询：嵌套 带in的子查询：in(嵌套) 批量比较子查询：all（指定表达式要与子查询结果集中的每个值进行比较，只有当表达式与每个值都满足比较关系时，true）、some、any（表达式与子查询结果集中的某个值满足比较关系时，就会返回true） 12select xm from xsjbxxb where xh=some(select xh from xsxkb where cj&lt;60);select xm from xsjbxxb where csrq&lt;=all(select crsq from xsjbxxb); exist子查询：只返回一个逻辑值 1select xm from xsjbxxb where exists(select * from xsxkb where xsjbxxb.xh=xsxkb.xh); 子查询和连接查询在很多情况下可以互换： 查询语句要输出的字段来自多个表时，连接居多 输出字段来自一个表，where子句涉及另一个表，连接居多 只涉及一个表，但涉及聚合函数比较，子居多 正则表达式的模糊查询： regexp是正则表达式的缩写，但不是sql标准的一部分，可和rlike互换 ^ 匹配字符串开始字符 ^a -&gt; abc $ ………………结束字符 ing$ -&gt; string . ……任意单个字符，包括回车和换行 b.g -&gt; big * ……*之前的0个或多个字符 *c -&gt; abc、bc + ……该字符前面的字符1次或多次 p+hp -&gt; php 以hp结尾，前面至少一个p 12select xh,xm,xb from xsjbxxb where xm regexp &#x27;^张&#x27;;select xh,xm,xb from xsjbxxb where xm like &#x27;张%&#x27;; union合并结果集： 将多个select语句的返回结果组合到一个结果集中。当要检索的数据在不同的结果集中，并且不能利用一个单独的查询语句得到时 12select bjbh,bmh,bjzwmc from bjdmb where bmh=&#x27;01&#x27; union select bjbh,bmh,bjzwmc from bjdmb where bmh=&#x27;03&#x27;;查询部门号01、03的班级信息 索引：加速对数据进行检索而创建的一种分散的、物理的数据结构；根据表中一列或多列按照一定顺序建立的列值与记录行之间的对应关系表；所有数据类型都能被索引。 索引分类： 普通索引index：基本索引类型，允许在定义索引的字段插入重复值和空值 唯一索引unique：值必须唯一且允许有空值；组合索引字段值的组合必须唯一；一个表上可以有多个 主键索引primary key:取值唯一且不允许有空值；一般在建表时被创建，也可以通过修改表时添加主键索引；一张表只能有一个 全文索引fulltext:在定义索引的字段上支持值的全文查找；允许插入重复值和空值；总在整个字段上创建，不支持字段前缀索引 空间索引spatil:在空间数据类型字段上建立的索引；空间列上的索引必须时空间索引，并且仅适用于单个空间列；不能为空，不能用于主键或唯一索引 索引名称必须唯一 主键索引必须是唯一的，但唯一索引不一定是主键索引 创建主键约束可自动生成主键索引，创建唯一性约束时也会自动创建唯一索引。应保证索引满足约束条件。 创建索引键值列数：单列、复合 存储方式：hash、btree 索引原则： 并非越多越好 避免对经常更新的表创建过多的索引，对经常查询的表建立索引 经常需要排序、分组、联合操作的字段建立 不要对含有大量重复值的字段建索引 不要对数据量小的表建立索引 创建索引 12345678910create table course(\tcid varchar(6) not null, cname varchar(20) not null, credit float(3,1), semester int(1), index(cname desc));在cname上建立普通索引并降序排序alter table xsjbxxb add index index_xm(xm); index_xm时索引的名称create index index_xm_bj on xsjbxxb(xm desc, nj asc); 查看索引 123456已创建索引的情况show index from xsjbxxb;show create table xsjbxxb;索引的使用情况explain select * from xsjbxxb where 条件表达式; 删除索引 12drop index index_kcmc on kcdmb;alter table xsjbxxb drop index index_kcmc; 视图 虚拟表。是从一个或多个表及其它视图中通过select语句导出的表，其内容由查询定义派生出视图的表称为基表。视图包含一系列带有名称的字段和记录，但是只放了定义，没有放数据，浏览视图时所对应的数据行和列数据来自定义视图查询所引用的表，并且在引用视图时动态生成。 只有查询没有任何限制 优点：简化数据查询和处理、屏蔽数据库的复杂性、安全性 创建视图 在指定的数据库表上建立视图。视图可以建立在一张表上，也可以建立在多张表或已有视图上。需要权限 or replace:当已具有同名视图时，替换已有视图 alogrithm：视图算法可影响查询语句的解析方式 ​ undefined：默认，自动选择算法 ​ merge：将视图定义和查询视图时的select语句合并起来查询 ​ temptable：先将视图结果存入临时表，然后用临时表进行查询 definer:定义视图的用户与安全控制有关，默认为当前用户 ​ user|current_user sql security：用于视图的安全控制 ​ definer|invoker with (cascaded|local) check option：对于视图数据操作时的检查条件 ​ cascaded、local：决定了检查测试的范围。默认，在一个视图的基础上创建另一个视图时，进行级联检查|操作数据时满足该视图本身定义的条件即可 123create view xs_1 as select xh,xm,xb,zymc from xsjbxxb where zymc=&#x27;通信工程&#x27; with check option;create view xs_cj_avg(专业名称，平均成绩) as select zymc,avg(cj) from xsjbxxb,xsxkb where xsjbxxb.xh=xsxkb.xh group by zymc;建立一个计算每个专业平均成绩 查看视图 1234desc 视图名;show table status like &#x27;视图名&#x27;;(为null是虚表)show create view 视图名;select table_a, table_b, view_a from information_a.views where table_name=&#x27;视图名&#x27;;查看视图详细信息 修改视图 对已存在的 12create or replace view 名字 as select ……;alter view 名字 as select ……; 查询视图 1select *from xs_kc where xb=&#x27;男&#x27;; 更新视图 通过视图修改基表。不是所有视图都能更新，只有满足条件的视图才可以更新 不能更新的情况: 含聚合函数 含union&#x2F;union all&#x2F;distinct&#x2F;top&#x2F;group by&#x2F;having等关键字 定义视图的select中包含子查询 由不可更新的视图导出的视图 视图上对应的数据表上存在没有默认值且不为空的列，该列没有被包含在视图里 from子句中包含多个表 12345678910和正常插入一 insert在创建视图中使用了 with check option，所有对视图进行修改的语句必须符合这个限定条件一次插入只能作用到一个基表上更新 updateupdate xs_kc set cj=80 where xm=&#x27;张三&#x27;;删除数据 delete对视图操作，基表同时被操作当一个视图连了两个以上的基表，对数据的删除不会成功 删除视图 只删了定义，不会影响基表中的数据 1drop view xs_kc; 最好仅将视图作为虚表，不要通过视图更新数据 常量 实型常量 12.3，-56.4，12e3 整型常量 字符串常量 ‘ab #3’、”abc def “ 日期&#x2F;时间常量 ‘2010-04-02’ 布尔值 null值 表示无数据，但不同于空字符串和数字0 unicode字符前面有一个N标志符，必须为大写 N&#39;hello&#39; 变量 全局变量:系统定义，自动初始化陌生值，用户不能定义；值可以通过my.ini修改，但必须有super权限；影响整个服务器 12345678910查看所有全局变量的值 show global variables;指定显示某个全局变量的值 select @@global.变量名;设置全局变量set global var_name=value;set @@global.var_name=value;调用全局变量是，需要在名称前加上&#x27;@@&#x27;，但在系统日期、系统时间、用户名等全局变量的值设为400 set global rang_alloc_block_size=400;这里的global不能省略，否则默认为会话变量 session 会话变量:每次建立一个新连接是，由mysql服务器将当前所有全局变量复制一份给会话变量完成初始化，它只影响当前的数据连接参数；只能更改自己的 12345678设置set session var_name=value;set @@session.var_name=value;set var_name=value;查看select @@var_name;select @@session.var_name;show session variables like &quot;th%&quot;; 用户变量:必须定义和初始化，没有则为null 1set @name=&#x27;王三&#x27;; 局部变量:declare 必须定义在函数、触发器、存储过程等存储程序中，不能单独使用 1declare name char(6) default &#x27;张三&#x27;; &lt;&#x3D;&gt; 安全等于，不会返回unknown （true、false） &lt;&gt; 、!&#x3D; 不等于 least 返回最小值 greatest 返回最大值 in 判断一个值是in列表中的任意一个值 not in ………………不是……………………………… like 通配符匹配 regexp 正则表达式匹配 not ! and &amp;&amp; 有0为0 or || xor 有1为1 流程控制语句 123456789101112131415161718delimiter$$create preocedure getGrade(cj varchar(20))begin declare stu_grade float; select cj into stu_grade from xsxkb where xh=stu_no and kcdm=cour_no; if stu&gt;=90 then select stu_grade,&#x27;A&#x27;; elseif ; end if; case when stu_grade&gt;=90 then select stu_grade,&#x27;A&#x27;; end case;end $$delimiter; 1234567891011121314delimiter$$create preocedure getGrade(a int)begin declare i int default 1; loop_name: loop if i&gt;a then leave loop_name;--判断条件成立则结束循环 end if; set sum=sum+i; set i=i+1; end loop;--循环结束 select sum;end$$delimiter; 123456789declare sum int default 0;declare i int default 1; repeat --循环开始 if i&gt;a then set sum=sum+i; set i=i+1; until i&gt;a end repeat;--循环结束select sum; 1234while i&lt;=a do\tset sum=sum+i;\tset i=i+1;end while; 1234567label1:loop set p1=p1+1; if p1&lt;10 then inerate lable1; end if; leave lable1;end loop label1; 加密函数： md5() 计算字符串的md5校验和 sha() …………………安全散列算法(sha)校验和 sha2(str,hash_length) hash_length支持的值为224、256、384、512、0 自定义函数 12345create function 函数名（参数列表） returns 数据类型begin\t;return 值;end; 123456查看函数 show create function 函数名;\tshow function status;\talter function 函数名 选项;drop function 函数名; 存储过程的函数：一组经过编译并保存在数据库中sql语句的集合 ​ 允许标准组件式编程、较快的执行速度、减少网络流量、安全 存储过程的创建 12345678delimiter$$create procedure proc(out num int)begin\tselect count(*) into num from xsjbxxb;end $$delimiter;作用是将语句的结束符;修改为$$，不会出现错误proc的简单存储过程，用于获取表xsjbxxb中的记录数 存储过程的调用 12call proc(@num);select @num;--输出 查看存储过程 123456查看存储过程的状态show procedure status like &#x27;proc&#x27;;查看存储过程的定义show create procedure jwgl.proc;查看存储过程的信息select *from information_schema.routines where routine_name=&#x27;pf_name&#x27;; 修改存储过程 不能使用关键字alter更改存储过程的参数或子程序，如果需要修改，则必须删除存储过程后再重新创建 1alter procedure proc modify sql data sql security invoker;修改读写权限和安全类型 删除存储过程 1drop procedure [if exists] proc; 存储过程与函数的联系与区别： 存储过程实现的功能更复杂，函数的实现功能针对性比较强 存储过程可以返回参数，不需要返回类型；函数只能返回值或者表对象（一个） 存储过程可以使用非确定函数，不允许在用户定义函数主体中内置非确定函数 存储过程一般作为一个独立的部分来执行；函数在select后面；sql中不可以使用存储过程，但可以使用函数 在存储过程和函数中，当查询语句返回多条记录时，可以使用游标对结果集进行逐条读取 定义游标 declare 1declare youbiao cursor for select语句; 打开游标 在打开一个游标时，游标并不指向第一条记录，而是指向第一条记录的前面 1open youobiao; 使用游标 fetch 常与循环结构配合使用，用于遍历表中的所有记录 1fetch youbiao into 变量名; 将定义游标是查询出的数据赋予变量 关闭游标 1close youbiao; 例子： 创建存储过程，并显示前3名同学的xh、xm 123456789101112131415161718192021DELIMITER $$ CREATE PROCEDURE proc1() BEGIN DECLARE s_xh VARCHAR(20); DECLARE s_name VARCHAR(50); DECLARE stu CURSOR FOR SELECT xh, xm from xsjbxxb; OPEN stu; FETCH stu INTO s_xh, s_name; SELECT s_xh, s_name; FETCH stu INTO s_xh, s_name; SELECT s_xh, s_name; FETCH stu INTO s_xh, s_name; SELECT s_xh, s_name; SELECT s_xh, s_name; CLOSE stu; END $$DELIMITER; 统计xsjbxxb中age&gt;20 12345678910111213141516171819202122232425DELIMITER $$\tCREATE PROCEDURE proc2() BEGIN DECLARE total int; DECLARE id VARCHAR(20) CHARACTER SET utf8; DECLARE done INT DEFAULT 0; DECLARE cur CURSOR FOR SELECT xh FROM xsjbxxb WHERE age &gt; 20; DECLARE CONTINUE HANDLER FOR NOT found SET done = 1; 指定游标循环结束时的返回值 open cur; set total = 0; WHILE done != 1 DO FETCH cur INTO id; if done != 1 THEN SET total = total + 1; END IF; END WHILE; CLOSE cur; SELECT &quot;年龄大于20岁的有：&quot;,total,&quot;人&quot;; END $$DELIMITER ;call proc(); 触发器 与存储过程类似，也是一段程序代码。但触发器是由事件激发某个操作的（当表中出现特定事件时就会激发该对象） 是特殊存储过程，只要一个预定义的点事件发生就会被mysql自动调用 ​ 引发触发器执行的事件一般如下： 增加一条学生记录时，自动检查年龄是否符合范围要求 删除一条学生信息时，自动删除其成绩表上对应的记录 删除一条数据时，会在数据库存档表中保留一个备份副本 执行是自动的，当对触发器相关表的数据进行修改后可立即执行 触发器可以通过数据库相关的表层叠修改另外的表 触发器可以实施比外键约束、check约束更为复杂的检查和操作 与表关系密切，主要用于保护表中的数据。特别是当有多个表具有一定的相互联系时，触发器能让不同的表保持数据的一致性 insert触发器 在insert语句执行之前或之后响应的触发器（后面同理） 在insert触发器代码内，可引用一个名为new的虚拟表来访问被插入的行 …before insert………new中的值也可以被更新（可修改被插入的值（要有权限）） 对于auto_increment列，new在insert执行之前包含的值是0，在insert执行之后将包含新的自动生成值 update触发器 在update触发器代码内，可引用一个名为new的虚拟表来访问被更新的值 ……………………………………………………………old…………………………update语句执行之前的值 old中的值全是只读的 在before update触发器代码内，new中的值可能也会被更新，即允许更改将要用于update语句中的值 当触发器设计对触发表自身更新操作时，只能使用before类型的触发器，after类型 的则不被允许 delete触发器 在delete触发器代码内，可引用old的虚拟表来访问被删除的行 触发器出现错误，mysql的处理： 对于事务性表，触发程序失败，以及由此导致的整个语句失败，那么该语句所执行的所有更改将回滚；对于非事务性表，则不能执行此类回滚，即使语句失败，失败之前所作的任何更改依然有效 若before触发程序失败，则mysql将不执行相应行上的操作。若在before或after触发程序的执行过程中出现错误，则将导致调用触发程序的整个语句失败。仅当before触发程序和行操作均已被成功执行，mysql才会执行after触发程序 创建触发器 1create trigger 触发器名 before/after insert/update/delete on 表名 for each row 主体; 表名把必须是永久性表，不能把临时表或者视图和这个关联起来 同一个表不能拥有两个具有相同触发时刻和事件的触发器（不能同时有两个before insert） 主体:表示触发器的动作主体，包含激发器激活时要执行的mysql语句。如果有多个，即用begin……end复合语句结构 每个表最多支持6个触发器，每个表的每个事件每次只允许有一个触发器，即单一触发器不能与多个事件或多个表关联 before类型触发器 创建触发条件为向表tb_emp8插入数字之前，对新插入的salary字段值进行求和计算 123456create trigger Summ before insert on tb_emp8 for each row set @sum=@sum+new.salary;set @sum=0;insert into tb_emp8 values(1,&#x27;A&#x27;,1000),(2,&#x27;B&#x27;,2000);select @sum; after类型触发器 创建一个名为ds的触发器，触发条件是向表te6中插入数据后，再向te7中插入相同的数据，并且salary为te6中新插入的字段值的2倍 1create trigger ds after insert on te6 for each row insert into te7 value(new.id,new.name); 查看触发器 12345show triggers;查看某个表上的： show triggers from 数据库名 like 表名;精确查看某个触发器： show triggers where &#x27;trigger&#x27; like &#x27;名字%&#x27;;触发器的详细信息： select *from 数据库 where trigger_name=&#x27;&#x27;； 删除触发器 1drop trigger 数据库.触发器名字; 事件 调度事件：指按调度表运行的任务 创建事件时，可将其创建为命名数据库对象，其中包含在特定时间执行或定期重复的sql语句（或存储过程） 事件与触发器： 相同点： ​ 在某些事情发生时启动 不同点： ​ 事件基于特定时间周期来触发执行某些任务；触发器基于某个表所产生的事件来触发 查看事件状态 12345show variables like &#x27;event_scheduler&#x27;;select @@event_scheduler;set global event_scheduler=on/off/1/0;set @@global.event_scheduler=on/off/1/0; 创建事件 事件event_minute，设定在2022-06-01 09:40:00时每分钟向数据表ub_emp8中插入一条记录，然后创建事件，事件类型：间隔触发&#x2F;特定事件触发 12345678910DROP EVENTIF EXISTS event_minute;delimiter $$ CREATE DEFINER = &#x27;root&#x27;@&#x27;localhost&#x27; EVENT event_minue ON SCHEDULE EVERY 1 MINUTE STARTS &#x27;2022-06-01 09:40:00&#x27; ON COMPLETION NOT PRESERVE ENABLE DO BEGIN INSERT INTO tb_emp8 VALUES(3, &#x27;C&#x27;, 1000); INSERT INTO tb_emp8 VALUES(4, &#x27;D&#x27;, 1000);\tEND $$ 查看事件 1show events; 所有触发器的定义都存储在系统数据库中的information_schema的events表中 1select *from information_schema where events_name=&#x27;事件名&#x27;; 删除事件 1drop event [if exist] 事件名; 禁用事件 1alter event 事件名 disable; 开启事件 1alter event 事件名 enable; 修改事件 1alter event 事件名;"},{"title":"对拍","path":"/undefined/STL总结/","content":"STL总结1234567迭代器例子：`set&lt;int&gt;:: iterator it;for(it = x.begin(); it != x.end(); ++it) x.rbegin(); x.rend; ++ (反向迭代器)for(auto w: x) 排序： sort(v.begin(), v.end()) （包括字母）（less&lt;int&gt;() &#x2F; greater&lt;int&gt;()） vectorvector&lt;int&gt; a(n + 1);\t能先开辟先开辟，如果输入失败又可能这里出问题了 vector&lt;int&gt; b = a;\t定义的时候等于，否则可能会出问题 map默认key从小到大排序 自定义按value :sort cmp(pair&lt;int, int&gt;a, pair&lt;int, int&gt;b) return a.second &lt; b.second; 获取最大值： auto i = max_element(t.begin(), t.end(), cmp) (还有min_element) map&lt;int, set&lt;string&gt;&gt; m; word[len] = set&lt;string&gt;(); (只是创建空间， 会重置原数据) 返回出现次数：m.count(length) 可以mp.first(); mp.second(); pair先比较第一个，第一个相同再比较第二个 当想插入两个： q.push(make_pair(0, 0)); string大小转 小写：transform(s.begin(), s.end(), s.begin(),tolower) 小写转大写：toupper 有空格：getline(cin, s); s.substr(0，n): 从1开始数n个 s.reverse(s.begin(), s.end()) : 字符串翻转 12s.insert(pos, string, pos1, size_n) : 从pos1开始数的第n个字符插在pos前s.insert(pos, n, char c) : 在下标为pos前插入n个字符c (n个相同的) 1.count(begin, end, &quot;s&quot;); set去重 + 自动排序 multiset： 不去重（可以删除某个点） 123s.erase(pos) 删除pos迭代器所选元素s.erase(x.begin(), x.end()) 删除[begin, end)内所有元素s.erase(elem) 删除值为elem的元素 set.count(string s) ： set内有几个与s相同的 &#x2F;&#x2F;string同样可用 12set.count(begin, end, &quot;s&quot;);set.count(&quot;s&quot;); queue12345queue&lt;pair&lt;int, int&gt;&gt; q;q.insert(&#123;a, b&#125;);q.pop();int c = q.front().first;int d = q.front().second;"},{"title":"对拍","path":"/undefined/STL关于50条总结/","content":"STL关于50条总结（effective stl） 标准STL序列容器： vector、string、deque、list 标准STL关联容器（会按照某种排序规则插入）： set、mulitiset、map、multimap 非标准STL序列容器： slist、rope 非标准的关联容器hash_set、hase_multiset、hash_map和hash_multimap 几种标准的非STL容器，数组、bitset、valarray、stack、queue和priority_queue 序列容器支持push_front &#x2F; push_back 关联容器提供了对数时间的lower_bound、ipper_bound、equal_range 123456789连续内存容器：标准： vector、string、deque​ 非标准：rope基于节点的容器：容器内元素的插入删除只影响指向节点的指针（提供了双向迭代器）​ list、slist标准C++部分： 排除slist、rope对插入删除失败的回滚能力： 基于节点的容器deque的插入操作仅在末尾时，迭代器可能会失效，但指针和引用不会失效（特殊的） 任意位置插入： 序列容器 元素查找速度： 哈希 &gt; 排序的vector &gt; 标准关联容器 随机访问迭代器： vector、string、deque ​ 要求这个的： sort类的函数、nth_element 12345string是STL中在swap过程中会导致迭代器、指针和引用变为无效的唯一容器。STL容器是各自有优缺点的，不能混在一起用。\t有时候可能会改容器，这时候使用封装P14（暂时不想看懂）拷贝对象是STL的工作方式通过利用插入迭代器的方式来限定目标区间的copy调用，几乎全部应替换为对区间成员函数的调用 map&lt;string, vector&lt;类&gt;&gt;遍历： map&lt;string, vector&lt;类&gt; : : iterator&gt; : : const_iterator if(c.size() &#x3D;&#x3D; 0)\t&lt;&#x3D;&gt;\tif(c.empty()) (这个更优,对所有容器都为常数操作) 两个vector 使v1的内容和v2的后半部分相同的最简单操作： v1.assign(v2.begin() + v2.size() / 2, v2.end()); (copy也影响效率，不行) 对区间函数调用： v1.insert(v1.end(), v2.begin(), + v2.size() / 2, v2.end()); ​ （数组插到vector也可用） ​\tassign： 需要完全替换一个标准序列容器内容时 ​\toperator &#x3D; : 可选择的赋值函数 ？"},{"title":"dfs","path":"/undefined/DFS/","content":"DFS小技巧while(cin &gt;&gt; ch) 一般枚举所有的两种方案dfs （2^n）**&#x2F; ** 二进制(n * 2^n) 看第 i 位是不是1，可以右移 i 位再 &amp;1 看 u &gt;&gt; i &amp; 1 （要从0开始枚举） 如果需要拼接： dfs 能剪枝的就把它先剪了（在确认没错的情况下） 找区间： ret += upper_bound(a.begin(), a.end(), 3 * a[j] - 2 * a[i]) - lower_bound(a.begin(), a.end(), 2 * a[j] - a[i]);（找z） 二分也行啊，别再一个一个试了$$给出 n 根长度不一的木棍，第 i 根棍子长度为 a_i 。两根长度分别为a_b和a_c的木棍可以拼接成一根长度为a_b + a_c的木棍，同理3根,4根，甚至n根都能拼接。 问：使用这 n 根木棍作三角形的边（一根木棍至多使用一次，也可以不使用），能拼出的面积最大的三角形的面积。$$ 123456789101112double dfs(int l1, int l2, int l3, int cnt)&#123; if(cnt&gt;n) return -1;//最优性剪枝？？ if(judge(l1, l2, l3)) &#123; mx = max(mx,area(l1,l2,l3)); &#125; dfs(l1+a[cnt],l2,l3,cnt+1); dfs(l1,l2+a[cnt],l3,cnt+1); dfs(l1,l2,l3+a[cnt],cnt+1); dfs(l1,l2,l3,cnt+1); return mx;&#125; 12345678910111213141516string s = &quot;BESIGOM&quot;;\tmap&lt;char, int&gt; v;\tint ans = 0;\tfor (int i = 0; i &lt; (1 &lt;&lt; 7); ++i) &#123; for (int j = 0; j &lt; 7; ++j) v[s[j]] = i &gt;&gt; j &amp; 1;// for (auto w : v) &#123; cout &lt;&lt; w.first &lt;&lt; &quot; &quot; &lt;&lt; w.second &lt;&lt; endl; &#125; if ((v[&#x27;B&#x27;] + v[&#x27;I&#x27;]) * (v[&#x27;G&#x27;] + v[&#x27;O&#x27;] + v[&#x27;E&#x27;] + v[&#x27;S&#x27;]) * v[&#x27;M&#x27;] % 2 == 0) &#123; int temp = 1; for (int j = 0; j &lt; 7; ++j) temp *= mp[i &gt;&gt; j &amp; 1][s[j]];//组合数学 ans += temp; &#125;\t&#125; 12345678910111213141516171819202122232425最长正方形搜索， dp可做 （最好从1，1开始存） dp: 查上方，左方，左上方 f[i][j]=min(min(f[i][j-1],f[i-1][j]),f[i-1][j-1])+1 ans = max(f[i][j], ans); max说明了能取成功， f[n][m]不一定能取成功int a[105][105];int n, m, xx, yy, temp = 0;void dfs(int x, int y) &#123;\tif (!a[x][y]) return ;\tfor (int i = xx; i &lt; x; ++i) if (!a[i][y]) return ;\tfor (int i = yy; i &lt; y; ++i) if (!a[x][i]) return ;\t++temp;\tdfs(x + 1, y + 1);//直接搜下一层（）斜对角可以搜&#125;\tint ans = 0;\tfor (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (a[i][j]) &#123; temp = 0; xx = i, yy = j; dfs(i, j); ans = max(ans, temp);//是可以放出来的\t&#125;\t&#125;\t&#125; 12345678910111213141516171819202122232425262728293031323334int n, a[20];\tbool vis[20];\t//全部选择，对n升序排序// 一共tar个坑，当前枚举到第pos个坑void dfs(int pos, int tar) &#123; if (pos == tar + 1) &#123; for (int i = 1; i &lt;= tar; i ++ ) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return ; &#125; // 选数填坑，选择的数范围是1～n for (int i = 1; i &lt;= n; i ++) &#123; if (!vis[i]) &#123; vis[i] = true; a[pos] = i; dfs (pos + 1, tar); vis[i] = false; &#125;\t&#125;\t&#125; for (int i = 1; i &lt;= n; i++) dfs(1, i);//只需要小的在前，大的在后，增加条件// 当前枚举到第pos个坑， 上一个坑填的是start-1，这次只能从start开始找数填， 一共要填tar个坑void dfs(int pos, int start, int tar) &#123; if (pos == tar + 1) &#123; for (int i = 1; i &lt;= tar; i ++ ) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return ; &#125; // 选数填坑，选择的数范围是start～n for (int i = start; i &lt;= n; i ++) &#123; if (!vis[i]) &#123; vis[i] = true; a[pos] = i; dfs (pos + 1, i + 1, tar); vis[i] = false; &#125;\t&#125;\t&#125; for (int i = 1; i &lt;= n; i ++ )\tdfs(1, 1, i); 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#define x first\t#define y second\tusing namespace std;typedef pair&lt;int, int&gt; PII;\tconst int N = 55; //acwing奶牛选美int n, m;\tchar g[N][N];\tvector&lt;PII&gt; points[2];int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;//记住这种void dfs(int x, int y, vector&lt;PII&gt;&amp; ps)&#123;\tg[x][y] = &#x27;.&#x27;; ps.push_back(&#123;x, y&#125;);//这样放置 for (int i = 0; i &lt; 4; i ++ )&#123; int a = x + dx[i], b = y + dy[i]; if (a &gt;= 0 &amp;&amp; a &lt; n &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; m &amp;&amp; g[a][b] == &#x27;X&#x27;)// dfs(a, b, ps);//&#125;\t&#125;int main()&#123;\tcin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i ++ ) cin &gt;&gt; g[i];//输入 for (int i = 0, k = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; m; j ++ ) if (g[i][j] == &#x27;X&#x27;) dfs(i, j, points[k ++ ]);//求连通块的精妙之处，在dfs中早已处理好了这块 int res = 1e8; for (auto&amp; a: points[0]) for (auto&amp; b: points[1]) res = min(res, abs(a.x - b.x) + abs(a.y - b.y) - 1); return 0;&#125; 星空之夜🔗 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960char g[105][105];int m, n;\tint top;const double eps = 1e-6;\tpair&lt;int, int&gt; q[105 * 105];inline double dis(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) &#123;\tdouble dx = a.first - b.first;\tdouble dy = a.second - b.second;\treturn sqrt(dx * dx + dy * dy);&#125;double get_sum() &#123;//利用两两之间的距离hash映射\tdouble sum = 0;\tfor (int i = 0; i &lt; top; ++i) &#123; for (int j = i + 1; j &lt; top; ++j) &#123; sum += dis(q[i], q[j]); &#125;\t&#125;\treturn sum;&#125;char get_tu(double key) &#123;\tstatic double tu[30];\tstatic int id = 0;\tfor (int i = 0; i &lt; id; ++i) &#123; if (fabs(tu[i] - key) &lt; eps) return i + &#x27;a&#x27;;\t&#125;\ttu[id++] = key;\treturn id + &#x27;a&#x27; - 1;&#125;void dfs(int x, int y) &#123;\tq[top++] = &#123;x, y&#125;;\tg[x][y] = &#x27;0&#x27;;\tfor (int i = x - 1; i &lt;= x + 1; ++i) &#123; for (int j = y - 1; j &lt;= y + 1; ++j) &#123; if (i == x &amp;&amp; j == y) continue; if (i &gt;= 0 &amp;&amp; i &lt; n &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; m &amp;&amp; g[i][j] == &#x27;1&#x27;) dfs(i, j); &#125;\t&#125;&#125;int main() &#123;\tIOS\tcin &gt;&gt; m &gt;&gt; n;\tfor (int i = 0; i &lt; n; ++i) cin &gt;&gt; g[i];\tfor (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123;//连通块 if (g[i][j] == &#x27;1&#x27;) &#123; top = 0; dfs(i, j); char c = get_tu(get_sum()); for (int k = 0; k &lt; top; ++k) &#123; g[q[k].first][q[k].second] = c; &#125; &#125; &#125;\t&#125;\tfor (int i = 0; i &lt; n; ++i) cout &lt;&lt; g[i] &lt;&lt; endl;\treturn 0;&#125;"},{"title":"刷题1","path":"/undefined/关于题目/","content":"小红和紫准备玩一个游戏。她们拿到了一个只包含小写字母的字符串 s。两人轮流将一个小写字母添加到一个新串t的结尾，必须保证t时刻都是s的一个子序列。谁先无法操作则输掉游戏。t初始是一个空串。小红先手添加，假设两人都足够聪明，请问谁最终能获得胜利？ 🔗 123456789101112131415161718\tint i,j=s.length()-1; for(i=j-1;i &gt;= 0;i--)&#123;//注意i大于等于0 if(s[i]==s[j])j=i-1,i=j;\t&#125; if(j==-1)cout&lt;&lt;&quot;yukari&quot;; else cout&lt;&lt;&quot;kou&quot;;最后一个&#x27;b&#x27;，谁的 t 串添加到这里谁就赢了。那么字符串标记为afnabasfoa[b]afnabasfoa[b]。其中中括号为必胜区间。//ab cabc 取了b，无论选cab中的谁都没办法结束 是要赢只能选那个必胜区间，否则根本没法那么，这个 b 到上一个 b 之间所有的字母都是必败的。因为如果某人“不小心”取到了这些字母中的任意一个，对方只要在后面加一个 &#x27;b&#x27; ，就直接到了最后一个 b 了。因此，第五个字母 &#x27;b&#x27; 后面这些字母都是必败的。字符串标记为 afna(basfoa)[b]afna(basfoa)[b]。其中小括号为必败区间。那么第四个字母&#x27;a&#x27;就是必胜的，因为只要某人取到了这个 a ，对方就不得不取后面的小括号区间的某个字母，导致失败。以此类推，字符串可以标记为 (afn)[a](basfoa)[b](afn)[a](basfoa)[b]。标记的逻辑是：最后一个字母 chrchr 为必胜，那么找到它前面离它最近的那个 chrchr ，这段区间为必败。必败区间前面的那个字母为必胜，以此类推，标记出所有区间。那么怎么评定胜负的标准呢？很简单，若第一个字母在必败区间，那么小红必败。否则小红必胜，因为小红可以直接取到第一个必败区间前面的那一个字母，迫使紫m去取必败区间。 如果要求每次添加的时候t都是s的子串，解法是后缀自动机next指针dag图上求sg函数 炸鸡块君和同学们一共n个人去学校附近玩耍，先让m个人带校园卡进入学校，再派一个人带着所有m张校园卡出来，重复上述过程，直到所有人进入学校。 假设从外面进入学校和从校内出来到校外都需要花费一个单位的时间，求所有人都进入学校最少需要花费几个单位的时间。🔗 123456789 if(n &gt; 1 &amp;&amp; m == 1) &#123; cout &lt;&lt; -1 &lt;&lt; endl; continue;\t&#125; if(n &lt;= m)&#123; cout &lt;&lt; 1 &lt;&lt; endl; continue;\t&#125; ans = ceil(((double)(n - 1)) / (m-1));//之所以不是n/m-1 例如5 2 =&gt; 7 //必须往大了的去取整，时间毕竟是个整数，具体还是看要求 cout &lt;&lt; ans * 2 - 1 &lt;&lt; endl;就去硬模拟，不对一定有不对的地方，先改ll， 奇数奇数 奇数偶数 偶数奇数 奇数偶数 这样去试 逆洗牌🔗 123456for (int i = 1; i &lt;= n; ++i) &#123;\tcin &gt;&gt; tem; mp[tem] = i;\t&#125;//string temp;for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; s[i]; for (int i = 1; i &lt;= n; ++i) t[mp[mp[mp[i]]]] = s[i];//for (int i = 1; i &lt;= n; ++i)\tcout &lt;&lt; t[i] &lt;&lt; endl; 一定要抽象问题！！！状压dp: https://ac.nowcoder.com/acm/contest/11230/F 贪心： https://ac.nowcoder.com/acm/contest/11230/E 定理：当且仅当一个数组a1,a2,…,an满足以下两个约束条件时，它可以通过一连串的操作被完全删除。 n是偶数 数组中任何元素的最大频率最多为n&#x2F;2。 本题需要取模，而期望值并不一定是整数，所以要用到逆元和快速幂"},{"title":"对拍","path":"/undefined/对拍/","content":"只需要四个cpp文件生成的数据、对拍文件、你写的、暴力的绝对正解（按图的顺序）这个的输出格式就是你造数据的格式，对比的也是结果的文本，记得全部编译一次。 rand()：随机数； % 10 是为了取[0， 10）之间的数据，后面如果加减同理是为了得到区间里的数第7行是为了避免相同的数据这里这些是名字，名字改了就行直接点运行，运行那个duipai.cpp就可以了进阶后面再写本来是想在蓝桥杯用，似乎学校的两个编译器都不支持。"}]