
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.29.1" theme-name="Stellar" theme-version="1.29.1">
  
  <meta name="generator" content="Hexo 6.3.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  
  <title>计网 - nu∞-记录</title>

  
    <meta name="description" content="HTTP 的基本概念网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。 HTTP工作原理HTTP协议定义 Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。 客户端向服务器发送一个请求报文，服务器以一个状态行来响应。 HTTP请求&#x2F;响应的步骤 连接请求加响应，释放解析整过程。">
<meta property="og:type" content="article">
<meta property="og:title" content="计网">
<meta property="og:url" content="http://example.com/undefined/%E8%AE%A1%E7%BD%91/index.html">
<meta property="og:site_name" content="nu∞-记录">
<meta property="og:description" content="HTTP 的基本概念网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。 HTTP工作原理HTTP协议定义 Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。 客户端向服务器发送一个请求报文，服务器以一个状态行来响应。 HTTP请求&#x2F;响应的步骤 连接请求加响应，释放解析整过程。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="d:\Typeeasy\image-20231012162427806.png">
<meta property="og:image" content="d:\Typeeasy\image-20231012162404877.png">
<meta property="og:image" content="d:\Typeeasy\image-20231012162337964.png">
<meta property="og:image" content="d:\Typeeasy\image-20231012162450724.png">
<meta property="og:image" content="d:\Typeeasy\image-20231012163833400.png">
<meta property="og:image" content="d:\Typeeasy\image-20231012164326559.png">
<meta property="og:image" content="d:\Typeeasy\image-20231012164347247.png">
<meta property="og:image" content="d:\Typeeasy\image-20231016161842423.png">
<meta property="og:image" content="d:\Typeeasy\image-20230526151812433.png">
<meta property="og:image" content="d:\Typeeasy\image-20231016163005086.png">
<meta property="og:image" content="d:\Typeeasy\8ecdc60670194df7957ee59e1f56701ftplv-k3u1fbpfcp-watermark.png">
<meta property="og:image" content="d:\Typeeasy\f756ad3403bc4fe18e970c56677c796etplv-k3u1fbpfcp-watermark.png">
<meta property="og:image" content="d:\Typeeasy\b67bd1f793a3425d9e8a415cae9b7863tplv-k3u1fbpfcp-watermark.png">
<meta property="og:image" content="d:\Typeeasy\77d8ae8e0de44f3aa693f0626a346d4ctplv-k3u1fbpfcp-watermark.png">
<meta property="og:image" content="d:\Typeeasy\image-20231022210218706.png">
<meta property="og:image" content="d:\Typeeasy\image-20231022213256211.png">
<meta property="article:published_time" content="2024-09-29T03:26:37.000Z">
<meta property="article:modified_time" content="2024-09-29T03:28:50.834Z">
<meta property="article:author" content="abulili">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:\Typeeasy\image-20231012162427806.png">
  
  
  
  

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.29.1">

  
    <link rel="shortcut icon" href="https://ww4.sinaimg.cn/mw690/007SwF3Bgy1hrnqrl7allj30wr0wrq5e.jpg">
  

  

  
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://ww4.sinaimg.cn/mw690/007SwF3Bgy1hrnqrl7allj30wr0wrq5e.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">nu∞-记录</div><div class="sub normal cap">专栏为主，不在侧栏最近更新显示</div><div class="sub hover cap" style="opacity:0"> 什么事？</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"></nav>
</div>
<div class="widgets">


<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/undefined/1panel%E5%AE%89%E8%A3%85/"><span class="title">1panel安装</span></a><a class="item title" href="/undefined/9-29%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"><span class="title">面试记录1</span></a><a class="item title" href="/undefined/css/"><span class="title">css</span></a><a class="item title" href="/undefined/%E8%AE%A1%E7%BD%91/"><span class="title">计网</span></a><a class="item title" href="/undefined/%E6%B5%8F%E8%A7%88%E5%99%A8/"><span class="title">浏览器</span></a><a class="item title" href="/undefined/vue/"><span class="title">vue</span></a><a class="item title" href="/undefined/js/"><span class="title">js</span></a><a class="item title" href="/undefined/%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%E5%90%8E%E4%BE%A7%E8%BE%B9%E6%A0%8F%E6%B6%88%E5%A4%B1/"><span class="title">打包部署后侧边栏消失</span></a><a class="item title" href="/undefined/ruankao/"><span class="title">软考</span></a><a class="item title" href="/undefined/school/"><span class="title">校内项目</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2024-09-29T03:26:37.000Z">2024-09-29</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2024-09-29T03:28:50.834Z">2024-09-29</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>计网</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><h3 id="HTTP-的基本概念"><a href="#HTTP-的基本概念" class="headerlink" title="HTTP 的基本概念"></a>HTTP 的基本概念</h3><p><code>网络协议</code>，是一个客户端和服务器端<code>请求和应答的标准（TCP）</code>，用于从 WWW 服务器传输超文本到本地浏览器的<code>超文本传输协议</code>。</p>
<h3 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h3><p>HTTP协议定义 Web客户端<code>如何</code>从Web服务器<code>请求</code>Web页面，以及服务器如何把Web页面<code>传送</code>给客户端。</p>
<p>客户端向服务器发送一个<code>请求报文</code>，服务器以一个<code>状态行来响应</code>。</p>
<h3 id="HTTP请求-x2F-响应的步骤"><a href="#HTTP请求-x2F-响应的步骤" class="headerlink" title="HTTP请求&#x2F;响应的步骤"></a>HTTP请求&#x2F;响应的步骤</h3><blockquote>
<p>连接请求加响应，释放解析整过程。</p>
</blockquote>
<ul>
<li>1.客户端连接到Web服务器</li>
<li>2.发送HTTP请求</li>
<li>3.服务器接受请求并返回HTTP响应</li>
<li>4.释放TCP连接</li>
<li>5.客户端（浏览器）解析HTML内容（超文本）</li>
</ul>
<h3 id="HTTP-的-5-种方法"><a href="#HTTP-的-5-种方法" class="headerlink" title="HTTP 的 5 种方法"></a>HTTP 的 5 种方法</h3><blockquote>
<p>增删改查（资源） + 头部获取</p>
</blockquote>
<ul>
<li>GET—获取资源 查</li>
<li>POST—传输资源 增（删改）</li>
<li>PUT—更新资源 ·改</li>
<li>DELETE—删除资源 删</li>
<li>HEAD—获取报文首部</li>
</ul>
<h3 id="GET与POST的区别"><a href="#GET与POST的区别" class="headerlink" title="GET与POST的区别"></a>GET与POST的区别</h3><p><strong>1.浏览器回退表现不同</strong> GET在浏览器回退时是无害的，而POST会再次提交请求<br><strong>2.浏览器对请求地址的处理不同</strong> GET请求地址会被浏览器主动缓存，而POST不会，除非手动设置<br><strong>3.浏览器对响应的处理不同</strong>GET请求参数会被完整的保留在浏览器历史记录里，而POST中的参数不会被保留（所以回退不同）<br><strong>4.参数大小不同.</strong> GET请求在URL中传送的参数是有长度的限制，而POST没有限制<br><strong>5.安全性不同.</strong> GET参数通过URL传递，会暴露，不安全；POST放在Request Body中，相对更安全<br><strong>6.针对数据操作的类型不同</strong>.GET对数据进行查询，POST主要对数据进行<code>增删改</code>！简单说，GET是只读，POST是写。</p>
<h3 id="HTTP报文的组成成分"><a href="#HTTP报文的组成成分" class="headerlink" title="HTTP报文的组成成分"></a>HTTP报文的组成成分</h3><ul>
<li>请求报文{ 请求行、请求头、空行、请求体 } </li>
<li>响应报文{ 状态行、响应头、空行、响应体 }</li>
<li>请求行{请求方式、请求资源路径、http协议版本}</li>
</ul>
<p>（post比get多了个form data（请求体），也可以没有这个请求体）</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="D:\Typeeasy\image-20231012162427806.png" alt="img"></p>
<p><strong>GET &#x2F;sample.com HTTP&#x2F;1.1</strong>  &#x2F;&#x2F;请求行</p>
<p>**Request Header:**请求头</p>
<ol>
<li><strong>Host:</strong>  <a target="_blank" rel="noopener" href="http://www.uuid.online/">www.uuid.online/</a> &#x2F;&#x2F;请求的目标<code>域名和端口号</code></li>
<li><strong>Origin:</strong> <a target="_blank" rel="noopener" href="http://localhost:8081/">http://localhost:8081/</a>  &#x2F;&#x2F;请求的来源域名和端口号 （跨域请求时，浏览器会自动带上这个头信息）</li>
<li><strong>Referer:</strong> <a target="_blank" rel="noopener" href="https://localhost:8081/link?query=xxxxx">https://localhost:8081/link?query=xxxxx</a> &#x2F;&#x2F;请求资源的完整URI</li>
<li><strong>User-Agent:</strong> Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;67.0.3396.99 Safari&#x2F;537.36 &#x2F;&#x2F;浏览器信息</li>
<li><strong>Cookie:</strong>  BAIDUID&#x3D;FA89F036:FG&#x3D;1; BD_HOME&#x3D;1; sugstore&#x3D;0  &#x2F;&#x2F;当前域名下的Cookie</li>
<li><strong>Accept:</strong> text&#x2F;html,image&#x2F;apng  &#x2F;&#x2F;代表客户端希望接受的数据类型是html或者是png图片类型 </li>
<li><strong>Accept-Encoding:</strong> gzip, deflate  &#x2F;&#x2F;代表客户端能支持gzip和deflate格式的压缩</li>
<li><strong>Accept-Language:</strong> zh-CN,zh;q&#x3D;0.9  &#x2F;&#x2F;代表客户端可以支持语言zh-CN或者zh(值得一提的是q(0~1)是优先级权重的意思，不写默认为1，这里zh-CN是1，zh是0.9)</li>
<li><strong>Connection:</strong> keep-alive  &#x2F;&#x2F;告诉服务器，客户端需要的tcp连接是一个长连接</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="D:\Typeeasy\image-20231012162404877.png" alt="img"></p>
<p>**Response Header:**响应头</p>
<ol>
<li><strong>HTTP&#x2F;1.1 200 OK</strong>  &#x2F;&#x2F; 响应状态行</li>
<li><strong>Date:</strong>  Mon, 30 Jul 2018 02:50:55 GMT  &#x2F;&#x2F;服务端发送资源时的服务器时间</li>
<li><strong>Expires:</strong>  Wed, 31 Dec 1969 23:59:59 GMT &#x2F;&#x2F;比较过时的一种验证缓存的方式，与浏览器（客户端）的时间比较，超过这个时间就不用缓存（不和服务器进行验证），适合版本比较稳定的网页</li>
<li><strong>Cache-Control:</strong>  no-cache  &#x2F;&#x2F; 现在最多使用的控制缓存的方式，会和服务器进行缓存验证，具体见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/amiezhang/p/9389537.html">博文”Cache-Control“</a></li>
<li><strong>etag:</strong>  “fb8ba2f80b1d324bb997cbe188f28187-ssl-df”  &#x2F;&#x2F; 一般是<a target="_blank" rel="noopener" href="http://www.t086.com/article/5207">Nginx静态服务器</a>发来的静态文件签名，浏览在没有“Disabled cache”情况下，接收到etag后，同一个url第二次请求就会自动带上“If-None-Match” （条件式请求首部）</li>
<li><strong>Last-Modified:</strong>  Fri, 27 Jul 2018 11:04:55 GMT &#x2F;&#x2F;是服务器发来的当前资源最后一次修改的时间，下次请求时，如果服务器上当前资源的修改时间比这个旧时间大，就返回新的资源内容</li>
<li><strong>Content-Type:</strong>  text&#x2F;html; charset&#x3D;utf-8  &#x2F;&#x2F;如果返回是流式的数据，我们就必须告诉浏览器这个头，不然浏览器会下载这个页面，同时告诉浏览器是utf8编码，否则可能出现乱码</li>
<li><strong>Content-Encoding:</strong>  gzip  &#x2F;&#x2F;告诉客户端，应该采用gzip对资源进行解码</li>
<li><strong>Connection:</strong>  keep-alive  &#x2F;&#x2F;告诉客户端服务器的tcp连接也是一个长连接</li>
</ol>
<h3 id="https-的基本概念"><a href="#https-的基本概念" class="headerlink" title="https 的基本概念"></a>https 的基本概念</h3><blockquote>
<p>是、组成、作用</p>
</blockquote>
<p>https:加密传输协议，是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。 http+ssl层&#x3D;https。</p>
<p>​	tls协议和ssl协议主要是如何建立安全连接</p>
<p>作用：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。</p>
<h3 id="http-和-https-的区别？"><a href="#http-和-https-的区别？" class="headerlink" title="http 和 https 的区别？"></a>http 和 https 的区别？</h3><blockquote>
<p>明文传输超文本，安全等级各不同。CA证书费用高，无状连接端难同。工作层与匿名也不同。</p>
</blockquote>
<ul>
<li>http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议，密文。</li>
<li>Https 协议需要 ca 证书，费用较高。 </li>
<li>使用不同的链接方式，端口也不同，一般，http 协议的端口为 80，https 的端口为 443。</li>
<li>http 的连接很简单，是无状态的（<em>无状态是指协议对于事务处理没有记忆能力,服务器不知道客户端是什么状态</em>）。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="D:\Typeeasy\image-20231012162337964.png"></p>
<p>​									 （应用层）     （应用层与传输层之间）</p>
<blockquote>
<p>HTTPS工作在传输层和应用层之间。在传输层，它使用TLS协议提供安全传输，而在应用层，它仍然使用HTTP协议来传递数据。</p>
</blockquote>
<h4 id="https-协议的工作原理"><a href="#https-协议的工作原理" class="headerlink" title="https 协议的工作原理"></a>https 协议的工作原理</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="D:\Typeeasy\image-20231012162450724.png" alt="image.png"></p>
<p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="D:\Typeeasy\image-20231012163833400.png" alt="image-20231012163833400"></p>
<ol>
<li>客户端使用 https url 访问服务器，则要求 web 服务器<code>建立 ssl 链接</code>。</li>
<li>web 服务器接收到客户端的请求之后，会<code>将网站的证书（CA证书中包含了公钥），传输给客户端</code>。</li>
<li>客户端和 web 服务器端开始<code>协商 SSL 链接的安全等级</code>，也就是加密等级。</li>
<li>客户端浏览器通过双方协商一致的安全等级，<code>建立会话密钥</code>，然后通过网站的公钥来加密会话密钥，并传送给网站。</li>
<li>web 服务器<code>通过自己的私钥解密出会话密钥</code>。</li>
<li>web 服务器<code>通过会话密钥加密与客户端之间的通信</code>。</li>
</ol>
<blockquote>
<p><strong>记忆口诀：一连二传三协商，四建五得六使用。</strong></p>
</blockquote>
<h4 id="https-协议的优缺点"><a href="#https-协议的优缺点" class="headerlink" title="https 协议的优缺点"></a>https 协议的优缺点</h4><ul>
<li>HTTPS 协议要比 http 协议<code>安全</code>，可防止数据在传输过程中被窃取、改变，确保数据的完整性。</li>
<li>https 握手阶段比较<code>费时</code>，会使页面加载时间延长 50%，增加 10%~20%的耗电。 </li>
<li>https <code>缓存</code>不如 http 高效，会增加数据开销。 </li>
<li>SSL 证书也需要钱，功能越强大的<code>证书费</code>用越高。 </li>
<li>SSL 证书需要绑定 <code>IP</code>，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。</li>
</ul>
<h3 id="TCP-x2F-IP网络模型"><a href="#TCP-x2F-IP网络模型" class="headerlink" title="TCP&#x2F;IP网络模型"></a>TCP&#x2F;IP网络模型</h3><p>TCP&#x2F;IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。</p>
<ul>
<li>链路层：负责封装和解封装IP报文，发送和接受ARP&#x2F;RARP报文等。</li>
<li>网络层：负责路由以及把分组报文发送给目标网络或主机。</li>
<li>传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。</li>
<li>应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="D:\Typeeasy\image-20231012164326559.png" alt="image.png"></p>
<p>先二进制传数据，再传输有地址的帧并检查看错没，根据地址来选择路由传输到指定地址，直到找到之后再借助端口与其它点建立联系，决定是否进行加密，联系好之后转换数据格式，将结果表现出来传输给用户。（其中刚好可以带入之前的知识）</p>
<h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="D:\Typeeasy\image-20231012164347247.png" alt="image.png"></p>
<ol>
<li>第一次握手：<code>建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认</code>；SYN：同步序列编号（Synchronize Sequence Numbers）。</li>
<li>第二次握手：<code>服务器收到syn包并确认客户的SYN</code>（ack&#x3D;j+1），<code>同时也发送一个自己的SYN包</code>（syn&#x3D;k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li>
<li>第三次握手：<code>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1）</code>，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。</span><br></pre></td></tr></table></figure>

<h3 id="TCP协议是怎么保证有效传输的？"><a href="#TCP协议是怎么保证有效传输的？" class="headerlink" title="TCP协议是怎么保证有效传输的？"></a>TCP协议是怎么保证有效传输的？</h3><p>  1、确认和重传 </p>
<p>  2、数据校验 </p>
<p>  3、流量控制 </p>
<p>  4、拥塞控制 </p>
<p><strong>可靠传输</strong>就是通过TCP连接传送的数据是没有差错、不会丢失、不重复并且按序到达的。（set）</p>
<p>TCP是通过序列号、检验和、确认应答信号、重发机制、连接管理、窗口控制、流量控制、拥塞控制一起保证TCP传输的可靠性的。</p>
<ul>
<li>首先通过三次握手建立连接 </li>
<li>建立连接的时候交换序列号 </li>
<li>发送方每次发送包的时候会带上序列号 </li>
<li>接收方收到包后检验数据是否正确，确认后发送确认的序列号给发送方 </li>
<li>发送方没有收到确认的序列号的包，就会重写发送</li>
</ul>
<p>可靠传输的具体实现是：</p>
<ul>
<li>应用层的数据会被分割成TCP认为最适合发送的数据块。 </li>
<li>序列号：TCP给发送的每一个包都进行编号，接收方对数据包进行排序，把有序数据传送给应用层，TCP的接收端会丢弃重复的数据。 </li>
<li>检验和：TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。 </li>
<li>确认应答：如果收到的数据报报文段的检验和没有差错，就确认收到，如果有差错，TCP就丢弃这个报文段和不确认收到此报文段。 </li>
<li>流量控制：TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。  </li>
<li>拥塞控制：当网络拥塞时，减少数据的发送。 </li>
<li>停止等待协议：它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。  </li>
<li>超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ul>
<h3 id="TCP（传输控制协议）是什么？"><a href="#TCP（传输控制协议）是什么？" class="headerlink" title="TCP（传输控制协议）是什么？"></a>TCP（传输控制协议）是什么？</h3><p>  <strong>标准回答</strong> </p>
<p>   TCP是传输控制协议，是TCP&#x2F;IP体系中非常复杂的一个协议，属于运输层协议。与UDP协议一样用于处理应用层的数据。它和UDP一样具有复用和分用的功能。TCP的主要特点是：面向连接、单播、可靠交付、全双工通讯、面向字节流、头部开销大。 </p>
<p>  <strong>加分回答</strong> </p>
<p>  TCP是传输控制协议，是TCP&#x2F;IP体系中非常复杂的一个协议，属于运输层协议。与UDP协议一样用于处理应用层的数据。它和UDP一样具有复用和分用的功能以及差错检测的功能。TCP的主要特点是： </p>
<ul>
<li>面向连接。应用程序在使用TCP之前必须两端之间先建立TCP连接。当确认数据传输完成之后，必须要释放TCP连接。    </li>
<li>单播。TCP只能有两个端点，进行点对点的传输，不支持多播和广播传输。    </li>
<li>可靠交付。通过TCP连接传送的数据是没有差错、不会丢失、不重复并且按序到达的。    </li>
<li>全双工通信。TCP允许连接的双方可以在任何时候发送数据，双方都有发送缓存和接收缓存。应用程序把数据给发送缓存之后就可以做其他的事情了，TCP发送缓存会在合适的时候自己把缓存中的数据发送出去。在接受的时候TCP会把数据存进接收缓存，上层应用程序会在合适的时候读取数据。也正因为是全双工通信方式，建立连接时最少需要三次信息确认，也就是三次握手，断开连接时最少需要四次信息确认，也就是所谓的四次挥手。    </li>
<li>面向字节流。TC不像UDP每一个数据报独立传输，而是在不保留报文边界的情况下以字节流的方式进行传输，这也是长连接的由来。TCP中的“流”就是指流入到进程或从进程流出的字节序列。    </li>
<li>头部开销大。最小20字节，最大60字节。加上TCP的可靠传输机制功能的影响，数据传输效率比UDP慢很多。</li>
</ul>
<h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><p>因为tcp的半关闭（后面有个链接）</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="D:\Typeeasy\image-20231016161842423.png" alt="image-20231016161842423"></p>
<ol>
<li><code>客户端进程发出连接释放报文</code>，并且停止发送数据。释放数据报文首部，FIN&#x3D;1，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li>
</ol>
<p>2）<code>服务器收到连接释放报文，发出确认报文</code>，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号seq&#x3D;v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p>
<p>3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。</p>
<p>4）<code>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文</code>，FIN&#x3D;1，ack&#x3D;u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq&#x3D;w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</p>
<p>5）<code>客户端收到服务器的连接释放报文后，必须发出确认</code>，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是seq&#x3D;u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</p>
<p>6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="D:\Typeeasy\image-20230526151812433.png" alt="image-20230526151812433" style="zoom:50%;" />

<h5 id="为什么要三次握手、四次挥手？"><a href="#为什么要三次握手、四次挥手？" class="headerlink" title="为什么要三次握手、四次挥手？"></a>为什么要三次握手、四次挥手？</h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhengpan/p/12160597.html">https://www.cnblogs.com/zhengpan/p/12160597.html</a></p>
<ul>
<li><p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误</p>
</li>
<li><p>三次握手才可以阻止重复历史连接初始化（主要原因）</p>
</li>
<li><p>三次握手才可以同步双方的初始序列号</p>
</li>
<li><p>三次握手才可以避免资源浪费</p>
</li>
<li><p>为了建立可靠的数据传输通道</p>
</li>
</ul>
<p><strong>四次挥手：</strong></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="D:\Typeeasy\image-20231016163005086.png" alt="image-20231016163005086"></p>
<p>保证等数据完成的被接收完再关闭连接。既然提到需要保证数据完整的传输完，那就需要<strong>保证双方都达到关闭连接的条件才能断开</strong>。</p>
<p>TCP是<strong>全双工模式</strong>，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。<br>服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，从而比三次握手导致多了一次</p>
<p><strong>TCP和UDP的区别</strong></p>
<p>首先UDP协议和TCP协议都是运输层协议，都是为应用层程序服务，都具有复用（不同的应用层协议可以共用UDP协议和TCP协议）和分用（将数据报解析之后分发给不同的应用层程序）的功能</p>
<ol>
<li><p>TCP是面向<code>连接</code>的，而UDP是面向无连接的。</p>
</li>
<li><p>TCP仅支持<code>单播传输</code>，UDP 提供了单播，多播，广播的功能。</p>
</li>
<li><p>TCP的三次握手保证了连接的<code>可靠性</code>; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。</p>
</li>
<li><p>UDP的<code>头部开销</code>比TCP的更小，数据<code>传输速率更高</code>，<code>实时性更好</code>。</p>
</li>
</ol>
<p>  1.TCP面向连接，UDP无连接 </p>
<p>  2.TCP可靠传输，UDP尽力交付 </p>
<p>  3.TCP采用<strong>全双工模</strong>式传输，UDP单工、半双工、全双工模式均可 </p>
<p>  4.TCP最小报文20字节，UDP最小报文8字节 </p>
<p>  5.TCP面向字节流，UDP面向报文 </p>
<p>  6.头部开销</p>
<p>  具体的区别详细描述可以是： </p>
<ul>
<li>​    UDP协议：面向无连接（不需要三次握手和四次挥手）、尽最大努力交付、面向报文（每次收发都是一整个报文段）、没有拥塞控制不可靠（只管发不管过程和结果）、支持一对一、一对多、多对一和多对多的通信方式、首部开销很小（8字节）。优点是快，没有TCP各种机制，少了很多首部信息和重复确认的过程，节省了大量的网络资源。缺点是不可靠不稳定，只管数据的发送不管过程和结果，网络不好的时候很容易造成数据丢失。又因为网络不好的时候不会影响到主机数据报的发送速率，这对很多实时的应用程序很重要，因为像语音通话、视频会议等要求源主机要以恒定的速率发送数据报，允许网络不好的时候丢失一些数据，但不允许太大的延迟，UDP很适合这种要求。    </li>
<li>​    TCP协议：是TCP&#x2F;IP体系中非常复杂的一个协议，面向连接（需要三次握手四次挥手）、单播（只能端对端的连接）、可靠交付（有大量的机制保护TCP连接数据的可靠性）、全双工通讯（允许双方同时发送信息，也是四次挥手的原由）、面向字节流（不保留数据报边界的情况下以字节流的方式进行传输，这也是长连接的由来。）、头部开销大（最少20字节）。优点是可靠、稳定，有确认、窗口、重传、拥塞控制机制，在数据传完之后，还会断开连接用来节约系统资源。缺点是慢，效率低，占用系统资源高，在传递数据之前要先建立连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接。在要求数据准确、对速度没有硬性要求的场景有很好的表现，比如在FTP（文件传输）、HTTP&#x2F;HTTPS（超文本传输），TCP很适合这种要求。</li>
</ul>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ol>
<li><p>跨域的原理</p>
<blockquote>
<p>阻止、不能、防</p>
</blockquote>
<p><strong>阻止一个域与另一个域的内容进行交互，能有效防止XSS、CSRF攻击</strong>，是指浏览器不能执行其他网站的脚本</p>
<p><strong>跨域</strong>，它是由浏览器的<code>同源策略</code>造成的。<br><strong>同源策略</strong>,是浏览器对 JavaScript 实施的安全限制，只要<code>协议、域名、端口</code>有任何一个不同，都被当作是不同的域(所有的XMLHttpRequest 和 Fetch API 请求都需要在同一个域下进行)。同一个服务器是同一个域<br>跨域原理，即是通过各种方式，<code>避开浏览器的安全限制</code>。</p>
</li>
<li><p>解决方案</p>
<p>最初做项目的时候，使用的是jsonp，但存在一些问题，使用get请求不安全，携带数据较小，后来也用过<em>iframe，但只有主域相同</em>才行，也是存在些问题，后来通过了解和学习发现使用代理和proxy代理配合起来使用比较方便，就引导后台按这种方式做下服务器配置，在开发中使用proxy，在服务器上使用nginx代理，这样开发过程中彼此都方便，效率也高；现在h5新特性还有 windows.postMessage()</p>
<ul>
<li><p><strong>JSONP</strong>：<br>ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是 返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。</p>
<p>步骤：</p>
<ol>
<li>去创建一个script标签</li>
<li>script的src属性设置接口地址</li>
<li>接口参数，必须要带一个自定义函数名，要不然后台无法返回数据</li>
<li>通过定义函数名去接受返回的数据</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSearch</span>(<span class="params"></span>) &#123;  </span><br><span class="line">   <span class="keyword">var</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;input&#x27;</span>);    <span class="keyword">var</span> inputVal = input.<span class="property">value</span>;  </span><br><span class="line">   <span class="keyword">var</span> url = <span class="string">&quot;https://suggest.taobao.com/sug?code=utf-8&amp;q=&quot;</span> + inputVal + <span class="string">&quot;&amp;callback=getJsonp&quot;</span>;    <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);    script.<span class="title function_">setAttribute</span>(<span class="string">&#x27;src&#x27;</span>, url);  </span><br><span class="line">   <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].<span class="title function_">appendChild</span>(script);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getJsonp</span>(<span class="params">data</span>) &#123;  </span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(data);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>JSONP 的缺点</strong>:<br>JSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。</p>
</li>
<li><p><strong>document.domain</strong>设置或返回当前文档的域名  基础域名相同 子域名不同</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">你的网站是 www.<span class="property">example</span>.<span class="property">com</span>，你可以将 <span class="variable language_">document</span>.<span class="property">domain</span> 设置为 example.<span class="property">com</span> 或者 www.<span class="property">example</span>.<span class="property">com</span>。这使得你可以在一个子域名（比如 subdomain.<span class="property">example</span>.<span class="property">com</span>）下进行跨域请求，即使这个子域名实际上是不同的二级域名。</span><br><span class="line"></span><br><span class="line">需要注意的是，你只能将 <span class="variable language_">document</span>.<span class="property">domain</span> 设置为你自己拥有控制权的域。如果你试图设置一个你无法控制的域，或者将 <span class="variable language_">document</span>.<span class="property">domain</span> 设置为一个更短的子域名（比如 .<span class="property">com</span>），那么浏览器将会抛出一个错误。</span><br><span class="line"><span class="keyword">var</span> d = <span class="variable language_">document</span>.<span class="property">domain</span>; <span class="comment">// 获取当前域名  </span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">domain</span> = d; <span class="comment">// 重新设置当前域名</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>window.name</strong> 利用在一个浏览器窗口内，载入所有的域名都是共享一个 window.name</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> windowName = <span class="string">&quot;myWindow&quot;</span>;  </span><br><span class="line"><span class="keyword">let</span> myWindow = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&quot;&quot;</span>, windowName);  </span><br><span class="line"><span class="comment">// 使用 myWindow 打开一个新的窗口  </span></span><br><span class="line">myWindow.<span class="property">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;p&gt;Hello World!&lt;/p&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">此外，<span class="variable language_">window</span>.<span class="property">name</span> 也可以被用来存储一些数据。例如：</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&quot;myData&quot;</span>;</span><br><span class="line">我们可以在其他地方通过 <span class="variable language_">window</span>.<span class="property">name</span> 来获取这个数据</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>CORS</strong> CORS(Cross-origin resource sharing)跨域资源共享 服务器设置对CORS的支持原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在CORS中，浏览器会在发起跨域请求时添加一个名为&quot;Origin&quot;的请求头，以标识原始的请求来源。服务器在接收到请求后，会检查&quot;Origin&quot;头，并根据其值来判断是否允许该请求访问资源。如果服务器允许该请求，它会返回一个包含&quot;Access-Control-Allow-Origin&quot;头的响应，并设置该头的值为原始请求的&quot;Origin&quot;头。这样，浏览器在接收到响应后就会知道该请求已经被允许访问资源。</span><br><span class="line"></span><br><span class="line">CORS只适用于简单的跨域请求，例如GET、POST、PUT和DELETE等请求方法。对于一些不安全的请求方法（如PUT和DELETE），浏览器会默认禁止跨域访问。此外，CORS也只适用于同源策略下的跨域请求，如果请求违反了同源策略，即使服务器返回了正确的CORS响应头，浏览器也会拒绝访问资源。</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>proxy代理</strong> 目前常用方式</li>
<li><strong>window.postMessage()</strong>  h5新特性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">允许在一个窗口（或标签页）中向另一个窗口传递信息。这种通信方式是跨源的，也就是说，两个窗口可以来自不同的域、协议或端口</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">postMessage</span>() 方法接受两个参数：</span><br><span class="line">    data：需要传递的数据，可以是一个对象、字符串或者一个序列化的 <span class="title class_">JSON</span> 对象。</span><br><span class="line">    targetOrigin：一个字符串，表示接收消息的目标窗口的源（<span class="variable constant_">URI</span>）。这个字符串可以包含一个简单的通配符（*），表示接受来自所有源的消息。</span><br><span class="line"><span class="comment">// 源窗口  </span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">postMessage</span>(&#123;  </span><br><span class="line">  <span class="attr">message</span>: <span class="string">&#x27;Hello World!&#x27;</span>,  </span><br><span class="line">  <span class="attr">someData</span>: <span class="string">&#x27;This is some data&#x27;</span>  </span><br><span class="line">&#125;, <span class="string">&#x27;*&#x27;</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 目标窗口  </span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">origin</span> !== <span class="string">&#x27;http://example.org:8080&#x27;</span>) <span class="keyword">return</span>;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>);  </span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Websocket</strong></li>
</ul>
<p>全双工通信协议，由HTML5定义，可以在单个TCP连接上进行全双工通信。这种通信方式使得服务器和客户端之间可以实现实时交流。WebSocket在完成一次握手后，浏览器和服务器就可以创建持久性的连接，并进行双向数据传输。在WebSocket中，可以使用ws或wss的统一资源标志，其中wss表示在TLS之上的WebSocket。</p>
<p><strong>提交表单有跨域问题吗</strong></p>
<p>不会。默认使用form表单提交是不会跨域的,因为使用form表单提交后<u>原来的页面无法得到响应的内容</u>,所以浏览器认为是安全的,但是使用ajax提交是可以得到响应内容的,所以浏览器不允许它跨域</p>
</li>
</ol>
<p><strong>预检</strong></p>
<p>但是还有复杂一点的请求，我们需要先发OPTIONS请求，a.com想请求b.com它需要发一个自定义的Headers：X-ABC和content-type，这个时候就不是简单请求了， a.com要给b.com 发一个options请求，它其实在问b.com我用post行不行，还想在Headers中带X-ABC和content-type；并不是所有的headers都发这个OPTIONS请求，因为X-ABC是自定义的，所以需要发；b.com看到OPTIONS请求，先不会返回数据，先检查自己的策略，看看能不能支持这次请求，如果支持就返回200。</p>
<p>OPTIONS请求返回以下报文</p>
<p>HTTP&#x2F;2.0 20 OK<br>Access-Control-Allow-Origin:<a target="_blank" rel="noopener" href="https://a.com/">https://a.com</a><br>Access-Control-Allow-Methods:POST,GET,OPTIONS<br>Access-Control-Allow-Headers:X-ABC,Content-Type<br>    Access-Control-Max-Age:86400 &#x2F;&#x2F; 告诉浏览器这个策略生效时间为一个小时，在一个小时之内发送类似的请求，不用在问服务端了，相当于缓存了<br>浏览器收到了OPTIONS的返回，会在发一次，这一次才是真正的请求数据，这次headers会带上X-ABC、contentType。</p>
<p>整体的过程cors将请求分为2种，简单请求和复杂请求，需不需要发送OPTIONS浏览器说的算，浏览器判断是简单请求还是复杂请求，cors是非常广泛的跨域手段 这里的缺点是OPTIONS请求也是一次请求，消耗带宽，真正的请求也会延迟。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- 最方便的跨域方案 **proxy代理+ Nginx**</span><br><span class="line">    nginx是一款极其强大的web服务器，其优点就是轻量级、启动快、高并发。</span><br><span class="line"></span><br><span class="line">    跨域问题的产生是因为浏览器的同源政策造成的，但是服务器与服务器之间的数据交换是没有这个限制。</span><br><span class="line"></span><br><span class="line">    反向代理就是采用这种方式，建立一个虚拟的代理服务器来接收 internet 上的链接请求，然后转发给内部网络上的服务器，并将从服务器上得到的结果，返回给 internet 上请求链接的客户端。现在的新项目中nginx几乎是首选，我们用node或者java开发的服务通常都需要经过nginx的反向代理。</span><br><span class="line"></span><br><span class="line">-   **window.postMessage()** 利用h5新特性window.postMessage()</span><br></pre></td></tr></table></figure>

<p>跨域传送门 ☞ <a target="_blank" rel="noopener" href="https://juejin.cn/post/7003232769182547998"># 跨域，不可不知的基础概念</a></p>
<h3 id="Cookie、sessionStorage、localStorage-的区别"><a href="#Cookie、sessionStorage、localStorage-的区别" class="headerlink" title="Cookie、sessionStorage、localStorage 的区别"></a>Cookie、sessionStorage、localStorage 的区别</h3><p><strong>相同点</strong>：</p>
<ul>
<li>存储在客户端</li>
</ul>
<p><strong>不同点</strong>：</p>
<ul>
<li>cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+</li>
<li>cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除</li>
<li>cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地</li>
</ul>
<h3 id="HTTP状态码及常见状态码"><a href="#HTTP状态码及常见状态码" class="headerlink" title="HTTP状态码及常见状态码"></a>HTTP状态码及常见状态码</h3><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><ul>
<li>1xx：指示信息类，表示请求已接受，继续处理</li>
<li>2xx：指示成功类，表示请求已成功接受</li>
<li>3xx：指示重定向，表示要完成请求必须进行更近一步的操作</li>
<li>4xx：指示客户端错误，请求有语法错误或请求无法实现</li>
<li>5xx：指示服务器错误，服务器未能实现合法的请求</li>
</ul>
<h4 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h4><ul>
<li><p>200 OK：客户端请求成功</p>
</li>
<li><p>301 Moved Permanently：所请求的页面已经永久重定向至新的URL</p>
</li>
<li><p>302 Found：所请求的页面已经临时重定向至新的URL</p>
</li>
<li><p>304 Not Modified 未修改。</p>
</li>
<li><p>403 Forbidden：对请求页面的访问被禁止</p>
</li>
<li><p>404 Not Found：请求资源不存在</p>
</li>
<li><p>500 Internal Server Error：服务器发生不可预期的错误原来缓冲的文档还可以继续使用</p>
</li>
<li><p>503 Server Unavailable：请求未完成，服务器临时过载或宕机，一段时间后可恢复正常</p>
</li>
<li><p>1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码</p>
<ul>
<li>100 - 继续 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分</li>
<li>101 - 切换协议 请求者已要求服务器切换协议，服务器已确认并准备切换</li>
</ul>
</li>
<li><p>2xx（成功）表示成功处理了请求的状态码</p>
<ul>
<li><code>200</code> - 成功 服务器已经成功处理了请求。通常，这表示服务器提供了请求的网页</li>
<li>201 - 已创建 请求成功并且服务器创建了新的资源</li>
<li>202 - 已接受 服务器已接受请求，但尚未处理</li>
<li>203 - 非授权信息 服务器已经成功处理了请求，但返回的信息可能来自另一来源</li>
<li>204 - 无内容 服务器成功处理了请求，但没有返回任何内容</li>
<li>205 - 重置内容 服务器成功处理了请求，但没有返回任何内容</li>
</ul>
</li>
<li><p>3xx（重定向）表示要完成请求，需要进一步操作；通常，这些状态代码用来重定向</p>
<ul>
<li>300 - 多种选择 针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择</li>
<li><code>301</code> - 永久移动 请求的网页已永久移动到新位置。服务器返回此响应（对GET或HEAD请求的响应）时，会自动将请求者转到新位置</li>
<li><code>302</code> - 临时移动 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li>
<li>303 - 查看其它位置 请求者应当对不同的位置使用单独的GET请求来检索响应时，服务器返回此代码</li>
<li><code>304</code> - 未修改 自上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页的内容</li>
<li>305 - 使用代理 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理</li>
<li><code>307</code> - 临时性重定向 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有的位置来进行以后的请求</li>
</ul>
</li>
<li><p>4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理</p>
<ul>
<li><code>400</code> - 错误请求 服务器不理解请求的语法</li>
<li><code>401</code> - 未授权 请求要求身份验证。对于需要登录的网页，服务器可能返回此响应</li>
<li><code>403</code> - 禁止 服务器拒绝请求</li>
<li><code>404</code> - 未找到 服务器找不到请求的网页</li>
<li>405 - 方法禁用 禁用请求中指定的方法</li>
<li>406 - 不接受 无法使用请求的内容特性响应请求的网页</li>
<li><code>407</code> - 需要代理授权 此状态码与401（未授权）类似，但指定请求者应当授权使用代理</li>
<li><code>408</code> - 请求超时 服务器等候请求时发生超时</li>
<li>410 - 已删除 如果请求的资源已永久删除，服务器就会返回此响应</li>
<li><code>413</code> - 请求实体过大 服务器无法处理请求，因为请求实体过大，超出了服务器的处理能力</li>
<li><code>414</code> - 请求的URI过长 请求的URI（通常为网址）过长，服务器无法处理</li>
</ul>
</li>
<li><p>5xx（服务器错误）这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错</p>
<ul>
<li><code>500</code> - 服务器内部错误 服务器遇到错误，无法完成请求</li>
<li>501 - 尚未实施 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码</li>
<li><code>502</code> - 错误网关 服务器作为网关或代理，从上游服务器无法收到无效响应</li>
<li><code>503</code> - 服务器不可用 服务器目前无法使用（由于超载或者停机维护）。通常，这只是暂时状态</li>
<li><code>504</code> - 网关超时 服务器作为网关代理，但是没有及时从上游服务器收到请求</li>
<li>505 - HTTP版本不受支持 服务器不支持请求中所用的HTTP协议版本</li>
</ul>
</li>
</ul>
<h3 id="粘包问题分析与对策"><a href="#粘包问题分析与对策" class="headerlink" title="粘包问题分析与对策"></a>粘包问题分析与对策</h3><p>TCP粘包是指：发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p>
<p><strong>粘包出现原因</strong></p>
<p>简单说，在流传输中出现，UDP不会出现粘包，因为它有<strong>消息边界</strong></p>
<blockquote>
<p>消息边界（message boundary）是一个特定的分隔符，用于标识消息的结束和下一次消息的开始。这个分隔符可以是任意的字符串，通常是一对反斜杠带着换行符和回车符（\n\r）。消息边界主要用于标识由多个部分组成的连续消息。</p>
</blockquote>
<p>粘包情况有两种，一种是<code>粘在一起的包都是完整的数据包</code>，另一种情况是<code>粘在一起的包有不完整的包</code>。</p>
<p>为了<strong>避免粘包</strong>现象，可采取以下几种措施：</p>
<p>（1）对于发送方引起的粘包现象，用户可通过编程设置来避免，<code>TCP提供了强制数据立即传送的操作指令push</code>，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；</p>
<p>（2）对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、<code>提高接收进程优先级等措施</code>，使其及时接收数据，从而尽量避免出现粘包现象；</p>
<p>（3）由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。<code>分包多发</code>。</p>
<p>以上提到的三种措施，都有其不足之处。</p>
<p>（1）第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。</p>
<p>（2）第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。</p>
<p>（3）第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。</p>
<blockquote>
<p>一种比较周全的对策是：接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开。实验证明这种方法是高效可行的。</p>
</blockquote>
<h3 id="客户端与服务端长连接方式"><a href="#客户端与服务端长连接方式" class="headerlink" title="客户端与服务端长连接方式"></a>客户端与服务端长连接方式</h3><ol>
<li><p><strong>ajax 轮询</strong><br><strong>实现原理</strong>：ajax 轮询指客户端每间隔一段时间向服务端发起请求，保持数据的同步。</p>
<p><strong>优点</strong>：可实现基础（指间隔时间较短）的数据更新。</p>
<p><strong>缺点</strong>：这种方法也只是尽量的模拟即时传输，但并非真正意义上的即时通讯，很有可能出现客户端请求时，服务端数据并未更新。或者服务端数据已更新，但客户端未发起请求。导致多次请求资源浪费，效率低下。【<code>数据更新不及时，效率低下</code>】</p>
</li>
<li><p><strong>long poll 长轮询</strong></p>
<p><strong>实现原理</strong>：<br>long poll 指的是客户端发送请求之后，如果没有数据返回，服务端会将请求挂起放入队列（不断开连接）处理其他请求，直到有数据返回给客户端。然后客户端再次发起请求，以此轮询。在 HTTP1.0 中客户端可以设置请求头 Connection:keep-alive，服务端收到该请求头之后知道这是一个长连接，在响应报文头中也添加 Connection:keep-alive。客户端收到之后表示长连接建立完成，可以继续发送其他的请求。在 HTTP1.1 中默认使用了 Connection:keep-alive 长连接。</p>
<p><strong>优点</strong>：减少客户端的请求，降低无效的网络传输，保证每次请求都有数据返回，不会一直占用线程。</p>
<p><strong>缺点</strong>：无法处理高并发，当客户端请求量大，请求频繁时对服务器的处理能力要求较高。服务器一直保持连接会消耗资源，需要同时维护多个线程，服务器所能承载的 TCP 连接数是有上限的，这种轮询很容易把连接数顶满。每次通讯都需要客户端发起，服务端不能主动推送。【<code>无法处理高并发，消耗服务器资源严重，服务端不能主动推送</code>】</p>
</li>
<li><p><strong>iframe 长连接</strong></p>
<p><strong>实现原理：</strong><br>在网页上嵌入一个 iframe 标签，该标签的 src 属性指向一个长连接请求。这样服务端就可以源源不断地给客户端传输信息。保障信息实时更新。</p>
<p><strong>优点</strong>：消息及时传输。</p>
<p><strong>缺点</strong>：<code>消耗服务器资源</code>。</p>
</li>
<li><p><strong>WebSocket</strong></p>
<p><strong>实现原理</strong>：<br>Websocket 实现了客户端与服务端的双向通信，只需要连接一次，就可以相互传输数据，很适合实时通讯、数据实时更新等场景。</p>
<p>Websocket 协议与 HTTP 协议没有关系，它是一个建立在 TCP 协议上的全新协议，为了兼容 HTTP 握手规范，在<u>握手阶段依然使用 HTTP 协议</u>，握手完成之后，数据通过 <u>TCP</u> 通道进行传输。</p>
<p>Websoket 数据传输是通过 frame 形式，一个消息可以分成几个片段传输。这样大数据可以分成一些小片段进行传输，不用考虑由于数据量大导致标志位不够的情况。也可以边生成数据边传递消息，提高传输效率。</p>
<p><strong>优点</strong>：<br>双向通信。客户端和服务端双方都可以主动发起通讯。<br>没有同源限制。客户端可以与任意服务端通信，不存在跨域问题。<br>数据量轻。第一次连接时需要携带请求头，后面数据通信都不需要带请求头，减少了请求头的负荷。<br>传输效率高。因为只需要一次连接，所以数据传输效率高。</p>
<p><strong>缺点</strong>：<br>长连接需要后端处理业务的代码更稳定，推送消息相对复杂；<br>长连接受网络限制比较大，需要处理好重连。<br>兼容性，WebSocket 只支持 IE10 及其以上版本。<br>服务器长期维护长连接需要一定的成本，各个浏览器支持程度不一；<br>成熟的 HTTP 生态下有大量的组件可以复用，WebSocket 则没有，遇到异常问题难以快速定位快速解决。【需要后端代码稳定，受网络限制大，兼容性差，维护成本高，生态圈小】</p>
</li>
</ol>
<h3 id="非对称加密RSA"><a href="#非对称加密RSA" class="headerlink" title="非对称加密RSA"></a>非对称加密RSA</h3><ol>
<li>对称加密算法又称现代加密算法。 </li>
<li>非对称加密是计算机通信安全的基石，保证了加密数据不会被破解。 </li>
<li>非对称加密算法需要两个密钥：公开密钥(publickey) 和私有密(privatekey) </li>
<li>公开密钥和私有密钥是一对</li>
</ol>
<p>如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密。 <br>如果用私有密钥对数据进行加密，只有用对应的公开密钥才能解密。</p>
<p><strong>特点：</strong> </p>
<p>安全性: 算法强度复杂，安全性依赖于算法与密钥。 </p>
<p>效率: 加密解密速度慢。</p>
<p>非对称性：公钥和私钥是一对，使用公钥加密的数据只能使用私钥解密，使用私钥加密的数据只能使用公钥解密。</p>
<p><strong>与对称加密算法的对比：</strong> <br>对称加密只有一种密钥，并且是非公开的，如果要解密就得让对方知道密钥。 <br>非对称加密有两种密钥，其中一个是公开的。</p>
<p><strong>RSA应用场景：</strong> <br>由于RSA算法的加密解密速度要比对称算法速度慢很多，在实际应用中，数据本身的加密和解密使用对称加密算法(AES)。 用RSA算法加密并传输对称算法所需的密钥。</p>
<h3 id="HTTP1、HTTP2、HTTP3"><a href="#HTTP1、HTTP2、HTTP3" class="headerlink" title="HTTP1、HTTP2、HTTP3"></a>HTTP1、HTTP2、HTTP3</h3><p>HTTP&#x2F;2 相比于 HTTP&#x2F;1.1，可以说是大幅度提高了网页的性能，只需要升级到该协议就可以减少很多之前需要做的性能优化工作，虽如此但HTTP&#x2F;2并非完美的，HTTP&#x2F;3 就是为了解决 HTTP&#x2F;2 所存在的一些问题而被推出来的。</p>
<h3 id="HTTP1-1-的缺陷"><a href="#HTTP1-1-的缺陷" class="headerlink" title="HTTP1.1 的缺陷"></a><strong>HTTP1.1 的缺陷</strong></h3><blockquote>
<p><strong>记忆口诀：队头阻塞高延迟，无状态阻交互，明文传输不安全，服务推送不支持。</strong></p>
</blockquote>
<ol>
<li><p>高延迟 — 队头阻塞(Head-Of-Line Blocking)</p>
<p><code>队头阻塞</code>是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。</p>
<p>针对队头阻塞的解决办法:</p>
<ul>
<li><code>将同一页面的资源分散到不同域名下，提升连接上限</code>。 </li>
<li><code>合并小文件减少资源数</code>，使用精灵图。</li>
<li><code>内联(Inlining)资源</code>是另外一种防止发送很多小图请求的技巧，将图片的原始数据嵌入在CSS文件里面的URL里，减少网络请求次数。</li>
<li><code>减少请求数量</code>，合并文件。</li>
</ul>
</li>
<li><p>无状态特性 — 阻碍交互</p>
<p><code>无状态是指协议对于连接状态没有记忆能力</code>。纯净的 HTTP 是没有 cookie 等机制的，每一个连接都是一个新的连接。</p>
<p><code>Header里携带的内容过大，在一定程度上增加了传输的成本</code>。且请求响应报文里有大量字段值都是重复的。</p>
</li>
<li><p>明文传输 — 不安全性</p>
<p>HTTP&#x2F;1.1在传输数据时，所有<code>传输的内容都是明文</code>，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性。</p>
</li>
<li><p>不支持服务端推送</p>
</li>
</ol>
<p><strong>HTTP 1.1 排队问题</strong></p>
<p>HTTP 1.1多个文件共用一个TCP，这样可以减少tcp握手，这样3个文件就不用握手9次了，不过这样请求文件需要排队，请求和返回都需要排队， 如果第一个文件响应慢，会阻塞后面的文件，这样就产生了对头的等待问题。</p>
<p>有的网站可能会有很多文件，浏览器处于对机器性能的考虑，它不可能让你无限制的发请求建连接，因为建立连接需要占用资源，浏览器不想把用户的网络资源都占用了，所以浏览器最多会建立6个tcp连接；如果有上百个文件 可能都需要排队，http2.0正在解决这个问题。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="D:\Typeeasy\8ecdc60670194df7957ee59e1f56701ftplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h3 id="SPDY-协议与-HTTP-x2F-2-简介"><a href="#SPDY-协议与-HTTP-x2F-2-简介" class="headerlink" title="SPDY 协议与 HTTP&#x2F;2 简介"></a>SPDY 协议与 HTTP&#x2F;2 简介</h3><h4 id="1、HTTP-x2F-2-简介"><a href="#1、HTTP-x2F-2-简介" class="headerlink" title="1、HTTP&#x2F;2 简介"></a>1、HTTP&#x2F;2 简介</h4><p>HTTP&#x2F;2是现行HTTP协议（HTTP&#x2F;1.x）的替代，但它不是重写。<strong>HTTP&#x2F;2基于SPDY(提高网页加载速度和可靠性的网络协议)，专注于性能，最大的一个目标是在用户和网站间只用一个连接（connection）</strong> 。</p>
<h4 id="2、HTTP-x2F-2-新特性"><a href="#2、HTTP-x2F-2-新特性" class="headerlink" title="2、HTTP&#x2F;2 新特性"></a>2、HTTP&#x2F;2 新特性</h4><h4 id="1、二进制传输"><a href="#1、二进制传输" class="headerlink" title="1、二进制传输"></a>1、二进制传输</h4><p><code>HTTP/2传输数据量的大幅减少,主要有两个原因:以二进制方式传输和Header 压缩</code>。我们先来介绍二进制传输,HTTP&#x2F;2 采用二进制格式传输数据，而非HTTP&#x2F;1.x 里纯文本形式的报文 ，二进制协议解析起来更高效。<code>HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码</code>。</p>
<h4 id="2、Header-压缩"><a href="#2、Header-压缩" class="headerlink" title="2、Header 压缩"></a>2、Header 压缩</h4><p>HTTP&#x2F;2并没有使用传统的压缩算法，而是开发了专门的”HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。</p>
<h4 id="3、多路复用"><a href="#3、多路复用" class="headerlink" title="3、多路复用"></a>3、多路复用</h4><p>在 HTTP&#x2F;2 中引入了多路复用(允许多个数据流共享一个单一的物理通道)的技术。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也更容易实现全速传输。</p>
<blockquote>
<p>多路复用技术被用于在一个TCP连接中同时处理多个请求和响应，从而减少了建立和关闭TCP连接的开销，并提高了网络利用率。</p>
<p>在SPDY中，每个流（Stream）都是一个双向的数据通道，可以在任何时候发送数据。这些流共享同一个TCP连接，但每个流都有自己的标识符和优先级。通过这种方式，SPDY可以在一个TCP连接中同时处理多个请求和响应，从而减少了延迟并提高了带宽利用率。</p>
</blockquote>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="D:\Typeeasy\f756ad3403bc4fe18e970c56677c796etplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h4 id="4、Server-Push"><a href="#4、Server-Push" class="headerlink" title="4、Server Push"></a>4、Server Push</h4><p>HTTP2还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。减少等待的延迟，这被称为”<code>服务器推送</code>“（ Server Push，也叫 Cache push）</p>
<h4 id="5、提高安全性"><a href="#5、提高安全性" class="headerlink" title="5、提高安全性"></a>5、提高安全性</h4><p>出于兼容的考虑，HTTP&#x2F;2延续了HTTP&#x2F;1的“明文”特点，可以像以前一样使用明文传输数据，不强制使用加密通信，不过格式还是二进制，只是不需要解密。</p>
<p>但由于HTTPS已经是大势所趋，而且主流的浏览器Chrome、Firefox等都公开宣布只支持加密的HTTP&#x2F;2，<strong>所以“事实上”的HTTP&#x2F;2是加密的</strong>。也就是说，互联网上通常所能见到的HTTP&#x2F;2都是使用”https”协议名，跑在TLS上面。HTTP&#x2F;2协议定义了两个字符串标识符：“h2”表示加密的HTTP&#x2F;2，“h2c”表示明文的HTTP&#x2F;2。</p>
<h4 id="6、防止对头阻塞"><a href="#6、防止对头阻塞" class="headerlink" title="6、防止对头阻塞"></a>6、防止对头阻塞</h4><p>http1.1如果第一个文件阻塞，第二个文件也就阻塞了。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="D:\Typeeasy\b67bd1f793a3425d9e8a415cae9b7863tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>http2.0的解决，把3个请求打包成一个小块发送过去，即使第一个阻塞了，后面2个也可以回来；相当于3个文件同时请求，就看谁先回来谁后回来，阻塞的可能就后回来，对带宽的利用是最高的；但没有解决TCP的对头阻塞，如果TCP发过去的一个分包发丢了，他会重新发一次；http2.0的解决了大文件的阻塞。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="D:\Typeeasy\77d8ae8e0de44f3aa693f0626a346d4ctplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>一个分包请求3个文件，即使第一个阻塞了，第二个也能返回</p>
<h3 id="HTTP-x2F-2-的缺点"><a href="#HTTP-x2F-2-的缺点" class="headerlink" title="HTTP&#x2F;2 的缺点"></a>HTTP&#x2F;2 的缺点</h3><p>虽然 HTTP&#x2F;2 解决了很多之前旧版本的问题，但它还是存在一个巨大的问题，<strong>主要是底层支撑的 TCP 协议造成的</strong>。HTTP&#x2F;2的缺点主要有以下几点：</p>
<ol>
<li>TCP 以及 TCP+TLS 建立连接时延时<code>(发送端发送连接请求到接收端回复连接确认的时间间隔。这个时间间隔被称为RTT（Round Trip Time，往返时间），反映了网络连接的性能,(三次握手建立连接))</code></li>
<li>TCP 的队头阻塞并没有彻底解决</li>
<li>多路复用导致服务器压力上升也容易 Timeout</li>
</ol>
<h3 id="HTTP-x2F-3-新特性"><a href="#HTTP-x2F-3-新特性" class="headerlink" title="HTTP&#x2F;3 新特性"></a>HTTP&#x2F;3 新特性</h3><h4 id="1、HTTP-x2F-3简介"><a href="#1、HTTP-x2F-3简介" class="headerlink" title="1、HTTP&#x2F;3简介"></a>1、HTTP&#x2F;3简介</h4><p>Google 在推SPDY的时候就搞了个基于 UDP 协议的“QUIC”协议，让HTTP跑在QUIC上而不是TCP上。而“HTTP over QUIC”就是HTTP&#x2F;3，真正“完美”地解决了“队头阻塞”问题。</p>
<p>QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，接下来我们重点介绍几个QUIC新功能。</p>
<h4 id="2、QUIC新功能"><a href="#2、QUIC新功能" class="headerlink" title="2、QUIC新功能"></a>2、QUIC新功能</h4><p>QUIC基于UDP，而UDP是“无连接”的，根本就不需要“握手”和“挥手”，所以就比TCP来得快。此外QUIC也实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似HTTP&#x2F;2的“流”和“多路复用”，单个“流”是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。具体来说QUIC协议有以下特点：</p>
<ul>
<li><p><strong>实现了类似TCP的流量控制、传输可靠性的功能</strong></p>
<p>虽然UDP不提供可靠性的传输，但QUIC在UDP的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性。</p>
</li>
<li><p><strong>实现了快速握手功能</strong></p>
<p>由于QUIC是基于UDP的，所以QUIC可以实现使用0-RTT或者1-RTT来建立连接，这意味着QUIC可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。<strong>0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势</strong>。</p>
</li>
<li><p><strong>集成了TLS加密功能</strong></p>
</li>
<li><p><strong>多路复用，彻底解决TCP中队头阻塞的问题</strong></p>
<p>和TCP不同，QUIC实现了在同一物理连接上可以有多个独立的逻辑数据流。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题。</p>
</li>
<li><p><strong>连接迁移</strong></p>
<p>TCP 是按照 4 要素（客户端 IP、端口, 服务器 IP、端口）确定一个连接的。而 QUIC 则是让客户端生成一个 Connection ID （64 位）来区别不同连接。只要 Connection ID 不变，连接就不需要重新建立，即便是客户端的网络发生变化。由于迁移客户端继续使用相同的会话密钥来加密和解密数据包，QUIC 还提供了迁移客户端的自动加密验证。</p>
</li>
</ul>
<h3 id="http总结"><a href="#http总结" class="headerlink" title="http总结"></a>http总结</h3><ul>
<li>HTTP&#x2F;1.1有两个主要的缺点：安全不足和性能不高。</li>
<li>HTTP&#x2F;2完全兼容HTTP&#x2F;1，是“更安全的HTTP、更快的HTTPS”，二进制传输、头部压缩、多路复用、服务器推送等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验；</li>
<li>QUIC 基于 UDP 实现，是 HTTP&#x2F;3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议。</li>
</ul>
<h3 id="利用Socket建立网络连接的步骤"><a href="#利用Socket建立网络连接的步骤" class="headerlink" title="利用Socket建立网络连接的步骤"></a>利用Socket建立网络连接的步骤</h3><p>建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。</p>
<p>套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="D:\Typeeasy\image-20231022210218706.png" alt="image-20231022210218706"></p>
<p>　　1、服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。</p>
<p>　　2、客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。</p>
<p>　　为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。</p>
<p>　　3、连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。</p>
<p>而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</p>
<h3 id="理解xss，csrf，ddos攻击原理以及避免方式"><a href="#理解xss，csrf，ddos攻击原理以及避免方式" class="headerlink" title="理解xss，csrf，ddos攻击原理以及避免方式"></a>理解xss，csrf，ddos攻击原理以及避免方式</h3><p><code>XSS</code>(<code>Cross-Site Scripting</code>，<strong>跨站脚本攻击</strong>)是一种代码注入攻击。攻击者在目标网站上<strong>注入恶意代码</strong>，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 <code>cookie，session tokens</code>，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。</p>
<blockquote>
<p>钓鱼欺诈是一种网络欺诈行为，通过伪造合法的Web站点来诱骗用户提供私人信息，如登录名、密码、信用卡号等。这些欺诈行为通常通过电子邮件或即时通讯工具发送具有欺诈性质的链接，诱骗用户点击并输入敏感信息。</p>
<p>蠕虫攻击是一种利用漏洞或弱点进行自我复制和传播的恶意软件，类似于生物学中的蠕虫。蠕虫攻击通常利用电子邮件或网络漏洞进行传播，它们可以自我复制并发送到其他计算机，从而占用网络资源和计算机资源，导致系统崩溃或数据损失。</p>
</blockquote>
<p><strong>XSS避免方式：</strong></p>
<ol>
<li><code>url</code>参数使用<code>encodeURIComponent</code>方法转义</li>
<li>尽量不使用<code>InnerHtml</code>插入<code>HTML</code>内容</li>
<li>使用特殊符号、标签转义符。</li>
</ol>
<p><code>CSRF</code>（<code>Cross-site request forgery</code>）<strong>跨站请求伪造</strong>：攻击者<strong>诱导受害者进入第三方网站</strong>，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p>
<p><strong><code>CSRF</code>避免方式：</strong></p>
<ol>
<li><p>添加验证码</p>
</li>
<li><p>使用token</p>
<ul>
<li>服务端给用户生成一个token，加密后传递给用户</li>
<li>用户在提交请求时，需要携带这个token</li>
<li>服务端验证token是否正确</li>
</ul>
</li>
</ol>
<p><code>DDoS</code>又叫<strong>分布式拒绝服务</strong>，全称 <code>Distributed Denial of Service</code>，其原理就是利用<strong>大量请求造成资源过载</strong>，导致服务不可用。</p>
<p><strong><code>DDos</code>避免方式：</strong></p>
<ol>
<li>限制单IP请求频率。</li>
<li>防火墙等防护设置禁止<code>ICMP</code>包等</li>
<li>检查特权端口的开放</li>
</ol>
<blockquote>
<p><code>ICMP</code>包:（Internet控制消息协议）,用于在IP主机、路由器之间传递控制消息</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzkzNzI0MDMxNQ==&mid=2247487116&idx=1&sn=09187eeb7e45faa1bee86ff48ae14be1&source=41#wechat_redirect">360技术：嗨，送你一张Web性能优化地图</a></p>
<h3 id="websocket和http"><a href="#websocket和http" class="headerlink" title="websocket和http"></a>websocket和http</h3><p><strong>1、含义不同</strong></p>
<p><strong>websocket</strong>：WebSocket是一种在单个TCP连接上进行<strong>全双工</strong>通信的协议。(全双工: 允许设备同时在两个方向上发送和接收数据，即同时进行上传和下载)</p>
<p><strong>http</strong>：超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上，是<strong>单向的通信协议</strong>。</p>
<p><strong>2、连接方式不同</strong></p>
<p><strong>websocket</strong>：WebSocket是需要浏览器和服务器<strong>握手</strong>进行建立连接的。</p>
<p><strong>http</strong>：http是浏览器发起向服务器的连接，服务器<strong>预先并不知道</strong>这个连接。</p>
<p><strong>3、连接长度不同</strong></p>
<p><strong>websocket</strong>：websocket是<strong>持久连接</strong>。</p>
<p><strong>http</strong>：http 是<strong>短连接</strong>(http可以通过Ajax一直发送请求和长轮询保持一段时间内的连接，但本质上还是短连接)。</p>
<p><strong>4、连接状态不同</strong></p>
<p><strong>websocket</strong>：websocket是<strong>有状态</strong>的双向连接。</p>
<p><strong>http</strong>：http 是<strong>无状态</strong>的单向连接。</p>
<p><strong>5、协议开头不同</strong></p>
<p><strong>websocket</strong>：websocket的协议是以 ws&#x2F;wss 开头。</p>
<p><strong>http</strong>：http 对应的是 http&#x2F;https。</p>
<p><strong>websocket和http的联系</strong></p>
<ul>
<li>都是基于TCP协议；</li>
<li>websocket是基于http的(但要握一次手),他们的兼容性都很好；</li>
<li>在连接的建立过程中对错误的处理方式相同；</li>
<li>都使用 Request&#x2F;Response（请求-应答）模型进行连接的建立；</li>
<li>都可以在网络中传输数据。</li>
</ul>
<h3 id="CDN-内容分发网络"><a href="#CDN-内容分发网络" class="headerlink" title="CDN-内容分发网络"></a>CDN-内容分发网络</h3><p>在用户访问相对集中的地区和网络设置一些<strong>缓存服务器</strong>。当用户访问网站时，利用全局的负载均衡技术将用户的访问指向距离最近的缓存服务器，由<strong>缓存服务器代替源站响应用户的访问请求</strong>。</p>
<p><strong>实现步骤:</strong></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="D:\Typeeasy\image-20231022213256211.png" alt="image-20231022213256211"></p>
<p>1、用户向浏览器提供要访问网站的域名，域名解析的请求被发往本地用户使用的DNS服务器，本地DNS服务器将解析请求转发至网站的DNS服务器(NS)；</p>
<p>2、由于网站的DNS服务器(NS)对此域名的解析设置了CNAME，请求最终被指向到CDN网络中的GLB系统;</p>
<p>3、GLB系统对域名进行智能解析，将响应速度最快的节点IP返回给用户;</p>
<p>4、浏览器在得到实际的IP地址以后，向CDN节点发出访问请求;</p>
<p>5、由于是第一次访问，CDN节点将回到源站获得用户请求的数据并发给用户，同时CDN节点根据缓存策略对该数据进行缓存;</p>
<p>6、当有其他用户再次访问同样内容时，CDN节点直接将数据返回给客户，完成请求&#x2F;服务过程。</p>

<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/undefined/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/undefined/vue/">vue</a></div></section></div>






<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">abulili</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.29.1">Stellar 1.29.1</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">HTTP 的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">HTTP工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82-x2F-%E5%93%8D%E5%BA%94%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-text">HTTP请求&#x2F;响应的步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E7%9A%84-5-%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">HTTP 的 5 种方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET%E4%B8%8EPOST%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">GET与POST的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E6%8A%A5%E6%96%87%E7%9A%84%E7%BB%84%E6%88%90%E6%88%90%E5%88%86"><span class="toc-text">HTTP报文的组成成分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#https-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">https 的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http-%E5%92%8C-https-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">http 和 https 的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#https-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">https 协议的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#https-%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">https 协议的优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-x2F-IP%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-text">TCP&#x2F;IP网络模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">TCP三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%8D%8F%E8%AE%AE%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%9C%89%E6%95%88%E4%BC%A0%E8%BE%93%E7%9A%84%EF%BC%9F"><span class="toc-text">TCP协议是怎么保证有效传输的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%EF%BC%88%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">TCP（传输控制协议）是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">TCP 四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="toc-text">为什么要三次握手、四次挥手？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F"><span class="toc-text">跨域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie%E3%80%81sessionStorage%E3%80%81localStorage-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Cookie、sessionStorage、localStorage 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">HTTP状态码及常见状态码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">HTTP状态码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">常见状态码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E5%AF%B9%E7%AD%96"><span class="toc-text">粘包问题分析与对策</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%95%BF%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="toc-text">客户端与服务端长连接方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86RSA"><span class="toc-text">非对称加密RSA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP1%E3%80%81HTTP2%E3%80%81HTTP3"><span class="toc-text">HTTP1、HTTP2、HTTP3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP1-1-%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-text">HTTP1.1 的缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPDY-%E5%8D%8F%E8%AE%AE%E4%B8%8E-HTTP-x2F-2-%E7%AE%80%E4%BB%8B"><span class="toc-text">SPDY 协议与 HTTP&#x2F;2 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81HTTP-x2F-2-%E7%AE%80%E4%BB%8B"><span class="toc-text">1、HTTP&#x2F;2 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81HTTP-x2F-2-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">2、HTTP&#x2F;2 新特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%A0%E8%BE%93"><span class="toc-text">1、二进制传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Header-%E5%8E%8B%E7%BC%A9"><span class="toc-text">2、Header 压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">3、多路复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81Server-Push"><span class="toc-text">4、Server Push</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E6%8F%90%E9%AB%98%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">5、提高安全性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E9%98%B2%E6%AD%A2%E5%AF%B9%E5%A4%B4%E9%98%BB%E5%A1%9E"><span class="toc-text">6、防止对头阻塞</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-x2F-2-%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">HTTP&#x2F;2 的缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-x2F-3-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">HTTP&#x2F;3 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81HTTP-x2F-3%E7%AE%80%E4%BB%8B"><span class="toc-text">1、HTTP&#x2F;3简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81QUIC%E6%96%B0%E5%8A%9F%E8%83%BD"><span class="toc-text">2、QUIC新功能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E6%80%BB%E7%BB%93"><span class="toc-text">http总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8Socket%E5%BB%BA%E7%AB%8B%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-text">利用Socket建立网络连接的步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3xss%EF%BC%8Ccsrf%EF%BC%8Cddos%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E9%81%BF%E5%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">理解xss，csrf，ddos攻击原理以及避免方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#websocket%E5%92%8Chttp"><span class="toc-text">websocket和http</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CDN-%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C"><span class="toc-text">CDN-内容分发网络</span></a></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js`,
    marked: `https://cdn.jsdelivr.net/npm/marked@13.0.1/lib/marked.umd.min.js`
  }
  

</script>

<script type="text/javascript">
  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },
    
    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function(response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function(data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function(error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
  };
</script>

<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>


<!-- required -->
<script src="/js/main.js?v=1.29.1" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    applyThemeToGiscus(theme)
  }

  const applyThemeToGiscus = (theme) => {
    theme = theme === 'auto' ? 'preferred_color_scheme' : theme

    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)

    const messages = {
      light: `切换到浅色模式`,
      dark: `切换到深色模式`,
      auto: `切换到跟随系统配色`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    }
  })()
</script>


<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
